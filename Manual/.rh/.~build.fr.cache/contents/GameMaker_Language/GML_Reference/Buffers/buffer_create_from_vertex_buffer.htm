buffer_create_from_vertex_buffer Vous utilisez cette fonction pour allouer une partie de la mémoire en tant que tampon dans votre jeu rempli des données d'un tampon de vertex créé précédemment. La fonction renvoie un identifiant de tampon unique qui doit être stocké dans une variable et utilisé pour tous les appels de fonction ultérieurs au tampon. La fonction prend l'identifiant du tampon de vertex à utiliser (tel que renvoyé par la fonction vertex_create_buffer(), par exemple) avec les constantes suivantes utilisées pour définir le type de tampon: Constant Description buffer_fixed Un tampon de taille fixe. buffer_grow Un tampon qui «grandira» dynamiquement à mesure que des données sont ajoutées buffer_wrap Un tampon dans lequel les données seront «enveloppées». Lorsque les données ajoutées atteignent la limite de la taille de la mémoire tampon, l'écrasement sera replacé au début de la mémoire tampon et une nouvelle écriture se poursuivra à partir de ce point. buffer_fast Tampon spécial "dépouillé" extrêmement rapide en lecture / écriture. Ne peut être utilisé qu'avec buffer_u8 types de données et doit être aligné sur 1 octet. buffer_vbuffer Ce type de tampon doit être utilisé uniquement comme tampon de sommets. Outre le type de tampon, vous devrez également définir l' alignement des octets pour le tampon. Cette valeur varie en fonction des données que vous souhaitez stocker dans la mémoire tampon, et dans la plupart des cas, une valeur de 1 convient parfaitement. Cependant, sachez que pour certaines opérations, un alignement spécifique est essentiel et qu'un alignement incorrect peut provoquer des erreurs (pour plus de détails sur l'alignement, voir Tampons ). Ce qui suit est un guide général pour montrer quelles valeurs sont les plus appropriées pour chaque type de données (en cas de doute, utilisez un alignement de 1): Les chaînes doivent être alignées sur 1 octet. Les entiers 8 bits signés ou non signés peuvent être alignés sur n'importe quelle valeur, mais notez que pour un tampon rapide (voir buffer_write() ) il doit être aligné sur 1. Les entiers 16 bits signés ou non signés doivent être alignés sur 2 octets. Les entiers 32 bits signés ou non signés doivent être alignés sur 4 octets Les flotteurs jusqu'à 16 bits doivent être alignés sur 2 octets. (Pas actuellement pris en charge!) Les flotteurs jusqu'à 32 bits doivent être alignés sur 4 octets. Les flottants jusqu'à 64 bits doivent être alignés sur 8 octets. REMARQUE: les tampons de sommet sont alignés sur 1 octet, mais vous pouvez créer le tampon avec n'importe quel alignement en fonction de la façon dont vous souhaitez traiter les données, car les données de sommet sont simplement une copie de mémoire brute dans le tampon. REMARQUE: il est important que vous supprimiez de la mémoire toutes les ressources créées dynamiquement comme celle-ci lorsque vous n'en avez plus besoin pour éviter les fuites de mémoire.Par conséquent, lorsque vous avez terminé avec le tampon que vous avez créé, vous devez le libérer à nouveau en utilisant buffer_delete (). Notez également que le tampon de vertex utilisé pour créer le nouveau tampon n'est pas non plus supprimé de la mémoire et que vous devez utiliser la fonction vertex_delete_buffer () lorsqu'elle n'est plus nécessaire. Syntaxe:buffer_create_from_vertex_buffer(vertex_buffer, type, alignment) Argument Description vertex_buffer Index de tampon de sommet à utiliser. type Le type de tampon à créer (voir la liste des constantes ci-dessus). alignment L'alignement des octets pour le tampon Retour:Int (Vertex buffer ID) Exemple:player_buffer = buffer_create_from_vertex_buffer(model_buffer, buffer_grow, 1); Le code ci-dessus alloue de la mémoire à un tampon puis copie les données du tampon de vertex donné dans celui-ci, renvoyant l'index du nouveau tampon qui est stocké dans la variable "player_buffer", pour une utilisation future.  Retour: Tampons Suivant:buffer_create_from_vertex_buffer_ext © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

