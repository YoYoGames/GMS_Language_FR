 Surfaces Dans les événements de dessin normaux, GameMaker Studio 2 ne dessine pas directement sur l'écran, mais dessine plutôt sur une surface appelée surface d'application. Cette surface est essentiellement un «canevas» vierge qui peut ensuite être manipulé avant d'être dessiné à l'écran si nécessaire, et dans la plupart des cas, GameMaker Studio 2 gère cela pour vous (bien que vous puissiez également le manipuler vous-même dans le code pour les shaders, la mise à l'échelle et beaucoup d'autres choses - plus de détails sont donnés ci-dessous). Cependant, en plus de cette surface d'application, vous pouvez également créer vos propres surfaces et les utiliser pour créer des effets spéciaux étonnants ou subtils dans votre jeu. Par exemple, vous pouvez utiliser des surfaces pour "attraper" des instances, qui peuvent ensuite être détruites, et de cette façon, vous pouvez créer un effet de décalcomanie où l'image-objet de l'occurrence est affichée sur la surface comme si elle existait toujours, permettant des effets graphiques tels que débris, sang, etc... sans réel frais de traitement. Une autre chose que vous pouvez faire avec les surfaces est de les utiliser comme textures à manipuler, ou pour créer des sprites "à la volée", ou pour créer des superpositions complexes. en fait, les utilisations des surfaces sont infinies! Les surfaces normales sont assez faciles à utiliser, mais il y a quelques règles de base à suivre lorsque vous les utilisez: Tout d'abord, vous devez vous rendre compte que les surfaces ( à l'exception de la surface d'application) sont «volatiles». Cela signifie que si l'appareil ou la fenêtre perd le focus ou est minimisé (les bons exemples sont lorsque vous ALT + Tab vers une fenêtre différente et vice versa sous Windows, ou sur un Android lorsque l'application perd le focus en raison d'un appel), la surface peut être détruit. En effet, il est stocké uniquement dans la mémoire de texture ( VRAM ) et peut être écrasé lorsque la plate-forme cible a besoin de cette mémoire pour autre chose, ce qui signifie que vous devez toujours avoir un type de code de sécurité en place, généralement avec le surface_exists() fonction.  REMARQUE: Cela ne semble pas se produire avec les sprites ou d'autres actifs visuels (mais c'est le cas!) Car ils sont également stockés dans la mémoire normale (RAM) et lorsqu'ils sont supprimés de la mémoire de texture (VRAM), ils sont immédiatement restaurés à partir de la mémoire normale. lorsque le jeu reprend sa concentration. Deuxièmement, vous devez noter que les surfaces peuvent nécessiter de grandes quantités de VRAM pour être utilisées, et vous devez donc essayer de les garder aussi petites que possible. Normalement, vous essayez de ne pas les garder plus grands que la taille de la vue ou de la fenêtre d'affichage. Troisièmement, vous ne devez créer des surfaces que dans l'événement de dessin. Si vous créez une surface dans l'événement Create d'une instance, vous pourriez potentiellement obtenir le même index que le application_surface. Cela peut alors causer beaucoup de problèmes et de confusion car vous pensez que vous utilisez votre propre surface, mais que vous utilisez en fait la cible de rendu actuelle. Vous devez également toujours essayer de limiter le dessin à une surface dans l'événement de dessin, car en raison de la manière optimisée dont GameMaker Studio 2 dessine à l'écran, il est recommandé de conserver toutes les fonctions de dessin dans l'événement de dessin - cela inclut la suppression. une surface lors de sa création, etc... Dessiner sur une surface en dehors de l'événement draw est possible et peut même être nécessaire pour certains effets, mais ce n'est pas ainsi que cela doit être fait. Quatrièmement, lorsque vous dessinez manuellement sur une surface, la surface est toujours à la position (0,0). Cela signifie que vous devrez peut-être convertir des coordonnées absolues en coordonnées relatives pour la surface. Par exemple, si vous avez une surface de la taille d'une caméra et que vous souhaitez dessiner quelque chose qui est actuellement visible dans la caméra sur cette surface, vous devez soustraire les coordonnées x et y de la vue de la caméra des coordonnées x et y réelles pour obtenir une position relative à la position de la surface (0,0). Ainsi, le code ressemblerait à ceci:  si view_current = 0 { surface_set_target (surf); avec (obj_Effect) { var _vx = camera_get_view_x (view_camera [1]); var _vy = camera_get_view_y (view_camera [1]); draw_sprite (sprite_index, image_index, x - _vx, y - _vy); } surface_reset_target (); } autre { draw_surface (surf, 0, 0); } Enfin, il convient de noter que le dessin sur une surface prendra en considération la couleur et la composante alpha de chaque pixel, à la fois de la surface elle-même et également de ce qui est dessiné sur elle. Cela peut conduire à des résultats plutôt peu intuitifs (par exemple, dessiner un sprite avec 0,5 alpha sur une surface avec 0 alpha donnera un alpha final de 0,25). Les raisons en sont expliquées sur la page suivante et nous vous recommandons de la lire avant de travailler avec des surfaces: Guide d'utilisation des modes de fusion REMARQUE: ce n'est pas le cas de la surface d'application, uniquement des surfaces créées par l'utilisateur. L'utilisation de base d'une surface serait la suivante: Vous créez d'abord une surface et affectez son index à une variable. Vous définiriez alors la cible du dessin sur la surface plutôt que sur l'affichage. Ensuite, vous dessinez les choses que vous souhaitez et effectuez toutes autres manipulations. Une fois que vous avez terminé, vous réinitialisez la cible du dessin afin que tous les autres dessins se reproduisent à l'écran. Enfin, vous dessineriez la surface (ou l'utiliser dans un shader, ou tout ce qui est nécessaire). Une chose à noter est que si vous avez besoin de dessiner tout l'affichage sur une surface (y compris les carreaux, les arrière-plans, etc.), vous pouvez simplement accéder à la surface de l'application elle-même (voir ci-dessous pour plus de détails) ou vous pouvez attribuer une surface à une vue. port en utilisant la variable view_surface_id[0..7] comme avec ceci, tout ce qui est visible dans ce port de vue sera dessiné sur la surface correspondante. Les fonctions suivantes existent pour gérer les surfaces (ces fonctions sont spécifiques à la création et à la manipulation de surfaces, mais pour les dessiner à l'écran, vous devez utiliser les fonctions de dessin spécifiques qui peuvent être trouvées ci-dessous): surface_existssurface_createsurface_create_extsurface_resizesurface_set_targetsurface_set_target_extsurface_get_targetsurface_get_target_extsurface_reset_targetsurface_copysurface_copy_partsurface_depth_disablesurface_get_heightsurface_get_widthsurface_get_texturesurface_get_depth_disablesurface_getpixelsurface_getpixel_extsurface_freesurface_savesurface_save_part Les fonctions suivantes existent pour dessiner des surfaces: REMARQUE: lorsque vous travaillez avec des surfaces, il est possible qu'elles cessent d'exister à tout moment car elles sont stockées dans la mémoire de texture. Vous devez TOUJOURS vérifier qu'une surface existe en utilisant surface_exists () avant de les référencer directement. draw_surfacedraw_surface_extdraw_surface_partdraw_surface_part_extdraw_surface_stretcheddraw_surface_stretched_extdraw_surface_tileddraw_surface_tiled_extdraw_surface_general Enfin, vous disposez de deux fonctions pour stocker et récupérer des surfaces dans les tampons:buffer_get_surfacebuffer_set_surface Comme mentionné ci-dessus, GameMaker Studio 2 ne rend pas la plupart des éléments directement à l'écran, mais au lieu de cela, il les rend à la surface de l'application. Il s'agit essentiellement d'une surface - comme tout ce que vous pouvez créer vous-même en utilisant les fonctions de surface - et en tant que telle, elle peut être manipulée, dessinée, envoyée aux shaders, etc... Fondamentalement, tout ce que vous feriez normalement avec une surface que vous créé peut également être appliqué à la surface d'application. REMARQUE: la seule chose que vous ne pouvez pas faire avec la surface d'application est de la libérer. Il existe toujours, bien que la valeur d'index pour y accéder puisse changer. Lorsque vous exécutez votre jeu, cette surface est créée la première fois que l' événement de tirage est appelé dans chaque nouvelle salle dans laquelle vous entrez, ce qui signifie que rien n'est dessiné jusqu'à ce point. Cependant, vous pouvez toujours obtenir la position de la surface de l'application et la redimensionner dans l' événement Créer ou tout autre événement sans obtenir d'erreurs et les valeurs utilisées seront pertinentes pour la surface lors de sa création. La séquence réelle des événements pour la création et le dessin de la surface d'application est la suivante: Événement pré-tirage ---> la surface d'application est créée (si elle n'existe pas) et la cible de rendu est définie Pour chaque port de vue visible, ou, si aucun port de vue n'est actif, une fois Événement de début de tirage au sort Événement de tirage au sort Événement de fin de tirage au sort ---> la cible de rendu de la surface d'application est réinitialisée ici Événement post-tirage ---> la surface de l'application est maintenant dessinée dans le tampon d'affichage par défaut (bien que vous puissiez désactiver cette fonction en utilisantapplication_surface_draw_enable() ) Draw GUI begin événement Dessiner un événement GUI Dessiner l'événement de fin de l'interface graphique L'utilisation de cette surface signifie que vous pouvez facilement créer des transitions incroyables à l'aide de shaders, ou prendre l'écran et l'enrouler autour d'une forme 3D, ou simplement faire évoluer un jeu basse résolution jusqu'à n'importe quelle résolution d'écran... Les possibilités sont infinies! Pour accéder à cette surface, vous devez utiliser la variable globale intégrée application_surface qui est expliqué à la page suivante:application_surface Vous disposez également de quelques fonctions spécialisées conçues uniquement pour être utilisées avec la surface d'application: application_surface_enableapplication_surface_is_enabledapplication_get_positionapplication_surface_draw_enable Retour: Dessin Suivant: Éclairage © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

