 Séquences Les séquences sont généralement créées dans l'EDI à l'aide de l' éditeur de séquence, mais elles peuvent également être créées et modifiées à l'aide de code. Cependant, avant de regarder les fonctions disponibles, il est important de comprendre la façon dont les séquences sont définies dans GameMaker et les différents termes qui seront utilisés. Pour commencer, au niveau supérieur, vous avez un élément de séquence. C'est ce que vous placez sur un calque dans une pièce, soit via l'éditeur de pièce, soit dans le code en utilisant les fonctions de calque appropriées. L'élément de couche n'a pas de propriétés réelles autres qu'une valeur d'ID d'élément, mais cet ID est nécessaire pour utiliser les fonctions de couche mentionnées ci-dessus pour changer la lecture de séquence ou pour accéder aux données de séquence. Ensuite, vous avez des objets de séquence et des instances de séquence, tout comme vous avez des objets et des instances généraux. Un objet séquence est la ressource de base telle que vous l'avez créé dans le navigateur de ressources ou à l'aide de la fonction sequence_create(), et l' instance de séquence est la "copie" de cet objet séquence qui a été placé dans une pièce en tant qu'élément sur un calque. Considérez les objets de séquence comme des plans et les instances de séquence comme la création à partir de ces plans. Les objets et les instances de séquence sont des structures et - contrairement aux objets ordinaires - une structure d'objet de séquence peut être modifiée à l' runtime, ce qui affectera toutes les autres instances de cette séquence lorsque vous les créez en tant qu'éléments (et toute modification effectuée sur un objet de séquence ne sera pas réinitialisée. en redémarrant le jeu ou la salle à l'aide du room_restart() ou game_restart() les fonctions). La structure d'instance de séquence contient quelques paramètres pour contrôler la lecture et les choses (cela est expliqué plus en détail ci-dessous) ainsi que la structure de données de séquence. Enfin, comme mentionné ci-dessus, vous avez les données de séquence, qui sont une autre structure. Cette structure contient toutes les données sur la séquence. Les pistes qu'il contient, les propriétés de ces pistes, la vitesse de lecture et bien plus encore. Les détails exacts du contenu de ces structures sont décrits ci-dessous, mais se composent essentiellement de structures de suivi d'actifs et de structures de suivi de paramètres qui utilisent des données d' keyframe pour effectuer réellement des actions pendant la lecture de la séquence. Les éléments de séquence sont traités à l'aide des fonctions de couche de pièce, mais pour les objets de séquence, les instances et les données, nous avons les fonctions suivantes: sequence_existssequence_createsequence_destroysequence_getsequence_track_newséquence_ keyframe _new séquence_ keyframe data_newsequence_get_objectssequence_instance_override_object Il existe également une variable intégrée associée aux instances qui peut être utilisée pour déterminer si l'instance a été utilisée dans une séquence ou non:in_sequence IMPORTANT! Si votre séquence contient des instances, ces instances ne doivent pas changer leurimage_xscale /image_yscale / image_angle /x /y variables car elles seront écrasées lorsque la séquence sera mise à jour à chaque étape après le début de la lecture. Avant d'utiliser ces fonctions pour créer ou modifier des séquences, nous vous recommandons de lire les descriptions détaillées ci-dessous pour les propriétés de la structure. Un aperçu général de la façon de créer une nouvelle séquence serait: Créez le nouvel objet séquence à l'aide de la fonction seqeunce_create() et stocker l'index d'objet de séquence dans une variable. Cet index vous donne accès à la structure de l'objet séquence.myseq = sequence_create(); Définissez les valeurs de niveau supérieur de l'objet séquence telles que la longueur, le mode de lecture, la vitesse de lecture, etc. Par exemple:myseq.length = 120; myseq.loopmode = seqplay_pingpong Avant de pouvoir ajouter des pistes à l'objet séquence, vous devez les créer, donc vous allez maintenant créer un tableau de pistes d'actifs qui ont été définies avec la fonction sequence_track_new(). Notez que dans le code, il n'y a vraiment aucune différence entre les pistes d'actifs et les pistes de paramètres - ce sont toutes simplement des pistes et leur comportement dépendra du type de piste que vous créez et si elles sont affectées en tant que sous-pistes à une piste de niveau supérieur ou ne pas. Ainsi, vous créeriez une piste pour un actif, puis affecteriez des sous-pistes pour les différents paramètres à celui-ci et ces sous-pistes agiraient comme les pistes de paramètres pour l'actif. L'exemple ci-dessous crée une seule piste d'actif graphique qui sera ajoutée ultérieurement à la séquence:var mytracks = array_create(1); mytracks[0] = sequence_track_new(seqtracktype_graphic); Chaque piste d'actif doit avoir des données pour dire à la séquence à quoi elle ressemblera, ou sa position, etc... et cela est ajouté sous la forme d' keyframes. Au niveau supérieur d'une piste d'actif, vous pouvez définir des keyframes pour diverses choses (répertoriées dans la section sur la structure de piste, ci-dessous), mais notez que comme il s'agit d' keyframes piste d'actif, elles ne seront pas interpolées et changeront simplement le valeur à laquelle ils se réfèrent lorsque la trame donnée est atteinte. Chaque keyframe est une structure qui est ajoutée à un tableau, puis ce tableau est affecté à la piste d'actif. Pour créer la keyframe nous appellerions la fonction sequence_keyframe_new() et pour remplir l' keyframe avec les données requises, nous utiliserions la fonction sequence_keyframedata_new():// Create a new keyframe struct for a graphics asset track and add it to an array (as you can have multiple keys in a frame) var graphickeys = array_create(1); graphickeys[0] = sequence_keyframe_new(seqtracktype_graphic); // Set the graphics
    keyframe top level data for the keyframe position and length, etc... graphickeys[0].frame = 0; graphickeys[0].length = 1; graphickeys[0].stretch = true; graphickeys[0].disabled = false; // Create the channel data that will
    go into this keyframe (again an array, as each key can have multiple channels of keyframe data) var graphickeydata = array_create(1); graphickeydata[0] = sequence_keyframedata_new(seqtracktype_graphic); graphickeydata[0].spriteIndex
    = spr_Platform; graphickeydata[0].channel = 0; // Add the keyframe data channels to the graphics track keyframe graphickeys[0].channels = graphickeydata; // Add the definied keyframes to the track mytracks[0].name = "TestGraphicTrack";    mytracks[0].keyframes = graphickeys; Nous devons maintenant créer une piste de paramètres que nous attribuerons en tant que sous-piste à la piste graphique que nous venons de créer. Cela sera fait de la même manière que ci-dessus, seulement maintenant nous devons donner à la piste un nom qui montre son but, dans ce cas "position" car nous allons utiliser cette piste pour déplacer la piste de la piste graphique sur le parcours des images d'animation de séquence:// Create a new parameter track struct for the position of the graphic var paramtracks = array_create(1); paramtracks[0] = sequence_track_new(seqtracktype_real); paramtracks[0].name = "position"; paramtracks[0].interpolation
    = true; // Create the keyframe struct to hold the parameter channel data and set the frame position for the keyframe var paramkeys = array_create(2); paramkeys[0] = sequence_keyframe_new(seqtracktype_real); paramkeys[0].frame =
    0; paramkeys[1] = sequence_keyframe_new(seqtracktype_real); paramkeys[1].frame = 120; // Create the keyframe data structs var paramkeydata1 = array_create(2); paramkeydata1[0] = sequence_keyframedata_new(seqtracktype_real);    paramkeydata1[0].channel = 0; // Channel 0 for a position track is the X position paramkeydata1[0].value = 0; paramkeydata1[1] = sequence_keyframedata_new(seqtracktype_real); paramkeydata1[1].channel = 1; // Channel 1 for a position
    track is the Y position paramkeydata1[1].value = 0; var paramkeydata2 = array_create(2); paramkeydata2[0] = sequence_keyframedata_new(seqtracktype_real); paramkeydata2[0].channel = 0; paramkeydata2[0].value = room_width;    paramkeydata2[1] = sequence_keyframedata_new(seqtracktype_real); paramkeydata2[1].channel = 1; paramkeydata2[1].value = room_height; // Assign the keyframe data structs to the channels for each key paramkeys[0].channels = paramkeydata1;    paramkeys[1].channels = paramkeydata2; // Assign the keys to the parameter track paramtracks[0].keyframes = paramkeys; Une fois cela fait, la dernière chose à faire est d'assigner la piste de paramètres en tant que sous-piste à notre piste d'actif graphique principale que nous avons créée au début, puis d'affecter ces pistes à la séquence dont nous pouvons ensuite créer une instance dans la pièce.:mytracks[0].tracks = paramtracks; myseq.tracks = mytracks; layer_sequence_create("Assets_1", 0, 0, myseq); Les instructions ci-dessus créent un objet séquence très simple qui dessine un sprite à la position (0, 0) de la séquence, puis le déplace vers le coin inférieur droit et retourne en boucle. Comme mentionné, il existe un certain nombre d'endroits où vous devez accéder à différentes structures pour donner ou obtenir des données sur la séquence, et les sections ci-dessous répertorient toutes les différentes propriétés que ces structures contiennent: La structure de l'objet de séquence La structure d'instance de séquence La structure de la voie La Keyframe La Keyframe données d'images clés Enfin, il est possible d'ajouter du code à des séquences qui peuvent être déclenchées soit comme un événement à un moment, soit comme un message diffusé. Ceci est expliqué en détail sur la page suivante: Événements, moments et messages diffusés  Retour: Asset Management Suivant: Polices © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

