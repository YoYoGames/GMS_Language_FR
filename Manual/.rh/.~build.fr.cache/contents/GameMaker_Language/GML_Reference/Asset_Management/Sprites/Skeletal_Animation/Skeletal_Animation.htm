 Sprites d'animation squelettique Les fonctions trouvées dans cette section sont uniquement destinées à être utilisées avec des sprites qui ont été importés à partir d'un fichier d'animation squelettique (en particulier, les fichiers JSON que Spine exporte) et peuvent être utilisées pour obtenir des informations sur un actif d'animation dans votre jeu, ainsi que pour définir certaines propriétés dans une animation. Ces fonctions peuvent être utilisées avec les fonctions et variables de sprite normales, vous permettant (par exemple) de mélanger deux animations squelettes à l'aide de ces fonctions spéciales tout en définissant l'échelle de l'image à l'aide des variables d'instance de sprite normales (pour plus d'informations sur les variables d'instance de sprite voir ici ). REMARQUE: pour plus d'informations sur l'importation de sprites d'animation squelettiques créés avec Spine, veuillez consulter la section Importer des sprites non bitmap. Vous pouvez en savoir plus sur les fonctions de ces types de sprites dans les sections ci-dessous: Animation Skins Pièces jointes Des os Machines à sous Dessin et divers Support noir de teinte Cette fonction permet aux zones sombres des emplacements de sprite Spine d'être teintées différemment des zones claires (il s'agit d'une fonction IDE Spine, voir la section Teinte noire ici pour plus de détails). Actuellement, pour utiliser cette fonctionnalité dans GameMaker Studio 2, vous devez utiliser un shader personnalisé lors du dessin d'un sprite Spine qui l'utilise. Ce shader contient une variable uniforme globale appelée "gm_SpineTintBlackColour "que le coureur remplit avec la couleur de teinte noire actuelle, extraite automatiquement des données Spine. Le shader requis est indiqué ci-dessous: Vertex Shader (c'est le même que le shader vertex passthrough par défaut)attribute vec3 in_Position; // (x,y,z) attribute vec4 in_Colour; // (r,g,b,a) attribute vec2 in_TextureCoord; // (u,v)
     varying vec2 v_vTexcoord; varying vec4 v_vColour;
     void main() {
     vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0); gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos; v_vColour = in_Colour; v_vTexcoord = in_TextureCoord; }
   Le Fragment Shader:varying vec2 v_vTexcoord; varying vec4 v_vColour;
     uniform vec4 gm_SpineTintBlackColour; // This is the uniform containing the tint-black colour
     void main() {
     vec4 tb = gm_SpineTintBlackColour; vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord ); vec4 outcol; outcol.rgb = v_vColour.rgb * texcol.rgb; outcol.rgb += tb.rgb * ((tb.a * (texcol.a - 1.0)) + (1.0 - texcol.rgb)); //
    This line performs the tint-black blending logic outcol.a = v_vColour.a * texcol.a; gl_FragColor = outcol; }
   Vous utiliseriez ceci en appelant d'abord le shader, puis en dessinant le sprite, puis en réinitialisant le shader, quelque chose comme ceci: shader_set(shd_spine_tint_black); draw_self();
     shader_reset();
   Retour: Sprites Suivant: Informations sur les sprites © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

