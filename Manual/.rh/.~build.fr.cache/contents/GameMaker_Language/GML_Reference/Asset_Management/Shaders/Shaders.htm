 Shaders Shaders sont un outil incroyablement puissant pour manipuler quoi et comment les choses sont rendues à l'écran par la carte graphique. Étant donné que ces petits programmes sont en fait exécutés sur la carte graphique elle-même, cela signifie qu'ils sont extrêmement rapides à traiter, ce qui libère de précieux cycles de processeur pour plus de logique de jeu. Pour créer un shader, vous aurez besoin d'avoir écrit à la fois un Vertex Shader et un fragment Shader (également comme Pixel Shader ) en utilisant le Shader Editor, et même si (par exemple) que vous souhaitez seulement changer les positions des sommets pour un être d'instance dessiné, ou si vous souhaitez uniquement modifier les valeurs de couleur des pixels, vous aurez toujours besoin des deux programmes pour qu'un shader complet fonctionne. REMARQUE: Shaders ne vous permettent pas de modifier la valeur de toutes les variables que vous passez en eux, et donc ceux - ci seront appelés shader constantes dans toute la documentation qui fait référence à eux. Pour un aperçu complet des fonctions et variables GLSL ES disponibles que vous pouvez utiliser pour programmer les shaders eux-mêmes, veuillez consulter les pages de référence OpenGL ES Shading Language (GLSL ES). Le lien suivant est également utile car il contient des cartes de référence rapide pour l'API OpenGL ES (notez que seules les deux dernières cartes affichées sont applicables à GameMaker Studio 2 ): Cartes de référence OpenGL ES. L'utilisation d'un shader dans vos projets est très simple et ne nécessite que quelques lignes de code pour en tirer le meilleur parti:shader_set(myShader); draw_self();
     shader_reset();
   Comme vous pouvez le voir, ils sont utilisés de la même manière pour les modes de fusion et les surfaces, où vous sélectionnez (définissez) d'abord le shader, dessinez ce que vous voulez en l'utilisant, puis réinitialisez à nouveau la cible de dessin par la suite. Si vous souhaitez rendre le plein écran à travers un shader, et pas seulement un sprite ou un arrière-plan unique, vous devrez configurer une surface pour capturer la vue actuelle, puis la transmettre au shader (voir Surfaces pour plus d'informations). REMARQUE: les Shaders, comme tout ce qui concerne le dessin, ne peuvent être utilisés que dans l'événement draw. Il est également intéressant de noter que si vous essayez d'utiliser une valeur de couleur dans un shader et que l'objet n'a pas de texture, les résultats deviendront noirs. Si le shader vous utilisez a des valeurs d'entrée, celles-ci sont définies à l'aide des fonctions uniformes. Vous obtiendrez d'abord le handle uniforme (qui est essentiellement une valeur d'ID pour l'uniforme à définir) en utilisant la fonction shader_get_uniform() dans l' événement Create de l'instance à l'aide du shader, puis stockez ces poignées dans des variables, quelque chose comme ceci:colour_to_find = shader_get_uniform(sShaderDemo5, "f_Colour1"); colour_to_set = shader_get_uniform(sShaderDemo5, "f_Colour2"); Une fois que vous avez les poignées uniformes, elles peuvent être définies dans le shader pour l' événement Draw comme ceci:shader_set(sShaderDemo5); shader_set_uniform_f(colour_to_find, 1,1,1 ); shader_set_uniform_f(colour_to_set, 1,0,0 ); draw_sprite(sprite_index,image_index,x+24, y); shader_reset();
   Une dernière chose à noter est que bien que les shaders soient acceptés sur toutes les plates-formes, ils sont toujours spécifiques à l'appareil et si le matériel ou le logiciel de l'appareil ne peut pas utiliser les shaders vous obtiendrez une erreur. Par conséquent, il est recommandé de vérifier que le shader a été compilé avant de définir des uniformes ou d'utiliser le shader lui-même, comme ceci:if (shader_is_compiled(myShader))     {
         shader_set(myShader);
         draw_self();
         shader_reset();
         }
     else show_debug_message("Shader failed"); Comme contrôle supplémentaire, vous pouvez également appeler la fonction shaders_are_supported() pour voir si le matériel prend même en charge les shaders. En général, vous effectuez ces vérifications au démarrage du jeu et stockez les résultats sous forme de variable globale GML _Overview / Variables / Global_Variables.htm "> pour ensuite vérifier plus tard. Il est important de noter que GameMaker Studio 2 prend également en charge certaines macros de compilation conditionnelles qui peuvent être utilisées dans les shaders GLSL ES afin qu'ils puissent exécuter un code alternatif sur des plates-formes prises en charge spécifiques. Les macros et les plates-formes sur lesquelles elles seront générées sont indiquées dans le tableau ci-dessous: Macro de Shader Évaluer Plateforme cible _YY_GLSLES_ 1 Toutes les plateformes cibles _YY_GLSL_ 2 Mac et Ubuntu ( Linux ) _YY_HLSL11_ 3 Windows, UWP, XboxOne _YY_PSSL_ 4 PS4 Lorsque vous compilez votre GameMaker Studio 2 sur l'une des plates-formes répertoriées à l'aide d'un shader format GLSL ES, l' une des macros ci-dessus sera générée et pourra ensuite être utilisée vérifiée dans le shader comme ceci:#ifdef _YY_HLSL11_ // HLSL shader code here #else
     // GLSL shader code here #endif
   Si vous êtes nouveau dans les shaders ou si vous souhaitez un guide plus complet pour les créer et les utiliser à l'aide de GameMaker Studio 2, veuillez consulter la page suivante du manuel: Guide d'utilisation des Shaders Les fonctions suivantes sont disponibles pour dessiner et définir des shaders: shader _get_name shader _get_uniform shader _get_sampler_index shader _set shader _set_uniform_f shader _set_uniform_f_array shader _set_uniform_i shader _set_uniform_i_array shader _set_uniform_matrix shader _set_uniform_matrix_array shader _reset shader _is_compilé shaders _sont_supportés shader _current Nous avons également une fonction spéciale qui définit un état global pour tous les shaders: shader _enable_corner_id Lorsque vous travaillez avec des échantillonneurs de texture dans des shaders vous aurez besoin d'informations sur la texture utilisée, auquel cas vous pouvez utiliser les fonctions suivantes: sprite_get_texturesprite_get_uvsfont_get_texturefont_get_uvstexture_get_widthtexture_get_heighttexture_get_texel_widthtexture_get_texel_heighttexture_set_stagegpu_set_texfilter_extgpu_set_texrepeat Bien que ce manuel ne couvre aucune des shader Open GL, il contient une liste de celles qui sont uniques à GameMaker Studio 2. Ces constantes ne font pas partie de la spécification Open GL pour les shaders et sont fournies pour simplifier l'intégration des shaders dans vos projets. Constantes de Shader Enfin, GameMaker Studio 2 vous permet de définir vos propres formats de sommets à partir desquels vous pouvez créer vos propres primitives personnalisées. Cela peut considérablement accélérer les shader ou peut être utilisé pour étendre leurs capacités et créer des effets surprenants. Vous pouvez trouver des informations à ce sujet dans les sections suivantes: Primitives et formats de sommets  Retour: Asset Management Suivant: Séquences © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

