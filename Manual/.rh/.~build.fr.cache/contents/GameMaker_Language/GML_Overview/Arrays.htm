 Tableaux Les tableaux peuvent être extrêmement utiles et sont un élément essentiel de la création de jeux. Voici quelques éléments qui seraient impossibles (ou du moins beaucoup plus difficiles) sans tableaux: Menus. Un tableau ou deux peuvent faciliter la création d'un bon système de menus. RPG. Les tableaux sont essentiels pour créer des RPG, car au lieu d'avoir un fouillis de variables, vous n'avez que quelques lignes, auxquelles vous pouvez vous référer à tout moment. Jeux de cartes. Bon pour garder une trace des cartes et des mains. Des scores élevés et d'autres statistiques. Il est beaucoup plus facile de suivre un tableau que plusieurs variables. Ce n'est que la pointe de l'iceberg, car les tableaux sont l'un des outils de programmation les plus fondamentaux et les plus utiles que vous puissiez utiliser, et vous seriez surpris des applications qu'ils peuvent avoir! Ils sont également très efficaces en mémoire et généralement rapides à analyser, ce qui les rend idéaux pour maintenir les performances au maximum. Un tableau de base est classé comme ayant une dimension, mais vous pouvez également avoir des tableaux avec plusieurs dimensions. Les sections ci-dessous expliquent un peu plus les deux types de tableaux: Tableaux à 1 dimension Avant d'aller plus loin, clarifions simplement ce qu'est réellement un tableau et comment il est structuré. Un tableau est simplement un type de données affecté à une variable, et il peut contenir non seulement une valeur, mais plusieurs valeurs. L'image ci-dessous montre un schéma pour un tableau de base: C'est ce qu'on appelle un tableau 1D (une dimension), et comme vous pouvez le voir, le tableau est stocké dans la variable "a "et contient plusieurs valeurs. Pour accéder au tableau, procédez comme suit:var _val = a[0]; show_debug_message(_val);
     Le code ci-dessus obtient la valeur de la position 0 du tableau "a" puis la renvoie à la console, qui - en fonction du contenu du tableau montré dans l'image ci-dessus - produirait 125. Si vous avez fait ce qui suit:var _val = a[3]; show_debug_message(_val);
     La sortie afficherait "Salut!". Comme vous pouvez le voir, vous donnez au tableau un nom de variable puis une valeur entre crochets [], où la valeur est la position dans le tableau à partir de laquelle obtenir les données. Donc, essentiellement un tableau est un conteneur avec un certain nombre d'espaces pour stocker des valeurs, et chaque position dans le conteneur a un numéro spécifique pour l'identifier, ce que nous mettons dans le []. Il est à noter que le contenu d'un tableau commence toujours à 0 et ne peut jamais être négatif! Nous avons montré comment vérifier un tableau pour les données, mais comment créer le tableau pour commencer? Il faut d'abord l' initialiser avant de pouvoir l'utiliser, GameMaker Studio 2 nous donnera une erreur. L'initialisation d'un tableau signifie simplement que nous donnons à chaque position du tableau une valeur initiale en vue de son utilisation ailleurs dans le code du projet. Ceci est important à retenir car cela signifie que vous devez faire un certain temps de planification avant d'utiliser des tableaux, mais il est assez facile d'en initialiser un en utilisant une boucle de répétition comme celle-ci...var i = 9; repeat(10)
           {
           array[i] = 0;     i -= 1;     }
     Ce code simple initialisera un tableau à dix positions (de 0 à 9) pour tenir 0, c'est-à-dire: chaque position du tableau contient la valeur 0. Vous remarquerez que le tableau a été initialisé à l' envers, la dernière valeur étant définie en premier. Ce n'est pas strictement nécessaire, mais la façon optimale de le faire comme il réservera un espace mémoire qui est la taille exacte du tableau, alors que si vous initialisez un tableau de 0 vers le haut, la mémoire doit être réaffectés pour chaque une valeur ajoutée supplémentaire (donc pour un tableau de dix éléments, l'initialiser dans une boucle changerait l'allocation de mémoire dix fois). La différence de vitesse est négligeable pour les petits tableaux, mais les plus grands doivent être optimisés autant que possible de cette manière. REMARQUE: L'exportation HTML5 est l'exception à la règle ci-dessus, et lors du ciblage, vous devez initialiser les tableaux dans un ordre consécutif à partir de 0. Vous pouvez également utiliser la fonction GML array_create() pour initialiser un tableau à une taille fixe, et vous pouvez même créer des tableaux «vides» sans valeurs, par exemple:my_array= []; Cela indique à GameMaker que la variable "my_array" est un tableau, et vous pouvez ensuite y ajouter des valeurs à tout moment dans le futur. Cependant, si vous essayez d'accéder à une valeur dans un tableau vide, vous obtiendrez une erreur. En fait, vous devez toujours veiller à accéder uniquement aux positions de tableau valides, car essayer d'accéder à une valeur en dehors d'un tableau donnera également une erreur. Par exemple, cela entraînera le blocage du projet lors de son exécution:my_array = array_create(5, 0); var _val = my_array[6]; Le tableau n'a été initialisé qu'avec 5 positions, mais nous avons essayé d'obtenir la position 7 - les tableaux sont numérotés à partir de 0, donc array[6] est la position 7 - pour cela, le jeu génère une erreur et plante. Nous avons montré comment initialiser un tableau avec la même valeur pour chaque position, mais que faire si nous voulons initialiser le tableau avec des valeurs différentes pour chaque position? Eh bien, pour cela, nous devons taper manuellement chaque position nous-mêmes, mais il y a une belle astuce pour nous aider à garder une trace des choses là-bas:var _count = 3; array[_count] = "you?" count -= 1; array[_count] = "are " count -= 1; array[_count] = "How " count -= 1; array[_count] = "Hello!" count -= 1; Comme vous pouvez le voir, nous n'avons utilisé aucun nombre dans le tableau réel, mais plutôt une variable locale pour effectuer le décompte des valeurs. Ceci est très utile, en particulier pour les tableaux plus grands, car cela signifie que vous n'avez pas à suivre le nombre de positions ni le numéro sur lequel vous vous trouvez, car le code se chargera de cela pour vous. Vous avez juste besoin de savoir combien de positions totales le tableau doit contenir. Enfin, vous pouvez affecter les valeurs à un tableau en utilisant un seul appel de variable comme celui-ci:var _a = [0, 1, 2, 3, 4]; var _b = []; Ce qui précède va créer deux tableaux en tant que variables locales, le premier déjà rempli de 5 éléments et le second en tant que tableau vide prêt à recevoir des valeurs ajoutées. Une fois cela fait, comment utiliser un tableau pour des choses pratiques? Exactement la même chose que nous utiliserions une variable normale, comme le montrent les exemples suivants:// Add two array values together total = array[0] + array[5];
       // Check an array value if (array[9]) == 10     {
           //do something     }
      
       // draw an array value draw_text(32, 32, array[3]); Étant donné que les tableaux sont numérotés consécutivement, cela signifie que vous pouvez également les parcourir pour effectuer des actions supplémentaires, tout comme nous l'avons fait pour l'initialiser:var total = 0; for (var i = 0; i < 10; ++i;)     {
           total += array[i];     draw_text(32, 32 + (i * 32), array[i]);     }
       draw_text(32, 32 + (i * 32), total); Le code ci-dessus ajoutera toutes les valeurs de notre tableau, dessinera chacune d'elles et dessinera la valeur totale à la fin. La dernière chose à mentionner à propos des tableaux est que vous pouvez également supprimer un tableau simplement en "réaffectant" la variable qui le définit à une valeur unique. Cela libérera la mémoire associée à toutes les positions et valeurs de ce tableau. Par exemple://Create the array for (var i = 9; i > -1; --i;)     {
           a[i] = i;     }
       //Delete the array a = -1; Si le tableau a plusieurs dimensions (voir ci-dessous), ils seront tous nettoyés également, et notez que lorsque vous créez des tableaux dans des instances, ceux-ci n'ont pas besoin d'être nettoyés lorsque l'instance est supprimée du jeu, car ils le seront. supprimé automatiquement par le ramasse -miettes à la fin de la destruction ou de la salle. Cependant, si l'une des positions du tableau contient des références à des actifs dynamiques - tels que des systèmes de particules, des tampons ou des structures de données - alors ceux- ci devront être détruits avant que le tableau ne soit supprimé ou que l'instance soit détruite ou que la pièce se termine. Baies multidimensionnelles Nous savons ce qu'est un tableau à 1 dimension, mais dans GameMaker Studio 2 vous pouvez avoir des tableaux à plusieurs dimensions, qui sont essentiellement structurés comme un tableau à l'intérieur d'un tableau à l'intérieur d'un tableau... Par exemple, ce qui suit est un 2D (deux dimensions) déployerarray[0][0] = 5; GameMaker essentiellement à GameMaker que le tableau est en fait composé de divers tableaux 1D. Voici un exemple détaillé:array[1][2] = 1; array[1][1] = "hello"; array[1][0] = 55.5; array[0][2] = sprite_index; array[0][1] = "world"; array[0][0] = -67.89; Un tableau multidimensionnel doit être initialisé avant utilisation, comme un seul tableau 1D, et peut contenir des nombres réels, des chaînes et tout autre type de données, comme n'importe quelle variable, ce qui en fait des candidats idéaux pour tout jeu qui doit stocker de grandes quantités de données d'une manière facilement accessible (rappelez-vous, vous pouvez facilement parcourir un tableau en boucle). Voici un dernier exemple de la façon dont cela peut être utilisé dans un jeu réel... Supposons que vous souhaitiez engendrer quatre ennemis différents à quatre points différents de votre jeu en fonction d'une valeur aléatoire. Eh bien, nous pouvons utiliser un tableau avec 2 dimensions pour ce faire et économiser l'écriture d'une charge de code. Nous devons d'abord initialiser le tableau que nous allons utiliser dans l'événement create de notre objet "controller" (notez l'utilisation de commentaires pour vous rappeler ce que fait chaque entrée du tableau):enemy[3][2] = 448;       //y position enemy[3][1] = 32;        //x position enemy[3][0] = obj_Slime; //Object enemy[2][2] = 448; enemy[2][1] = 608; enemy[2][0] = obj_Skeleton; enemy[1][2] = 32; enemy[1][1] = 608;      enemy[1][0] = obj_Knight; enemy[0][2] = 32; enemy[0][1] = 32; enemy[0][0] = obj_Ogre; Nous avons maintenant les objets pour générer des instances et leurs coordonnées d'apparition x et y correspondantes dans la pièce, tous stockés dans notre tableau. Cela peut maintenant être utilisé comme suit dans un autre événement de l'objet contrôleur (une alarme par exemple, ou un événement de pression de touche)://get a random number from 0 to 3, inclusive var i = irandom(3); //Use the array to create the object instance_create_layer(enemy[i][1], enemy[i][2], "Enemy_Layer", enemy[i][0]); Ce code court va maintenant engendrer un ennemi aléatoire dans la salle de jeu, et il utilise beaucoup moins de code qu'un "if / then / else "structure ou même un "switch ", et comme le tableau est initialisé tous ensemble dans l'événement de création, il est BEAUCOUP plus facile d'éditer et de changer l'une de ces valeurs car elles ne sont pas codées en dur dans le reste du code du projet. Il convient également de noter que la longueur de chaque dimension dans le tableau peut être différente, vous pouvez donc avoir la dimension initiale du tableau avec une longueur de 3, mais la deuxième entrée de dimension peut être une longueur différente pour chacune des valeurs initiales du tableau il est affecté, par exemple:array[2][2] = "3"; array[2][1] = "2"; array[2][0] = "1"; array[1][3] = "four"; array[1][2] = "three"; array[1][1] = "two"; array[1][0] = "one";      array[0][1] = 2; array[0][0] = 1; Enfin, les tableaux multidimensionnels ne sont pas limités à seulement deux dimensions, et vous pouvez avoir 3, 4 dimensions ou plus dans un tableau comme requis dans votre code, simplement en ajoutant [n] autres arguments, par exemple:array[0][0][0] = 1;     // A three dimensional array array[0][0][0][0] = 1;  // A four dimensional array // etc... Tout comme les variables normales, vous pouvez transmettre des tableaux aux fonctions de script et aux variables de méthode à utiliser, puis les renvoyer à l'instance qui a appelé la fonction. Pour ce faire, il vous suffit de spécifier la variable du tableau (pas besoin de chacune des positions individuelles, ni de la [] crochets) et le tableau entier sera passé par référence dans la fonction. Cependant, si vous modifiez l'une des valeurs du tableau, le tableau sera copié dans un tableau temporaire uniquement pour cette fonction. Notez l'utilisation du mot temporaire ici! Vous ne passez pas réellement le tableau lui-même dans la fonction (comme vous le feriez pour une variable), mais vous demandez plutôt que la fonction crée une copie de ce tableau, que vous allez modifier. Cela signifie que vous devez toujours renvoyer le tableau à partir de la fonction si vous souhaitez modifier les valeurs du tableau (ce comportement est appelé « copie à l'écriture »). REMARQUE: en raison de la façon dont cela fonctionne en interne, le passage de tableaux à des fonctions peut affecter les performances, en particulier si le tableau est très volumineux. Alors utilisez cette fonctionnalité avec précaution! À titre d'exemple, considérez le code suivant. Nous créons d'abord le tableau que nous voulons utiliser, puis nous passons ce tableau à la fonction:for (var i = 9; i > -1; --i;)     {
         a[i] = i;     }
     my_array_func(a);
   La fonction elle-même est quelque chose de simple comme:my_array_func = function(array)     {
         for (var i = 9; i > -1; --i;)         {
             array[i] = i * 100;         }
         }
   Maintenant, vous vous attendez à ce que le tableau final contienne les valeurs 900, 800, 700, etc... MAIS ce ne sera pas le cas, puisque nous n'avons pas renvoyé le tableau de la fonction, donc tout ce que nous avons changé était la copie temporaire qui était créé lorsque nous avons passé le tableau en tant qu'argument dans la fonction, et lorsque la fonction est terminée, cela disparaît également. Pour remédier à cela, nous aurions dû formater le code comme suit:for (var i = 9; i > -1; --i;)     {
         a[i] = i;     }
     a = my_array_func(a); Et la fonction devrait maintenant ressembler à ceci:my_array_func = function(array)     {
         for (var i = 9; i > -1; --i;)         {
             array[i] = i * 100;         }
         return array;     }
   REMARQUE: ce qui précède n'est pas nécessaire si vous ne modifiez aucune des valeurs de tableau, mais si vous les référencez simplement. Le référencement d'un tableau ne le copiera pas et sera plus rapide à analyser. Il convient également de noter que vous pouvez utiliser l'accesseur @ pour référencer un tableau à partir d'une fonction et modifier ses valeurs directement, ce qui évite la surcharge du processeur liée à sa copie dans la fonction. Vous pouvez trouver plus d'informations sur les accesseurs et leur fonctionnement, ainsi qu'un exemple pour les tableaux, à partir de la page suivante: Accesseurs  Retour: Présentation de GML Suivant: Types de données © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

