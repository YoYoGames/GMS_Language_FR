
  
  Tableaux
  Les tableaux peuvent être extrêmement utiles et constituent un élément essentiel de la création de jeux. Voici quelques exemples de choses qui seraient impossibles (ou du moins beaucoup plus difficiles) sans les tableaux :
  
    Les menus. Un tableau ou deux peuvent faciliter la création d'un bon système de menus.
    RPGs. Les tableaux sont essentiels pour la création de RPG, car au lieu d'avoir un fouillis de variables, vous n'avez que quelques lignes, auxquelles vous pouvez vous référer à tout moment.
    Jeux de cartes. Idéal pour garder la trace des cartes et des mains.
    Les meilleurs scores et autres statistiques. Il est beaucoup plus facile de garder la trace d'un tableau que de multiples variables.
  
  Ce n'est que la partie visible de l'iceberg, car les tableaux sont l'un des outils de programmation les plus fondamentaux et les plus utiles que vous puissiez utiliser, et vous seriez surpris des applications qu'ils peuvent avoir ! Ils sont également très efficaces en termes de mémoire et généralement rapides à analyser,
    ce qui les rend idéaux pour maintenir les performances au maximum.
  Un tableau de base est classé comme ayant une dimension, mais vous pouvez aussi avoir des tableaux avec plus d'une dimension. Les sections ci-dessous expliquent un peu plus les deux types de tableaux : 
   
  Tableaux à 1 dimension
  
    Avant d'aller plus loin, précisons ce qu'est un tableau et comment il est structuré. Un tableau est tout simplement un type de données qui est assigné à une variable, et il peut contenir non seulement une valeur, mais de multiples
      valeurs. L'image ci-dessous montre le schéma d'un tableau de base : 
    
    C'est ce qu'on appelle un tableau 1D (une dimension), et comme vous pouvez le voir, le tableau est stocké dans la variable "a" et contient plusieurs valeurs. Pour accéder au tableau, il faut faire quelque chose comme ce qui suit :
    var _val = a[0] ; show_debug_message(_val) ;
    
    Le code ci-dessus récupère la valeur de la position 0 du tableau "a" puis l'envoie à la console, qui - sur la base du contenu du tableau montré dans l'image ci-dessus - devrait afficher 125. Si vous faites ce qui suit :
    var _val = a[3] ; show_debug_message(_val) ;
    
    La sortie indiquerait "Salut !".
    Comme vous pouvez le voir, vous donnez au tableau un nom de variable, puis une valeur entre crochets [], où la valeur est la position dans le tableau pour obtenir des données. Donc, essentiellement, un tableau est un conteneur avec un certain nombre d'espaces pour
      stocker des valeurs, et chaque position dans le conteneur a un numéro spécifique pour l'identifier, qui est ce que nous mettons dans le []. Il est intéressant de noter que le contenu d'un tableau commence toujours à 0 et ne peut jamais être négatif !
    Nous avons montré comment vérifier la présence de données dans un tableau, mais comment créer le tableau pour commencer ? Il faut d'abord l'initialiser avant de pouvoir l'utiliser, sinon GameMaker Studio 2 nous enverra une erreur. L'initialisation d'un tableau signifie simplement que nous donnons à chaque position du tableau une valeur initiale dans le tableau.
      position du tableau une valeur initiale en vue de son utilisation dans le code du projet. Il est important de s'en souvenir car cela signifie que vous devez faire un peu de planification avant d'utiliser des tableaux, mais il est assez facile d'en initialiser un en utilisant une boucle répétitive comme celle-ci.
      un tableau en utilisant une boucle répétitive comme ceci...
    var i = 9 ; repeat(10)
       {
       array[i] = 0 ; i -= 1 ; }
    
    Ce code simple initialisera un tableau de dix positions (de 0 à 9) pour contenir 0, c'est-à-dire que chaque position du tableau contient la valeur 0. Vous remarquerez que le tableau a été initialisé à l'envers, la dernière valeur étant définie en premier. Ce
      Ce n'est pas strictement nécessaire, mais c'est la meilleure façon de procéder, car cela permet de réserver un espace en mémoire qui correspond à la taille exacte du tableau, alors que si vous initialisez un tableau à partir de 0, la mémoire doit être réallouée pour chaque valeur supplémentaire ajoutée (ainsi, pour un tableau de dix éléments, la mémoire doit être réallouée pour chaque valeur supplémentaire).
      supplémentaire ajoutée (ainsi, pour un tableau de dix éléments, l'initialiser dans une boucle modifierait dix fois l'allocation de mémoire). La différence de vitesse est négligeable pour les petits tableaux, mais les tableaux plus grands devraient être optimisés autant que possible de cette manière.
    REMARQUE: L'exportation HTML5 est l'exception à la règle ci-dessus, et lorsque vous ciblez cette cible, vous devez initialiser les tableaux dans un ordre consécutif à partir de 0.
    Vous pouvez également utiliser la fonction GML array_create() pour initialiser un tableau à une taille fixe, et vous pouvez même créer des tableaux "vides" sans valeur, par exemple :
    mon_tableau= [] ;
    Cela indique à GameMaker que la variable "mon_tableau" est un tableau, et que vous pouvez donc y ajouter des valeurs à tout moment. Cependant, si vous essayez d'accéder à une valeur dans un tableau vide, vous obtiendrez une erreur. En fait, vous devez toujours veiller à
      attention à n'accéder qu'aux positions valides du tableau, car si vous essayez d'accéder à une valeur en dehors d'un tableau, vous obtiendrez également une erreur. Par exemple, cela provoquera un crash du projet lors de son exécution :
    mon_tableau = array_create(5, 0) ; var _val = mon_tableau[6] ;
    Le tableau n'a été initialisé qu'avec 5 positions, mais nous avons essayé d'obtenir la position 7 - les tableaux sont numérotés à partir de 0, donc array[6] est la position 7 - le jeu génère donc une erreur et se plante.
    Nous avons montré comment initialiser un tableau avec la même valeur pour chaque position, mais que faire si nous voulons initialiser le tableau avec des valeurs différentes pour chaque position ? Pour cela, nous devons saisir manuellement chaque position, mais il existe une astuce intéressante pour nous aider à garder la trace de ces valeurs.
      il existe une astuce pour nous aider à garder la trace des choses :
    var _count = 3 ; array[_count] = "you ?" count -= 1 ; array[_count] = "are " count -= 1 ; array[_count] = "How " count -= 1 ; array[_count] = "Hello !" count -= 1 ;
    Comme vous pouvez le constater, nous n'avons pas utilisé de chiffres dans le tableau proprement dit, mais plutôt une variable locale pour décompter les valeurs. C'est très utile, surtout pour les tableaux de grande taille, car cela signifie que vous n'avez pas à suivre le nombre de positions ni le numéro sur lequel vous vous trouvez.
      car cela signifie que vous n'avez pas besoin de savoir combien de positions il y a ni sur quel numéro vous êtes, car le code s'en occupe pour vous. Il suffit de connaître le nombre total de positions que le tableau doit contenir.
    Enfin, vous pouvez affecter les valeurs à un tableau en utilisant un appel de variable unique comme ceci :
    var _a = [0, 1, 2, 3, 4] ; var _b = [] ;
    L'exemple ci-dessus créera deux tableaux en tant que variables locales, le premier étant déjà peuplé de 5 éléments et le second étant un tableau vide prêt à recevoir des valeurs.
    Ceci étant fait, comment utiliser un tableau pour des choses pratiques ? Exactement de la même manière que nous utiliserions une variable normale, comme le montrent les exemples suivants :
    // Additionne deux valeurs de tableau total = tableau[0] + tableau[5] ;
       // Vérifie une valeur de tableau if (tableau[9]) == 10 {
       // Faire quelque chose }
      
       // Dessine une valeur de tableau draw_text(32, 32, array[3]) ;
    Comme les tableaux sont numérotés consécutivement, cela signifie que vous pouvez les parcourir en boucle pour effectuer des actions supplémentaires, comme nous l'avons fait pour les initialiser :
    var total = 0 ; for (var i = 0 ; i < 10 ; ++i ;) {
       total += tableau[i] ; draw_text(32, 32 + (i * 32), tableau[i]) ; }
       draw_text(32, 32 + (i * 32), total) ;
    Le code ci-dessus va additionner toutes les valeurs de notre tableau, dessiner chacune d'entre elles et afficher la valeur totale à la fin.
    La dernière chose à mentionner à propos des tableaux est que vous pouvez également supprimer un tableau simplement en "réassignant" la variable qui le définit à une valeur unique. Cela libérera la mémoire associée à toutes les positions et valeurs de ce tableau.
      Par exemple :
    //Créer le tableau for (var i = 9 ; i > -1 ; --i ;) {
       a[i] = i ; }
       //Supprimer le tableau a = -1 ;
    Si le tableau a plusieurs dimensions (voir ci-dessous), elles seront toutes nettoyées également, et notez que lorsque vous créez des tableaux dans des instances, ceux-ci n'ont pas besoin d'être nettoyés lorsque l'instance est retirée du jeu, car ils seront supprimés automatiquement par le garbage collector lors de la destruction ou de la fin de la room.
      automatiquement par le ramasseur d'ordures à la destruction ou à la fin de l'instance. Cependant, si l'une des positions du tableau contient des références à des actifs dynamiques - comme des systèmes de particules, des tampons ou des structures de données
      - alors celles-ci devront être détruites avant que le tableau ne soit supprimé ou que l'instance ne soit détruite ou que la pièce ne se termine.
     
  
  Matrices multidimensionnelles
  
    Nous savons ce qu'est un tableau à une dimension, mais dans GameMaker Studio 2, vous pouvez avoir des tableaux à plusieurs dimensions, qui sont essentiellement structurés comme un tableau dans un tableau dans un tableau... Par exemple, le tableau suivant est un tableau 2D (à deux dimensions)
    tableau[0][0] = 5 ;
    Cela revient à dire à GameMaker que le tableau est en fait composé de plusieurs tableaux 1D. Voici un exemple détaillé :
    array[1][2] = 1 ; array[1][1] = "hello" ; array[1][0] = 55.5 ; array[0][2] = sprite_index ; array[0][1] = "world" ; array[0][0] = -67.89 ;
    Un tableau multidimensionnel doit être initialisé avant d'être utilisé, de la même manière qu'un tableau simple à 1D, et peut contenir des nombres réels, des chaînes de caractères et tout autre type de données, comme n'importe quelle variable.
      qui a besoin de stocker de grandes quantités de données d'une manière facilement accessible (rappelez-vous que vous pouvez facilement boucler dans un tableau). Voici un dernier exemple de la façon dont cela peut être utilisé dans un jeu réel... Supposons que vous vouliez faire apparaître quatre ennemis différents à quatre moments
      points de votre jeu en fonction d'une valeur aléatoire. Eh bien, nous pouvons utiliser un tableau à 2 dimensions pour le faire et éviter d'écrire une grande quantité de code.
    Tout d'abord, nous devons initialiser le tableau que nous allons utiliser dans l'événement create de notre objet "controller" (notez l'utilisation de commentaires pour vous rappeler ce que fait chaque entrée du tableau) :
    ennemi[3][2] = 448 ; //position y ennemi[3][1] = 32 ; //position x ennemi[3][0] = obj_Slime ; //Objet ennemi[2][2] = 448 ; ennemi[2][1] = 608 ; ennemi[2][0] = obj_Skeleton ;  ennemi[1][2] = 32 ; ennemi[1][1] = 608 ; ennemi[1][0] = obj_Knight ; ennemi[0][2] = 32 ; ennemi[0][1] = 32 ; ennemi[0][0] = obj_Ogre ;
    Nous avons maintenant les objets pour créer des instances et leurs coordonnées x et y correspondantes dans la pièce, le tout stocké dans notre tableau. Ceci peut maintenant être utilisé comme suit dans un autre événement de l'objet contrôleur (une alarme par exemple, ou une pression de touche
      ) :
    //obtient un nombre aléatoire de 0 à 3, inclus var i = irandom(3) ; //Utilise le tableau pour créer l'objet instance_create_layer(enemy[i][1], enemy[i][2], "Enemy_Layer", enemy[i][0]) ;
    Ce court code va maintenant faire apparaître un ennemi aléatoire dans la salle de jeu, et il utilise beaucoup moins de code qu'une structure " if /then / else " ou même un " switch ", et commele tableau est initialisé tous ensemble dans l'événement create
      il est BEAUCOUP plus facile d'éditer et de modifier n'importe laquelle de ces valeurs car elles ne sont pas codées en dur dans le reste du code du projet.
    Il faut également noter que la longueur de chaque dimension du tableau peut être différente, ainsi vous pouvez avoir la dimension initiale du tableau avec une longueur de 3, mais la deuxième entrée de la dimension peut avoir une longueur différente pour chacune des valeurs initiales du tableau.
      à laquelle elle est affectée, par exemple :
    tableau[2][2] = "3" ; tableau[2][1] = "2" ; tableau[2][0] = "1" ; tableau[1][3] = "quatre" ; tableau[1][2] = "trois" ; tableau[1][1] = "deux" ; tableau[1][0] = "un" ; tableau[0][1] = 2 ; tableau[0][0] = 1 ;
    Enfin, les tableaux multidimensionnels ne sont pas limités à deux dimensions, et vous pouvez avoir 3, 4 ou plus de dimensions à un tableau selon les besoins de votre code, en ajoutant simplement [n] arguments supplémentaires, par exemple :
    array[0][0][0] = 1 ; // Un tableau à trois dimensions array[0][0][0][0] = 1 ; // Un tableau à quatre dimensions // etc...
  
   
  Tout comme les variables normales, vous pouvez transmettre des tableaux aux fonctions de script et aux variables de méthode pour qu'ils soient utilisés puis renvoyés à l'instance qui a appelé la fonction. Pour ce faire
    vous devez simplement spécifier la variable tableau (pas besoin de chacune des positions individuelles, ni des parenthèses [] ) et le tableau entier sera passé par référence dans la fonction. Cependant, si vous modifiez une
    des valeurs du tableau, celui-ci sera copié dans un tableau temporaire réservé à cette fonction. Notez l'utilisation du mot temporaire ici ! Vous ne passez pas réellement le tableau lui-même dans la fonction (comme vous le feriez avec une
    ), mais vous demandez à la fonction de créer une copie de ce tableau, que vous allez modifier. Cela signifie que vous devez toujours retourner le tableau depuis la fonction si vous souhaitez modifier une valeur du tableau (ce comportement est appelé " copy on write ").
    ce comportement est appelé " copyon write ").
  NOTE : En raison de la façon dont cela fonctionne en interne, le passage de tableaux aux fonctions peut affecter les performances, en particulier si le tableau est très grand. Utilisez donc cette fonctionnalité avec précaution !
  À titre d'exemple, considérons le code suivant. D'abord, nous créons le tableau que nous voulons utiliser, puis nous passons ce tableau à la fonction :
  for (var i = 9 ; i > -1 ; --i ;) {
     a[i] = i ; }
     mon_tableau_func(a) ;
  
  La fonction elle-même est quelque chose de simple comme :
  my_array_func = function(array) {
     for (var i = 9 ; i > -1 ; --i ;) {
     array[i] = i * 100 ; }
     }
  
  Maintenant, on pourrait s'attendre à ce que le tableau final contienne les valeurs 900, 800, 700, etc... MAIS ce ne sera pas le cas, puisque nous n'avons pas retourné le tableau depuis la fonction, donc tout ce que nous avons changé est la copie temporaire qui a été créée lorsque nous avons passé le tableau
    comme argument dans la fonction, et lorsque la fonction est terminée, cette copie temporaire disparaît également. Pour rectifier cela, nous aurions dû formater le code comme suit :
  for (var i = 9 ; i > -1 ; --i ;) {
     a[i] = i ; }
     a = my_array_func(a) ;
  Et la fonction devrait maintenant ressembler à ceci :
  my_array_func = function(array) {
     for (var i = 9 ; i > -1 ; --i ;) {
     array[i] = i * 100 ; }
     return array ; }
  
  NOTE : Ce qui précède n' est pas nécessaire si vous ne modifiez aucune des valeurs du tableau, mais que vous les référencez simplement. Le fait de référencer un tableau ne le copiera pas et sera plus rapide à analyser.
  Il convient également de noter que vous pouvez utiliser l'accesseur @ pour référencer un tableau à partir d'une fonction et modifier ses valeurs directement, ce qui permet d'éviter la surcharge du processeur due à la copie du tableau dans la fonction. Vous pouvez trouver plus d'informations sur les accesseurs
    et leur fonctionnement, ainsi qu'un exemple pour les tableaux, à la page suivante :
  
    Accesseurs
  
   
   
   
  
    
      
        Retour : Aperçu duGML
        Suivant : Types de données
      
    
    Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

