 Expressions et opérateurs Une expression est une phrase mathématique qui peut contenir des nombres ordinaires, des variables, des chaînes ou des fonctions ainsi qu'un ou plusieurs opérateurs (comme ajouter, soustraire, multiplier, etc.). Les valeurs utilisées dans une expression peuvent être des nombres réels (par exemple 3.4 * 6 ), nombres hexadécimaux commençant par un $ signe (par exemple $00FFAA | $88FFAA ), des chaînes entre guillemets (par exemple "hello" + "world" ) ou des expressions plus compliquées utilisant plusieurs opérateurs et valeurs. Pour les expressions, les opérateurs suivants existent (par ordre de priorité): Assigner (=) = - Utilisé pour attribuer une valeur à une variable. Notez que cela peut également être utilisé pour comparer des variables dans GameMaker Studio 2 et vous pouvez le voir dans des exemples et des codes d'autres personnes. Cependant, il s'agit d'un héritage des anciennes GameMaker et vous devez utiliser les opérateurs == pour comparer et = pour attribuer, comme indiqué dans ces exemples:a = 12; speed = 5; val = (old_val + 5); Combiner (&&, ||, ^^) &&, ||, ^^ (et, ou et xor) - Combine des valeurs booléennes pour donner soit vrai ou faux. Si l'un des exemples suivants se résout en true alors le code serait exécuté:if (a == b && c == d) {do something...}  // and if (a == b || c ==d) {do something...}   // or if (a == b ^^ c == d) {do something...}  // xor Comparaison (<, <=, ==,! =,>,> =) <, <=, ==,! =,>,> = - Ce sont des comparaisons et ne peuvent donner qu'un true ou false result (où true peut également être interprété comme 1 et false comme 0). Exemples d'utilisation:if (a < b) {do something...} if (a != b) {do something...} Au niveau du bit (|, &, ^, <<, >>) |, &, ^, <<, >>: Vous pouvez effectuer des opérations au niveau du bit avec ceux-ci, où | = bit à bit ou, & = bit à bit et, ^ = bit à bit xor, << = décalage à gauche, >> = décalage à droite. Exemples d'utilisation:x = (x & $ffffffe0) + 32; if (y ^ $1f) > 0 {do something...}; Vous pouvez trouver des informations supplémentaires sur l'utilisation des opérateurs bit à bit et ce qu'ils font dans la section: Opérateurs bit à bit. Arithmétique (+, -, *, /) +, -, *, / - Additionnez, soustrayez, multipliez et divisez. Exemples d'utilisation:c = a * b; str = a + "world"; REMARQUE: les nombres à virgule flottante ne s'arrêtent pas sur Diviser par zéro car ils obtiendront une infinité comme réponse. Si A et B sont des entiers (int32 ou int64), la division sera effectuée sous forme d'entiers (et la division par 0 sera vérifiée et une erreur sera commise. Sinon, elle sera effectuée comme une division en virgule flottante (sans division par 0) ). Incrémenter / Décrémenter (++, -) ++, -: Ajouter ou soustraire un d'une valeur. Il est à noter que placer ceci avant ou après la valeur à ajouter ou à soustraire aura des résultats légèrement différents. Par exemple:++a incrémentera la variable et renverra la valeur incrémentée.a++ incrémentera la variable mais retournera la valeur avant qu'elle ne soit incrémentée. Par conséquent, si vous avez quelque chose comme ça:var a = 1; show_debug_message(string(a++));
       show_debug_message(string(++a));
     La sortie de débogage serait 1 et 3. Voici quelques exemples d'utilisation:for (var i = 0; i < 10; i++;)     {     do something...     };if (hit == true)     {     --score;     } REMARQUE: sur les YoYo (celles marquées (YYC)), ces expressions sont évaluées de gauche à droite, tandis que sur toutes les autres plates-formes cibles, elles sont évaluées de droite à gauche, ce qui signifie que ceci:val = max(num, ++num, num++); donnera des résultats différents selon la plate-forme. Division et Modulo (div,%, mod) div, mod (%) - Division et modulo, où div vous donne le montant qu'une valeur peut être divisée en produisant uniquement un quotient entier, tandis que mod ne vous donne que le reste d'une division. Notez que vous ne pouvez diviser ou modifier qu'en utilisant des valeurs entières. Exemples d'utilisation:secs = time mod 60; time_str = string(time div 60); Unaire (!, -, ~) En outre, les opérateurs unaires suivants existent: !: booléen "non", donc!true == false -: annule la prochaine valeur réelle ou entière (non valide pour les chaînes ou les booléens) ~: annule la valeur suivante au niveau du bit Comme valeurs dans toutes les expressions, vous pouvez utiliser des nombres, des variables ou des fonctions qui renvoient une valeur, et les sous-expressions peuvent également être placées entre crochets. Tous les opérateurs fonctionnent pour les valeurs de nombres réels, mais les comparaisons fonctionnent également pour les chaînes et l' opérateur "+ " peut être utilisé pour concaténer des chaînes. Lorsque vous effectuez plusieurs opérations dans une seule expression, il est très important d'utiliser des crochets () pour séparer l'ordre de fonctionnement, car différentes plates-formes peuvent les exécuter différemment si ce n'est pas explicitement indiqué de cette manière. Par exemple, considérez le code suivant:a = b == c || d; Les différents compilateurs cibles effectueront les opérations dans des ordres différents car ils ne sont pas explicitement affichés, donnant lieu à des résultats "étranges" auxquels vous ne vous attendez pas quand vous jouez à votre jeu. pour éviter cela, utilisez le () pour séparer les parties, comme ceci:a = (b == c || d);   //better a = ((b == c) || d); //best Notez également que lorsque vous utilisez diverses opérations et expressions dans un seul bloc de code, celles-ci doivent également être séparées. Par exemple, ce qui suit ressemble à du code valide: si ma_var == votre_var ++ leur_var; Cependant, le compilateur peut interpréter cela de deux manières:if my_var == your_var++ then their_var;
     // or
     if my_var == your_var then ++their_var; Maintenant, vous pouvez dire en regardant le code que l'un de ceux-ci est un peu stupide, mais c'est parce que nous savons ce que nous voulons accomplir et ce que nous voulons arriver, mais pas le compilateur. Tout ce qu'il voit, ce sont deux variables avec l'opérateur ++ entre elles, il doit donc choisir à laquelle l'appliquer. Par conséquent, vous devez toujours mettre explicitement entre parenthèses les expressions, opérations et instructions. La version correcte du code ci-dessus doit être:if (my_var == your_var) {
     ++their_var;
     }
   Cela peut paraître plus détaillé, mais il n'y a aucune ambiguïté sur les opérations effectuées et il se compilera et se comportera de manière cohérente sur toutes les plates-formes. Notez également que si vous pouvez enchaîner des expressions et des instructions sans utiliser de crochets pour le moment, il s'agit d'une fonctionnalité héritée et que, à l'avenir, il se peut que vous deviez être obsolète et supprimée de GML. est généralement une bonne pratique de toute façon). Voici quelques derniers exemples des différentes expressions:{ x = 23 div 2; colour = $FFAA00 + $00BB12; str = "hello" + "world"; y += 5; x *= y; x = y << 2; x = 23 * ((2 + 4) / sin(y)); b = (x < 5) && !((x == 2) || (x == 4)); }
   Une dernière chose à noter est qu'il existe également des expressions "raccourcis" appelés accesseurs à utiliser avec certaines structures de données et tableaux. Ceux-ci vous permettent d'ajouter ou de remplacer des données dans ces formats rapidement et facilement et sans utiliser d'appels de fonction. Pour plus de détails, veuillez consulter la page suivante Accesseurs  Retour: Présentation de GML Suivant: Accesseurs © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

