 Adressage de variables dans d'autres instances Dans les sections dédiées aux variables, vous avez découvert comment créer et utiliser des variables dans une seule instance, ou sur une portée globale, mais que se passe-t-il si vous voulez qu'une instance accède à une variable dans une autre instance différente? Il y a de nombreux cas où vous voudrez peut-être faire cela, par exemple dans une collision avec un objet de balle, vous voudrez peut-être savoir combien de dégâts la balle fait en accédant à une variable dans la balle, ou vous voudrez peut-être arrêter le mouvement de toutes les boules d'un puzzle, ou vous pouvez déplacer le personnage principal vers une position particulière, ou un certain nombre d'autres situations que vous rencontrez généralement dans n'importe quel jeu. Heureusement, le GameMaker Language est équipé de mécanismes pour y parvenir. L'une des méthodes les plus courantes pour accéder ou modifier une variable dans une autre instance consiste à utiliser son nom d'objet comme identificateur, puis à utiliser un point ". "pour indiquer à GameMaker Studio 2 que la variable utilisée après doit être affectée ou modifiée dans cet objet. La syntaxe est la suivante:<object_id>.<variable> = <value>;  En pratique, cela ressemblerait à ceci:obj_ball.speed = 0; Avec le code ci-dessus, vous définissez la vitesse d'une instance de "obj_ball ". Cependant, si vous avez plus d'une instance de l'objet donné dans la salle, cela s'appliquera à TOUS de la même manière - à moins que vous n'utilisiez HTML5, auquel cas cela n'affectera qu'une seule, mais vous n'avez aucun moyen de le savoir lequel cela affectera - donc si vous avez besoin d'accéder à toutes les instances d'un objet, vous devriez utiliser with(), car il est 100% compatible multiplateforme. En général, ce format ne doit être utilisé que lorsque vous avez une seule instance de l'objet dans la salle, ou (comme vous le verrez dans la partie suivante) lorsque vous avez un ID d' instance spécifique. Vous pouvez également accéder à une seule instance d'un objet lorsqu'il y a plusieurs instances dans la salle en utilisant le nom d'instance unique pour indiquer à GameMaker Studio 2 exactement l'instance à laquelle nous souhaitons nous adresser. La constante de nom d'instance est la constante d'identification unique qui est donnée à chaque instance ajoutée à une salle de votre jeu. Vous pouvez trouver cette constante en double-cliquant sur une instance dans l' éditeur de salle: Notez que ce nom peut être modifié et donner un nom plus descriptif - bien que le nom doive être unique à l'ensemble du jeu - et il peut être utilisé comme côté gauche du point:inst_4DB70D2.speed = 0; Cependant, la méthode de loin la plus courante et la plus pratique consiste à utiliser une variable à gauche du point, tant que la variable en question a stocké un identifiant d'instance valide. Les exemples suivants illustrent cela.// Example 1 var _inst = instance_position(mouse_x, mouse_y, all); if instance_exists(_inst)     {
         _inst.speed = 0;     }
    
     // Example 2 var _inst = instance_create_layer(mouse_x, mouse_y, "Enemies", obj_E_Parent); _inst.direction = point_direction(_inst.x, _inst.y, x, y); _inst.target = id; Dans le code ci-dessus pour l'exemple 1, il y a un instance_exists() appelez le bloc de code. En effet, l'utilisation de la méthode point pour accéder ou modifier une autre valeur d'instance donnera une erreur et plantera le jeu si l'instance n'existe pas, et il est possible que ce soit le cas dans cet exemple. Cependant, nous n'avons pas besoin de la vérification dans les exemples 2 et 3 car nous savons que l'instance est là puisque dans l'exemple 2 nous l'avons créée, et dans l'exemple 3, c'est l'autre instance dans un événement de collision. Cependant, s'il y a une possibilité que l'instance soit détruite, désactivée ou supprimée de la salle lors de l'utilisation de cette méthode, vous devez toujours vérifier au préalable en utilisant le instance_exists() fonction ou le instance_number() fonction. Notez que vous ne pouvez pas utiliser le mot clé spécial "all "avec cette méthode pour cibler toutes les instances (par exemple: all.val = 10 donnerait une erreur), mais vous pouvez utiliser les mots clés "other " et "self "sans problème. Par exemple, en utilisant other en cas de collision:// Example 3 other.hp -= 10; if other.hp <= 0     {
         other.sprite_index = spr_E_Dead;     }
   Il est également important de noter que vous ne pouvez utiliser aucune fonction seule comme côté gauche d'une affectation. Par exemple, le code suivant vous donnerait une erreur:instance_nearest(x, y, obj).speed = 0; La valeur de retour de l'expression dans cet exemple de code est un nombre entier (la valeur d'ID unique pour l'instance la plus proche) et doit donc être placée entre crochets () à utiliser de cette manière et adresser correctement l'instance requise. Le code ci-dessus serait correctement écrit comme suit:(instance_nearest(x, y, obj)).speed = 0;
     //or
    
     var inst = instance_nearest(x, y, obj); inst.speed = 0; Ce sont tous des moyens parfaitement valables de lire, de modifier et de définir des variables dans d'autres instances, et fonctionnent parce que le point est en fait un opérateur. Il prend une valeur comme opérande de gauche et une variable comme opérande de droite, et renvoie l'adresse de cette variable particulière dans l'objet ou l'instance indiqué. Tous les noms d'objets, constantes, identifiants, etc. représentent simplement des valeurs et celles-ci peuvent être traitées comme n'importe quelle autre valeur. L'autre façon de référencer des variables dans une autre instance est d'utiliser la fonction GameMaker Language with(), qui est discuté en détail ici: // This will affect all instances of the object "obj_Enemy" with (obj_Enemy)     {     target = other.parent;     }
     // This will affect one instance of the object "obj_Enemy" var _enemy = instance_nearest(x, y, obj_Enemy); if instance_exists(_enemy)     {     with (_enemy)         {         target_x = mouse_x;            target.y = mouse_y;         }     } Retour: Présentation de GML Suivant: Ordre d'évaluation © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

