 Accesseurs Le GameMaker Language ( GML ) vous permet également d'accéder à certaines structures de données et tableaux en utilisant des expressions logiques appelées accesseurs. Ceci est structuré de la même manière que lorsque vous travaillez normalement avec un tableau, seulement nous utilisons un symbole identifiant avant le premier argument pour indiquer à GameMaker Studio 2 que vous travaillez sur une structure de données (précédemment créée) ou le littéral de tableau. Listes DS [| ] La syntaxe des listes DS est la suivante:list_index[| index] Alors quand tu as utilisé ds_list_create() pour créer votre liste, vous utiliseriez l'index de la liste (que vous avez stocké dans une variable) pour la référencer, la valeur «index» étant la position dans la liste à définir ou à ajouter. Par exemple, le code suivant crée une liste, puis ajoute 10 entrées, définissant chaque entrée sur un nombre aléatoire de 0 à 9:ds = ds_list_create(); var index = 0; repeat(10)
           {
           ds[| index++] = irandom(9);     }
     Notez que si vous utilisez une expression pour ajouter une référence à un index qui a déjà une valeur, la valeur précédente sera remplacée au lieu d'avoir un autre index ajouté à la liste. Pour ajouter d'autres entrées, vous devez connaître la taille de ds_list et les ajouter à la fin. Il est également intéressant de noter que vous pouvez définir un index de liste supérieur à la taille de la liste référencée, ce qui définira cette valeur, en développant la liste en même temps et en initialisant toutes les positions de la liste à la valeur donnée. index comme 0. Une fois que vous avez créé votre structure de liste et l'avez remplie de données, pour obtenir des valeurs de la liste, vous auriez quelque chose comme:value = ds[| 5]; Ce qui précède obtiendra la valeur de la position 5 (le sixième index, puisque les listes commencent à 0) et la stockera dans une variable. Si vous indiquez une position en dehors de la taille de la liste, la valeur undefined sera retourné, que vous pouvez vérifier à l'aide de la fonction is_undefined(). DS Maps [? ] La syntaxe des cartes DS est la suivante:map_index[? key] Après avoir créé votre carte avec ds_map_create(), vous utiliseriez l'index de carte que vous avez stocké dans une variable pour la référencer, la valeur "clé" étant la clé de carte à définir ou à obtenir. Par exemple, le code suivant crée une carte, puis y ajoute quelques entrées à l'aide de cette syntaxe:ds = ds_map_create(); ds[? "Name"] = "Hamish"; ds[? "Company"] = "MacSeweeny Games"; ds[? "Game"] = "Catch The Haggis"; Notez que si la carte contient déjà la même valeur de clé que celle que vous essayez d'ajouter, elle ne créera pas de clé en double avec la nouvelle valeur, mais la valeur précédente sera remplacée. Une fois que vous avez créé votre structure de carte et l'avez remplie de données, pour obtenir les valeurs d'une clé de carte spécifique, vous auriez quelque chose comme ceci:value = ds[? "Name"]; Ce qui précède obtiendra la valeur de la clé "Nom" et la stockera dans une variable, mais sachez que si la clé donnée n'existe pas dans la carte DS, la valeur renvoyée sera undefined. Cela peut être vérifié à l'aide de la fonction is_undefined(). DS Grids [#] La syntaxe de la grille DS est la suivante:grid_index[# xpos, ypos] Après avoir créé votre grille avec le ds_grid_create(), vous utiliseriez l'index de grille que vous avez stocké dans une variable pour la référencer, avec les "xpos" et "ypos" étant la position dans la grille pour obtenir ou définir une valeur. Par exemple, le code suivant crée une grille, l'efface à 0, puis y ajoute quelques entrées:ds = ds_grid_create(); ds_grid_clear(ds, 0); var gw = ds_grid_width(ds) - 1; var gh = ds_grid_height(ds) - 1; repeat(10)
           {
           var xx = irandom(gw);     var yy = irandom(gh);     if (ds[# xx, yy] == 0)         {
               ds[# xx, yy] = 1;         }
           }
     Une fois que vous avez créé votre structure de grille et l'avez remplie de données, pour obtenir des valeurs à partir d'une position de grille spécifique, vous auriez quelque chose comme:value = ds[# mouse_x div 16, mouse_y div 16]; Ce qui précède obtiendra la valeur de la ds_grid donnée en fonction de la position de la souris (divisée par la largeur de la "cellule" dans la pièce pour obtenir l'emplacement correct). Si vous indiquez une position en dehors des limites de la grille, la valeur undefined sera retourné, que vous pouvez vérifier à l'aide de la fonction is_undefined(). Tableaux [@] Les tableaux ont également leurs propres accesseurs qui fonctionnent de la même manière que ceux listés ci-dessus pour les structures de données. Cependant, les accesseurs de tableau ont une propriété intéressante et c'est de vous permettre de modifier un tableau à partir d'une fonction de script oumethod sans avoir à le copier. Lorsque vous passez un tableau dans une fonction, il est passé par référence, ce qui signifie que le tableau lui-même n'est pas donné dans le script mais qu'il est simplement référencé pour obtenir les données. Normalement, si vous devez ensuite changer le tableau, il sera copié dans le script et vous devrez ensuite renvoyer (retourner) le tableau copié pour que le tableau d'origine soit mis à jour. Cela peut entraîner des frais généraux de traitement coûteux et vous pouvez donc utiliser l'accesseur à la place, car cela modifiera directement le tableau d'origine sans qu'il soit nécessaire de le copier. Vous pouvez voir comment cela fonctionne dans les exemples ci-dessous. La syntaxe des tableaux est:array[@ xpos] Après avoir créé votre tableau dans une instance, vous pouvez ensuite le transmettre à un script par référence et utiliser l'accesseur@ pour le changer directement. Par exemple, vous créez le tableau et appelez la fonction comme ceci:array[99] = 0; array_populate(array);
     La fonction elle-même aurait quelque chose comme ceci:function array_populate(_array)     {     var a = _array; var i = 0; repeat(25)         {         i = irandom(99);         while (a[i] != 0)             {             i = irandom(99);             }   
        a[@ i] = 100;         }     } Tout ce que fait cette fonction est de sélectionner 25 positions aléatoires dans le tableau et de définir la valeur de la position de tableau choisie sur 100. REMARQUE: vous ne pouvez pas utiliser l'accesseur de tableau @ lorsque vous travaillez avec leargument[n] tableau dans les fonctions de script. Structs [$] La syntaxe des structures eststruct[$ "name"] Cet accesseur est essentiellement un wrapper pour les fonctions variable_struct_get() et variable_struct_set(), et vous l'utiliseriez comme l'accesseur d'une carte DS. Par exemple, si vous avez créé une structure et que vous souhaitez récupérer une valeur à partir d'une variable appelée "my_health", vous feriez:var _hp = struct[$ "my_health"]; Comme vous pouvez le voir, vous ne fournissez pas la variable elle-même, mais plutôt une chaîne avec la variable. Notez que si la structure n'a pas de variable avec le nom donné, alors l'accesseur retournera undefined comme valeur. Pour définir une variable dans une structure, procédez comme suitstruct[$ "my_score"] = 100; Comme pour obtenir une valeur, vous fournissez le nom de la variable à définir sous forme de chaîne, et il sera défini sur la valeur donnée. Si le nom de variable utilisé n'existe pas dans la structure, il sera créé et mis à la valeur donnée. Une caractéristique importante des accesseurs est le fait qu'ils peuvent être enchaînés. Cela signifie que si vous avez plusieurs structures de données et / ou tableaux imbriqués, il n'est plus nécessaire d'utiliser une variété de fonctions pour accéder à une valeur qui est profondément dans la structure imbriquée. Par exemple, disons que vous avez un tableau et que chaque élément du tableau est une liste DS, comme ceci:array = array_create(3); for (var i = 0; i < 3; ++i;)     {
         array[i] = ds_list_create();     switch(i)
             {
             case 0:             with (obj_Wall) ds_list_add(array[i], id);             break;
             case 1:             with (obj_Door) ds_list_add(array[i], id);             break;
             case 2:             with (obj_Chest) ds_list_add(array[i], id);             break;
             }
         }
   Dans le code ci-dessus, nous avons créé un tableau de 3 éléments et attribué une liste DS à chacun d'eux, puis nous avons rempli les différentes listes avec les ID d'instance de divers objets du jeu. Maintenant, pour accéder à un identifiant dans l'une des listes, nous pouvons faire ce qui suit:var _list = array[0]; var _id = ds_list_find_value(_list, 0); Cependant, vous pouvez faire la même chose en utilisant des accesseurs chaînés d'une manière beaucoup plus propre qui utilise moins de code:var _id = array[0][| 0]; Vous pouvez enchaîner plusieurs accesseurs de cette manière et ils peuvent être de plusieurs types pour accéder aux informations stockées dans chaque partie de la structure imbriquée. Voici quelques exemples supplémentaires:// Access a grid that has been added to a list that is part of a map: var _a = data[? "lists"][| 0][# 0, 0];
     // Access an array nested in a list from a script and modify it: data[| 0][@ 10] = 100;
     // Access a map nested in a grid nested in a list nested in an array: data[0][| 10][# 3, 4][? "key"] = "hello world"; Utiliser des accesseurs chaînés pour les choses signifie non seulement que vous pouvez écrire du code plus compact, mais cela vous permettra également d'utiliser une itération (par exemple, en utilisant un for loop) et d'autres techniques pour accéder à vos données de manière plus propre et plus intuitive. Il est à noter que lorsque vous utilisez des accesseurs de cette manière, vous devez toujours utiliser le @ accesseur pour les tableaux, sinon vous ajouterez une surcharge supplémentaire à toutes les actions en cours d'exécution. Comme mentionné ci-dessus, par défaut, les tableaux sont passés par référence dans les fonctions et utilisent ensuite le comportement «copie à l'écriture» lorsqu'ils sont modifiés. Cependant, si le tableau fait partie d'une chaîne, l'élément précédent de la chaîne sera mis à jour avec le tableau copié et «l'original» sera supprimé. Par exemple, faire quelque chose comme ceci:// In an object event data[| 0][0] = 100;
     // In a function data[| 0][0] = 200; obtient les mêmes résultats que de faire ceci:// In an object event data[| 0][0] = 100;
     // In a function data[| 0][@ 0] = 200; Cependant, le deuxième exemple est meilleur car il fonctionne sans la surcharge inutile de la copie de tout le tableau en premier.  Retour: Présentation de GML Suivant: Fonctions et variables de script © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

