 Variables de méthode Une variable de méthode est essentiellement une variable à laquelle une fonction a été affectée, «liant» la fonction à une instance et vous permettant d'utiliser la variable pour faire référence à la fonction - un peu comme vous utilisez un nom de fonction d' runtime pour faire référence à une -dans la fonction GML La variable utilisée peut être de portée locale, d' instance ou globale (voir ici pour plus d'informations sur la portée de variable). La syntaxe de création d'une variable de méthode est la suivante:<variablename> = function(<parameter1>, <parameter2>, etc... )     {     <statement1>;     <statement1>;     ...     } oufunction <variablename>(<parameter1>, <parameter2>, etc... )     {     <statement1>;     <statement1>;     ...     } En général, cependant, vous utiliserez le premier formulaire pour les méthodes et le second formulaire pour définir les fonctions de script, car le second formulaire attribuera également un index de script au nom de la fonction tandis que le premier formulaire sera une méthode "vraie" (et nécessitent l'utilisation du global s'il est utilisé pour définir une fonction scriptée). REMARQUE: vous pouvez vérifier cela en utilisant les deux formulaires dans le projet, puis en appelant la fonction d' runtime typeof () sur chacun d'eux. L'un sera classé comme un "nombre" - car il renvoie un ID d'index de script - et l'autre sera classé comme une "méthode". Donc, gardez à l'esprit que - en général - nous ferons toujours référence à des fonctions qui n'ont pas été définies avec un index de script lorsque nous parlons de méthodes et de variables de méthode. Ci-dessous, vous pouvez voir trois exemples simples de création d'une variable de méthode à l'aide de différentes portées:// Local var _debug = function(message)     {     show_debug_message(message);     }
     // Instance do_maths = function(val1, val2, val3)     {     return (val1 * val2) - val3;     }
     // Global global.pd = function(_x1, _y1, _x2, _y2);     {     return point_distance(_x1, _y1, _x2, _y2);     } Notez que dans le code ci-dessus, les différents paramètres qui sont donnés comme entrées pour la fonction sont tous nommés et ces noms sont ce qui doit être utilisé dans la fonction pour faire référence aux différentes entrées. Notez également que vous pouvez utiliser le return pour renvoyer une valeur d'une fonction à utiliser ailleurs dans votre code, et qu'une fonction sans valeur de retour définie, retourneraundefined.par défaut. REMARQUE: alors que la variable sera dans la portée choisie, la fonction réelle sera liée à la portée dans laquelle elle a été initialement définie. Par exemple, les fonctions de script sont toutes à portée globale et "indépendantes" (c'est-à-dire qu'elles ne sont associées à aucun instances), mais si vous avez une fonction de script qui crée une autre fonction en tant que variable de méthode et que vous appelez cette fonction de script à partir d'une instance, la fonction utilisée dans le script sera liée à la variable d'instance en tant que méthode. En général, ce n'est pas quelque chose auquel vous devez penser, mais pour des opérations plus complexes avec des variables de méthode, cela vaut la peine d'être pris en considération. Cela s'applique également lors de l'utilisation d'autres constructions commewith - lorsque vous créez une variable de méthode à l'intérieur d'un with, la fonction sera liée à l'instance actuellement dans la portée. Une fois créée, la variable de méthode peut être utilisée comme vous le feriez pour une runtime ou une fonction de script, par exemple:create_vec = function(_x1, _y1, _x2, _y2);     {     var _array;     _array[0] = point_distance(_x1, _y1, _x2, _y2);     _array[1] = point_direction(_x1, _y1, _x2, _y2);     return _array;     } vec = create_vec(x,
    y, mouse_x, mouse_y); Les variables créées dans une fonction suivront les mêmes règles que d'habitude et seront étendues en fonction du mot-clé utilisé ou de la portée de l'appel de fonction. Dans l'exemple ci-dessus, nous utilisons var donc la variable de tableau est dans la portée locale de la fonction. Si nous n'avions pas utilisé le mot-clé, alors la variable aurait été créée sur la portée de l'instance qui a appelé la fonction. Les variables de méthode (et les fonctions de script) peuvent également prendre un nombre variable d'arguments, et vous pouvez utiliser le argument[0... n] pour les paramètres de fonction. Vous pouvez ensuite utiliser la variable intégrée argument_count pour vérifier ces paramètres supplémentaires. Par exemple:/// @function                 create_random(object, layer); /// @param {int}    object    The object to create an instance of /// @param {int}    layer     OPTIONAL! The layer to create it on ///
     /// @description    Create an instance of the given object at a random position on the current layer or on the (optional) given layer
     function create_random(_obj)     {
         var _layer = layer;     if argument_count > 1         {
             _layer = argument[1];         }
         var _x = irandom(room_width);     var _y = irandom(room_height);     instance_create_layer(_x, _y, _layer, _obj);     }
   REMARQUE: vous ne pouvez pas utiliser l' accesseur de tableau @ lorsque vous travaillez avec l' argument[n] tableau. Cependant, l'utilisation du argument[n] n'est pas strictement obligatoire et vous devez également savoir que tous les arguments qui ne sont pas fournis à la fonction (mais que la fonction a un argument spécifié) seront initialisés à "undefined ". Cela signifie que vous n'avez pas besoin d'utiliser la structure mentionnée ci-dessus en utilisant argument_count, et que vous pouvez à la place faire quelque chose comme ceci:function my_func( _value)     {
         _value = is_undefined(_value) ? 10 : _value;     return _value * 10;     }
   Le code ci-dessus vous permet de spécifier une valeur par défaut pour un paramètre si l'argument n'est pas fourni à la fonction. REMARQUE: le code ci-dessus utilise l' opérateur ternaire, sur lequel vous pouvez en savoir plus ici. Une caractéristique intéressante des variables de méthode (et des fonctions de script également) est qu'elles peuvent avoir des variables statiques. Une variable statique est une variable qui est définie la première fois que la fonction est appelée et qui conservera sa valeur à partir de là. Pour créer une variable statique, vous devez la définir à l'aide du static mot-clé, comme indiqué dans cet exemple simple:counter = function()     {     static num = 0;     return num++;     } Dans l'exemple ci-dessus, la variable "num "est une variable statique, et sera donc définie comme 0 la première fois que la fonction est appelée, mais chaque fois que la fonction est appelée après cela, l'initialisation de la variable sera ignorée. Donc, si vous appelez ensuite cette fonction comme ceci:for (var i = 0; i < 10; ++i;)     {     show_debug_message(counter());     } La sortie sera:0 1
     2
     3
     4
     5
     6
     7
     8
     9
   Si vous n'avez pas utilisé le static mot-clé ici alors la sortie serait simplement 0 pour chaque itération de la boucle, puisque la variable "num "sera défini à 0 chaque fois que la fonction est appelée avant d'être renvoyée. Notez qu'une variable statique ne peut être modifiée qu'à l'intérieur de la fonction d'origine, et la renvoyer vous donnera simplement une copie de sa valeur - essentiellement la variable statique partagée peut ne peut être modifié que par la fonction qui le contient. Une variable statique est toujours initialisée en haut de la méthode (ou de la fonction de script), donc peu importe où vous définissez une variable statique dans la fonction, elle sera toujours disponible pour être lue et modifiée dans toute la fonction (même si elle est utilisée avant en cours de définition). Consultez l'exemple suivant:function add_health()     {     my_health ++;     show_debug_message(my_health);     static my_health = 1;     } Ici, la variable statique " my_health " est modifiée et imprimée dans la sortie du compilateur avant d' être initialisée. Bien que cela semble faux, c'est parfaitement bien car les variables statiques sont initialisées avant l'exécution de tout code de fonction. Notez que s'il y a plusieurs variables statiques dans une fonction, l'ordre dans lequel elles ont été définies sera conservé lors de leur initialisation en haut. Vous pouvez également utiliser le static mot-clé dans une méthode (et une fonction de script) pour créer une fonction statique, ce qui - comme avec les variables - signifie simplement que la fonction ne sera définie qu'une seule fois, ce qui est la première fois que la méthode est appelée, par exemple:Vector2 = function( _x, _y ) constructor     {     x = _x;     y = _y;     static Add = function( _other )         {         x += _other.x;         y += _other.y;         }     } Dans l'exemple ci-dessus, la fonction Vector2 peut être utilisé pour créer une structure, et la structure aura des variables, dont l'une est la variable de méthode Add. Puisque cette variable a été définie comme statique, la fonction à laquelle elle fait référence ne sera initialisée qu'une fois la première fois Vector2 function est appelée, et toutes les autres structures créées avec ce constructeur référenceront la fonction Add qui a été créé initialement, au lieu de créer une nouvelle fonction pour chaque structure (pour plus d'informations sur les structures et le constructor mot-clé s'il vous plaît voir ici ). Ci-dessous, nous listons quelques fonctions d'assistance associées aux variables de méthode: is_method method method_get_self method_get_index  Retour: Présentation de GML Suivant: Structs © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

