
  
  Variables de la méthode
  Une variable de méthode est essentiellement une variable à laquelle une fonction a été attribuée, ce qui permet de "lier" la fonction à une instance et d'utiliser la variable pour faire référence à la fonction, tout comme vous utilisez un nom defonction d'exécution pour faire référence à une fonction GML intégrée . La variable utilisée peut avoir une portée locale, d'instance ou globale (voir ici pour plus d'informations sur la portée des variables).
  La syntaxe pour créer une variable de méthode est la suivante :
  <variablename> = function(<parameter1>, <parameter2>, etc... ) {
     <déclaration1> ; <déclaration1> ;... }
  
  ou
  fonction <variablename>(<parameter1>, <parameter2>, etc... ) {
     <déclaration1> ; <déclaration1> ;... }
  
  En général, cependant, vous utiliserez la première forme pour les méthodes, et la seconde pour définir des fonctions de script, car la seconde forme attribuera également un index de script au nom de la fonction, tandis que la première forme
    sera une "vraie" méthode (et nécessitera l'utilisation du préfixe global si elle est utilisée pour définir une fonction scriptée).
  NOTE: Vous pouvez vérifier cela en utilisant les deux formulaires dans le projet et en appelant la fonction d'exécution typeof() sur chacun d'eux. L'un d'eux sera classé comme un "nombre" - puisqu'il renvoie un ID d'index de script - et l'autre sera classé comme une "méthode".
    il renvoie un ID d'index de script - et l'autre sera classé comme une "méthode".
  Gardez donc à l'esprit qu'en général, lorsque nous parlons de méthodes et de variables de méthode, nous faisons toujours référence à des fonctions qui n'ont pas été définies avec un index de script. 
  Vous pouvez voir ci-dessous trois exemples simples de création d'une variable de méthode à l'aide de différents champs d'application :
  // Local var _debug = function(message) {
     show_debug_message(message) ; }
    
     // Instance do_maths = function(val1, val2, val3) {
     return (val1 * val2) - val3 ; }
    
     // Global global.pd = function(_x1, _y1, _x2, _y2) ; {
     return point_distance(_x1, _y1, _x2, _y2) ; }
  
  Remarquez que dans le code ci-dessus, les différents paramètres qui sont donnés en entrée de la fonction sont tous nommés et que ces noms sont ceux qui doivent être utilisés dans la fonction pour faire référence aux différentes entrées. Notez également que vous pouvez utiliser l'instruction return pour renvoyer une valeur d'une fonction à utiliser ailleurs dans votre code, et qu'une fonction sans valeur de retour définie renverra par défaut undefined.
  REMARQUE: Alors que la variable sera dans la portée choisie, la fonction réelle sera liée à la portée dans laquelle elle a été initialement définie. Par exemple, les fonctions de script ont toutes une portée globale et sont "non liées" (c'est-à-dire qu'elles ne sont pas associées à des instances).
    (c'est-à-dire qu'elles ne sont associées à aucune instance), mais si vous avez une fonction de script qui crée une autre fonction en tant que variable de méthode et que vous appelez ensuite cette fonction de script à partir d'une instance, la fonction utilisée dans le script sera liée à la variable d'instance en tant que méthode.
    En général, il n'est pas nécessaire de s'en préoccuper, mais pour des opérations plus complexes avec des variables de méthode, cela vaut la peine d'être pris en considération. Cela s'applique également à l'utilisation d'autres constructions telles que with    - lorsque vous créez une variable de méthode à l'intérieur d'un with, la fonction sera liée à l'instance qui est actuellement dans la portée.
  Une fois créée, la variable méthode peut être utilisée comme une fonction d'exécution ou une fonction de script, par exemple :
  create_vec = function(_x1, _y1, _x2, _y2) ; {
     var _array ; _array[0] = point_distance(_x1, _y1, _x2, _y2) ; _array[1] = point_direction(_x1, _y1, _x2, _y2) ; return _array ; }
    
     vec = create_vec(x, y, mouse_x, mouse_y) ;
  Les variables créées à l'intérieur d'une fonction suivent les mêmes règles que la normale et leur portée dépend du mot-clé utilisé ou de la portée de l'appel de fonction. Dans l'exemple ci-dessus, nous utilisons var et la variable tableau est donc dans la portée locale de la fonction.
    portée locale de la fonction. Si nous n'avions pas utilisé le mot-clé, la variable aurait été créée dans la portée de l'instance qui a appelé la fonction.
  Les méthodes, tout comme les fonctions de script, peuvent également prendre des arguments facultatifs qui ont des valeurs par défaut lorsqu'ils ne sont pas transmis :
  create_attachment = function(_attachment, _x = x, _y = y) {
     return instance_create_layer(_x, _y, layer, _attachment) ; }
  
  La fonction ci-dessus prend trois arguments, les deux derniers étant facultatifs. S'ils ne sont pas passés lors de l'appel de la fonction, les coordonnées x et y de l'instance seront utilisées par défaut.
  Notez que si un argument n'est pas passé, et qu'il n'a pas de valeur par défaut, alors il sera égal à undefined.
  Les méthodes peuvent également utiliser des variables statiques, qui conservent leur valeur à chaque appel de fonction. Veuillez lire cette page pour plus d'informations.
  Nous énumérons ci-dessous quelques fonctions d'aide associées aux variables de méthode :
  
    est_méthode
    méthode
    méthode_get_self
    méthode_get_index
  
   
   
   
  
    
      
        Retour : Aperçu duGML
        Suivant : Structs
      
    
    Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

