with Comme indiqué dans la section Adressage des variables dans d'autres instances, il est possible de lire et de modifier la valeur des variables dans des instances et structures autres que celle qui exécute actuellement un code donné. Cependant, dans un certain nombre de cas, vous souhaitez faire beaucoup plus que simplement modifier une seule variable dans ces autres instances, et vous pouvez souhaiter effectuer des actions de code plus complexes qui nécessitent plusieurs fonctions et lignes de code. Par exemple, imaginez que vous souhaitiez déplacer toutes les instances d'un objet balle dans votre jeu de 8 pixels vers le bas. Vous pouvez penser que cela est réalisé simplement par le morceau de code suivant:obj_ball.y = obj_ball.y + 8; Mais ce n'est pas correct, car le côté droit de l'affectation obtient la valeur de la coordonnée y de la première balle et y ajoute 8. Ensuite, cette nouvelle valeur est définie comme coordonnée y de toutes les boules, donc le résultat est que toutes les boules ont la même coordonnée y, et même si vous utilisez ce qui suit:obj_ball.y += 8; il aura exactement le même effet car il s'agit simplement d'une abréviation de la première déclaration. Alors, comment pouvons- nous réaliser quelque chose comme ça? C'est pourquoi le with l'instruction existe dans GML. Le with l'instruction a la syntaxe suivante:with (<expression>)     {     <statement>;     <statement>;     ...     } Pour l' expression, vous pouvez indiquer une ou plusieurs instances (ou une structure) sur lesquelles exécuter le code, à l'aide d'un ID d'instance, l'ID d'objet (qui indique que toutes les instances de la salle de cet objet doivent exécuter le bloc de code), l'ID struct, ou l'un des mots -clés spéciaux (all ou other ). Cela changera alors la portée du code entre les accolades {} de l'instance, de la structure ou de la fonction qui contient réellement le code à l'instance (ou aux instances ou à la structure) donnée dans l'expression. Une fois que l'expression a défini la portée du with, l' instruction sera alors exécutée pour chacune des instances indiquées, comme si cette instance était l'instance actuelle ( self ). Donc, pour revenir à notre problème d'origine, pour déplacer toutes les instances de l'objet boule de 8 pixels vers le bas, vous devez taper:with (obj_ball)     {
         y += 8;     }
   Il s'agit essentiellement d'une boucle, et à chaque itération de la boucle, le code s'exécutera sur une instance de l'objet obj_ball. Si vous souhaitez exécuter plusieurs instructions, incluez-les simplement entre accolades, comme vous le feriez autour de tout autre bloc de code. Ainsi, par exemple, pour déplacer toutes les balles de notre exemple vers une position aléatoire et leur donner une vitesse et une direction aléatoires, vous utiliseriez:with (obj_ball)     {
         x = random(room_width);     y = random(room_height);     speed = 1 + random(2);     direction = random(360);     }
   Comme mentionné ci-dessus, dans la ou les instructions, l'instance ou la structure indiquée est devenue la cible (self ) qui exécute le bloc de code, ce qui signifie que l'instance d'origine (qui contient le with et le bloc de code entier) est devenu le other exemple. Ainsi, par exemple, pour déplacer toutes les boules vers la position de l'instance actuelle qui contient réellement le code, vous pouvez taper ceci:with (obj_ball)     {
         x = other.x;     y = other.y;     }
   Le with instruction est un outil extrêmement puissant et utile dans de très nombreuses circonstances, il est donc important que vous compreniez pleinement comment il peut être utilisé. Pour vous aider, voici quelques autres exemples d'utilisation ci-dessous:with (instance_create_layer(x, y, "Instances", obj_Ball))     {
         speed = other.speed;     direction = other.direction;     }
   Le code ci-dessus créera une instance de obj_Ball et attribuez-lui la vitesse et la direction de l'instance qui exécute tout le bloc de code.with (instance_nearest(x, y, obj_Ball))     {
         instance_destroy();
         }
   Le code ci-dessus détruira l'instance de obj_Ball le plus proche de l'instance exécutant le code.with(clone_struct)     {     xx = other.x;     yy = other.y;     spd = other.speed;     dir = other.direction;     } Le code ci-dessus utilise with pour cibler une structure et définir les variables membres de structure données sur les valeurs stockées dans les variables d'instance de l'instance appelant le code.var _inst = noone; with (obj_ball)     {
         if (str > other.str)         {
             _inst = id;         }
         }
     if (_inst != noone)     {
         target = _inst;     }
   Le code ci-dessus est légèrement plus complexe que les précédents car il utilise une variable locale. Cette variable est locale à l' événement ou à la fonction de script et non à l'instance ou à la structure et peut donc être utilisée et accédée par toutes les instances référencées dans le bloc de code. Donc, dans le code ci-dessus, nous avons défini une variable locale sur le mot clé spécial noone puis utilisez le with construction pour avoir chaque instance de obj_Ball vérifier leur str variable par rapport à celle de l'instance exécutant le bloc de code. Si la valeur de la variable est plus grande, ils stockent leur identifiant unique dans le inst variable locale, ce qui signifie qu'à la fin du code, seule l'instance avec une valeur supérieure à l'instance appelante (ou le mot-clé noone si aucun n'est plus grand) sera stocké dans la variable locale _inst. Il est à noter que vous pouvez utiliser le spécial break et continue déclarations dans un avec appel aussi. Utilisant break quittera immédiatement le with bloc de code et passez à n'importe quel code qui se trouve dans l'événement ou la fonction après que with aurait dû se terminer, par exemple:var count = 0; with (obj_Enemy)     {
         if (++count > 10)         {
             break;
             }
         hp = 100;     }
   Le code ci-dessus boucle à travers les instances dans la salle de l'objet obj_Enemy et définit la variable hp à 100 pour les 10 premiers qu'il trouve. S'il existe plus de 10 instances, le avec le code appellera break et fin. Un exemple d'utilisation continue dans un with boucle serait:with (obj_Enemy_Parent)     {     if (invulnerable == true)         {         continue;         }     hp -= 25;     } Ce code boucle à travers toutes les instances avec le parent obj_Enemy_Parent, puis vérifie chaque instance pour voir si le invulnerable la variable d'instance est true ou non. Si c'est le cas, le continue Le mot-clé termine l'itération actuelle de la boucle et passe à l'instance disponible suivante, sinon il en supprime 25 de la hp variable. Cela se répétera jusqu'à ce que toutes les instances avec ce parent aient été vérifiées.  Retour: Caractéristiques linguistiques Suivant:return © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

