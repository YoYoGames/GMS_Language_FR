try / catch / finally Le try, catch et finally Les instructions peuvent être utilisées dans votre jeu pour la vérification des erreurs et vous permettent de tester des blocs de code et de contrôler ce qui se passe si des exceptions d' runtime se produisent. Les utiliser empêchera l'exception de mettre fin au jeu et d'afficher le message d'erreur standard à l'utilisateur, mais cela signifie que vous devrez gérer ce qui se passe ensuite dans ce cas, comme la sauvegarde des fichiers journaux - par exemple - et la fin du jeu gracieusement ( notez que si vous choisissez de ne rien faire, votre jeu peut devenir instable et ne pas fonctionner correctement). Au plus basique, le try la syntaxe est la suivante:try     {
         <statement1>;
         <statement2>;
         ...     }
   Cependant, avoir un try sans rien pour gérer les exceptions que le code peut produire ne sera pas très utile, nous l'associons donc généralement à un catch, avec la syntaxe suivante:try     {
         <statement1>;
         <statement2>;
         ...
         }
     catch(<variable>)
         {
         <statement1>;
         <statement2>;
         ...
         }
   Quoi catch vous permet d'exécuter du code supplémentaire fourni dans le bloc suivant lorsqu'une exception du précédent try a été attrapé. S'il s'agit d'une runtime, la variable fournie peut être utilisée pour accéder à une structure qui contiendra les informations suivantes:{ message : "",               // a string that is a short message for this exception longMessage : "",           // a string that is a longer message for this exception script : "",                // a string
    that describes where the exception came from stacktrace : [ "", "" ],    // an array of strings that is the stack frame the exception was generated }
   Un exemple simple d'utilisation est présenté ci-dessous:var a = 0, b = 0, c = 0; try
         {
         c = a div b;     }
     catch( _exception)     {
         show_debug_message(_exception.message);
         show_debug_message(_exception.longMessage);
         show_debug_message(_exception.script);
         show_debug_message(_exception.stacktrace);
         }
   Il se peut que vous souhaitiez exécuter du code indépendamment du fait qu'une exception ait été levée ou non, et pour cela, vous pouvez ajouter un finally bloquer. Le finally la syntaxe est:finally     {
         <statement1>;
         <statement2>;
         etc...
         }
   Il est à noter que vous pouvez combiner n'importe quelle combinaison de ces éléments, c'est-à-dire:try /finally try /catch try /catch /finally Notez que dans le finally bloquer que vous ne pouvez pas utiliser break, continue, exit ou return instructions car elles n'ont aucune signification dans ce contexte et le compilateur générera une erreur si elles sont utilisées. Enfin, vous pouvez également imbriquer divers try /catch /finally les uns dans les autres, par exemple:var a = 0, b = 0, c = 0; try
         {
         try
             {
             c = a div b;         }
         finally
             {
             ++a;
             }
         }
     catch(_exception)
         {
         ++a;
         show_debug_message(_exception.message);
         show_debug_message(_exception.longMessage);
         show_debug_message(_exception.script);
         show_debug_message(_exception.stacktrace);
         }
     finally
         {
         show_debug_message("a = " + string(a));     }
   Il est à noter que vous pouvez reprendre le GML par défaut et utiliser votre propre code de gestionnaire en appelant la fonction exception_unhandled_handler(). Cette exécution _Functions.htm "> runtime fonction vous permet d'fournissiez une coutumemethod pour l'utiliser, il sera appelé chaque fois que des exceptions non gérées se produiront dans votre jeu.  Retour: Caractéristiques linguistiques Suivant:throw © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

