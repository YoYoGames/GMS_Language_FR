
  
  commutateur
  Dans un certain nombre de situations, vous souhaitez que vos instances effectuent différentes actions en fonction d'une valeur particulière. Vous pouvez le faire en utilisant un certain nombre d'instructions consécutives if / else consécutives, mais
    mais lorsque le nombre de choix possibles dépasse deux ou trois, il est généralement plus facile d'utiliser l'instruction switch. Une instruction switch a la forme suivante :
  switch (<expression>) {
     case <constante1> : <expression1> ; ... ; break ; case <constante2> : <expression2> ; ... ; break ;...
     default : <statement> ; }
  
  Cela fonctionne comme suit :
  
    L'expression est d'abord exécutée.
    Ensuite, il est comparé aux résultats des différentes constantes après chacune desdéclarations de case.
      Quand nous disons "constante", ce que nous voulons dire c'est que la valeur dans le cas ne peut pas être une expression variable et doit être une valeur fixe de n'importe quel type de données, comme "combat" ou 3 ou le mot-clé noone. 
    L'exécution se poursuit après la première instruction case avec la valeur correcte, jusqu'à ce qu'une instruction break soit rencontrée.
    Si aucune instruction case n'a la bonne valeur, alors l'instruction default sera exécutée (il n'est pas nécessaire d'avoir une instruction default, et si aucune n'est fournie, aucune action ne sera entreprise).
  
  Un exemple simple d'utilisation d'une instruction de commutation serait quelque chose comme ceci :
  switch (global.state) { case "alert" : if (instance_exists(obj_Player)) { if (point_distance(x, y, obj_Player.x, obj_Player.y) < 100) { 
    global.state = "chase" ; }  }  break ; case "chase" : var _lost = false ; if (instance_exists(obj_Player)) { move_towards_point(obj_Player.x,
    obj_Player.y, 2) ; if (point_distance(x, y, obj_Player.x, obj_Player.y) > 100) { _lost = true ; }  }  else _lost = true ; if (_lost) { speed = 0 ; global.state = "alert" ; }  break ; }
  Ici, nous avons une variable globale qui contient une valeur de chaîne de caractères utilisée pour définir le comportement (état) de l'instance. Dans cet exemple, l'instance passe simplement d'un état à l'autre, mais il est extrêmement facile de l'étendre à d'autres états en ajoutant
    d'autres déclarations case pour des chaînes d'état supplémentaires, comme "fight" ou "die", etc...
  Notez que plusieurs instructions case peuvent être utilisées pour exécuter la même instruction, car la rupture n'est pas toujours nécessaire pour chaque case. S'il n'y a pas d'instruction break pour un
    particulière case, l'exécution continue simplement avec le code pour le cas suivant, par ex :
  switch (keyboard_key) {
     case vk_left : case ord("A") : x -= 4 ; break ;
     case vk_right : case ord("D") : x += 4 ; break ;
     case vk_up : case ord("W") : y -= 4 ; break ;
     case vk_down : case ord("S") : y += 4 ; break ;
     }
  
  Le code ci-dessus utilise switch pour vérifier la présence d'un événement clavier et le compare ensuite à chaque case listé. S'il correspond à l'une des valeurs requises, le code correspondant est exécuté. Notez comment dans le code nous avons utilisé
    la manière dont switch peut vérifier plusieurs cases et continuer si aucune break n'est rencontrée pour permettre l'utilisation de différentes touches pour obtenir le même résultat. Notez que chaque case peut avoir son propre code, et que vous pouvez ainsi mettre en place une sorte de système "d'héritage" où plusieurs case et leur code s'exécuteront consécutivement les uns après les autres jusqu'à ce qu'une rupture soit atteinte en fonction de la valeur de l'expression initiale
    de l'expression initiale switch.
   
   
   
  
    
      
        Retour : Caractéristiques de la langue
        Suivant : pause
      
    
    Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

