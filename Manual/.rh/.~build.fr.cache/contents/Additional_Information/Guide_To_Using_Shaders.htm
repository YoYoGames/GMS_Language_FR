 Guide d'utilisation des Shaders Shaders sont souvent utilisés pour créer de beaux effets graphiques dans les jeux. Elles font également partie des fonctionnalités les plus avancées offertes par GameMaker Studio 2, il est donc nécessaire que vous ayez une compréhension de base de la programmation et du fonctionnement de GameMaker Studio 2 avant de commencer à les utiliser. Alors, qu'est-ce qu'un shader ? Initialement, ils ont été créés pour fournir un ombrage pour l'éclairage (d'où le nom), mais ils sont maintenant utilisés pour produire une grande variété d'effets. Shader code Shader est similaire au code normal, mais il est (presque toujours) exécuté par le GPU, pas par le CPU. Cette différence vient avec son propre ensemble de règles et de limitations, mais nous les couvrirons plus tard. Chaque shader est composé de deux composants distincts: un vertex shader et un fragment shader (également appelé pixel shader ). Commençons par le vertex shader. Chaque sprite est formé par un rectangle, mais les ordinateurs aiment dessiner des triangles, donc ces rectangles sont divisés en deux triangles (parfois appelés quad ). Cela nous laisse avec six sommets (coins) par sprite, mais deux d'entre eux sont les mêmes, donc nous ne devrions nous soucier que de quatre. Maintenant, imaginez que nous ayons une boucle for qui passe sur chaque sommet et exécute le code à l'intérieur du shader vertex pour chacun. Cela nous permet de changer la position et la couleur des sommets avant de les transmettre au fragment shader puisque le vertex shader est exécuté plus tôt. Voici à quoi cela ressemblerait: Pour le fragment shader, vous pouvez imaginer la même boucle qu'avant, mais cette fois, elle passe sur chaque pixel de votre sprite, vous donnant des informations telles que l'emplacement et la couleur de ce pixel. Dans votre shader fragment, vous effectuez des opérations et des calculs pour déterminer la couleur de ce pixel afin d'obtenir l'effet souhaité. Par exemple, si vous voulez qu'un shader rend votre sprite noir et blanc, vous calculez alors quelle nuance de gris chaque pixel doit avoir pour créer l'effet. Cela ressemblerait à quelque chose comme ceci: La raison pour laquelle shader code de shader est généralement exécuté par le GPU est qu'il est plus efficace. Les processeurs modernes ont généralement entre deux et huit cœurs. Chaque cœur peut effectuer une tâche à la fois, donc en tirant parti de plusieurs cœurs, nous pouvons effectuer autant de tâches simultanément. En revanche, les GPU modernes peuvent effectuer des milliers, voire des dizaines de milliers de tâches en même temps. Ceci est utile pour les shaders car nous pouvons exécuter le shader de milliers de pixels simultanément. La limitation est que nous n'avons accès qu'à l'état initial du sprite, nous ne connaissons donc aucune modification apportée aux autres pixels car nous ne pouvons pas savoir avec certitude que le code a encore été exécuté sur eux. REMARQUE: GameMaker Studio 2 permet aux utilisateurs d'écrire des shaders en GLSL (OpenGL Shader Language), HLSL (High-level Shader Language, utilisé lors de l'utilisation de DirectX) et GLSL ES (un sous-ensemble de GLSL qui est courant dans les appareils mobiles). Ici, nous utilisons GLSL ES comme shader car c'est celui qui offre la meilleure compatibilité entre les plates-formes cibles. Généralement, c'est celui que vous souhaitez toujours utiliser à moins que vous n'ayez des besoins très spécifiques et que vous compreniez les limites des autres langages de shader Cependant, les mathématiques et les techniques devraient être similaires entre les trois langages, à l'exception de quelques différences de syntaxe ici et là. Le vertex shader est exécuté en premier et, comme nous l'avons expliqué ci-dessus, il traite des sommets. Il est utilisé pour calculer les positions, les normales et les coordonnées de texture. Ces shaders ne sont pas particulièrement utiles en 2D, puisque chaque sprite est généralement un carré, mais il peut être utilisé pour faire un peu de biais, de mise à l'échelle, etc... Cela devient beaucoup plus utile en 3D pour les calculs d'éclairage et les déformations de maillage. Les shaders fragments sont beaucoup plus intéressants et sont ce qui sera principalement couvert ici, car le shader fragment est l'endroit où nous obtenons des informations sur nos textures et pouvons modifier la couleur finale de chaque pixel de notre image. Variables de Shader Si vous avez créé un shader dans GameMaker Studio 2, vous avez sans doute remarqué les mots clés suivants dans le pass-through par défaut shader. Ces mots clés aident le shader comprendre le but et la portée de chaque variable: Attribut: ce sont des variables transmises par OpenGL au vertex shader. Ceux-ci peuvent changer par sommet et sont en lecture seule. Celles-ci incluent des informations telles que la position du sommet, les coordonnées de la texture, la couleur du sommet et la normale du sommet. Variables: ce sont des variables utilisées pour transmettre des données entre les shaders sommets et de fragments. Ceux-ci sont disponibles pour l'écriture dans le vertex shader, mais sont en lecture seule dans le fragment shader. Uniforme: ce sont des variables qui changent par objet et sont transmises par l'utilisateur au shader. Ceux-ci peuvent être utilisés à la fois dans les shaders vertex et de fragment, mais sont en lecture seule. Vous verrez également l'utilisation de vec comme mot-clé. Ceci est utilisé pour identifier une variable vectorielle dans le shader et vous verrez bientôt que les vecteurs sont très importants lorsque vous travaillez avec des shaders. C'est pourquoi ils sont implémentés en tant que type de base dans GLSL. Si vous ne les connaissez pas, il s'agit d'un terme mathématique représenté sous forme de matrice avec une seule colonne. En programmation, nous les représentons généralement sous forme de tableau où le nombre de composants correspond à la dimension. Les vecteurs à deux et trois dimensions sont souvent utilisés pour les positions, les coordonnées de texture ou les couleurs sans canal alpha, tandis que les vecteurs à quatre dimensions sont utilisés pour les couleurs avec un canal alpha. Nous pouvons également spécifier s'ils contiennent des booléens, des entiers ou des valeurs à virgule flottante. La syntaxe pour déclarer un vecteur est la suivante:vec2 firstVec;  // Two-dimensional vector of floats vec3 secondVec; // Three-dimensional vector of floats vec4 thirdVec;  // Four-dimensional vector of floats
     bvec3 boolVec;  // Three-dimensional vector of booleans ivec4 intVec;   // Four-dimensional vector of booleans Pour les initialiser, nous pouvons utiliser le constructeur pour créer le vecteur. Vous devez fournir le même nombre de valeurs que la longueur du vecteur, mais vous pouvez mélanger et faire correspondre des scalaires et des vecteurs plus petits pour atteindre la longueur cible. En voici quelques exemples:// Simple 2D vector with 2 scalar values vec2 firstVec  = vec2(2.0, 1.0); // A 4D vector using 2 scalars and a vec2 create the 4 values vec4 secondVec = vec4(1.0, firstVec, 0.0); // A 3D vector using 1 component of a vec4 plus a
    vec2 to create the 3 values vec3 thirdVec  = vec3(secondVec.x, firstVec); Nous pouvons également leur attribuer un autre vecteur de même longueur (ou faire basculer le vecteur jusqu'à ce qu'il ait la bonne longueur, mais nous l'expliquerons dans un instant):vec3 firstVec; vec3 secondVec = firstVec; vec4 thirdVec  = secondVec.xyz; vec2 fourthVec = thirdVec.zx; Lors de l'accès aux composants vectoriels dans GLSL, nous avons quelques options. Le plus élémentaire est de traiter le vecteur comme un tableau et d'accéder aux composants en utilisant des crochets, comme ceci:vec4 myVec; myVec[0] = 1.0; myVec[1] = 0.0; myVec[2] = 2.0; myVec[3] = 1.0; Cependant, il existe un autre moyen d'accéder aux composants avec la syntaxe suivante:vec4 myVec; myVec.x = 1.0; myVec.y = 2.0; Cela utilise les noms de composants à l'intérieur du vecteur pour y accéder. Vous pouvez utiliser x, y, z ou w pour obtenir respectivement les premier, deuxième, troisième ou quatrième composants. Nous appelons cette méthode swizzling car la syntaxe suivante est également valide:vec4 firstVec; vec3 secondVec = firstVec.xyz; vec2 thirdVec  = secondVec.zy; vec4 fourthVec = thirdVec.yxxy; Comme vous pouvez le voir, nous pouvons utiliser n'importe quelle combinaison de quatre lettres maximum pour créer un vecteur de cette longueur. Nous ne pouvons pas tenter d'accéder à un composant qui serait hors limites (par exemple, en essayant d'accéder à w dans secondVec ou thirdVec, car ils n'ont pas de quatrième composant). De plus, nous pouvons répéter des lettres et les utiliser dans n'importe quel ordre, à condition que la variable vectorielle à laquelle elle est affectée ait la même taille que le nombre de lettres utilisées. Pour des raisons évidentes, lorsque vous utilisez swizzle pour définir les valeurs des composants, vous ne pouvez pas utiliser le même composant deux fois. Par exemple, ce qui suit n'est pas valide car vous essayez de définir le même composant sur deux valeurs différentes:myVec.xx = vec2(2.0, 3.0); Enfin, nous utilisons xyzw comme notre masque swizzle, ce qui est généralement le cas lorsqu'il s'agit de positions. Vous pouvez utiliser deux autres ensembles de masques: rgba (utilisé pour les couleurs), ou stpq (utilisé pour les coordonnées de texture). En interne, il n'y a aucune différence entre ces masques, et nous les utilisons uniquement pour rendre le code plus clair quant à ce que le vecteur représente dans cette instance. De plus, nous ne pouvons pas combiner des masques de swizzle dans la même opération, donc ce n'est pas valide:myVec = otherVec.ybp; C'étaient beaucoup de définitions et d'informations, mais connaître ces choses est nécessaire pour comprendre les shaders eux-mêmes. Créer un Shader Lorsque vous créez un shader dans GameMaker Studio 2, il ouvre deux fichiers pour vous: un vertex shader (.vsh ) et un fragment shader (.fsh ). shader le plus basique que vous puissiez créer, qui prend un sprite, lit la texture et colore chaque pixel avec cette couleur. Si vous spécifiez les couleurs des sommets lors du dessin, ces couleurs se fondront avec la texture. Passons en revue le code d'un shader nouvellement créé et analysons-le, en commençant par le vertex shader.// Passthrough Vertex Shader attribute vec3 in_Position;                  // (x,y,z) //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader. attribute vec4 in_Colour;                    // (r,g,b,a) attribute
    vec2 in_TextureCoord;              // (u,v)
     varying vec2 v_vTexcoord; varying vec4 v_vColour;
     void main() {
         vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);     gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;          v_vColour = in_Colour;     v_vTexcoord = in_TextureCoord;    }
   En dehors de la fonction principale, nous voyons quelques déclarations de variables et leurs qualificatifs. Les attributs nous sont donnés par GameMaker. Les différents sont créés par l'utilisateur pour transmettre ces informations au fragment shader. À l'intérieur de la fonction principale, nous avons les calculs pour trouver la position d'écran du sommet: Tout d'abord, nous créons un vec4 et initialisez-le avec les composants de la position, en ajoutant un comme quatrième composant. En algèbre linéaire, la convention est que nous ajoutons un un à la quatrième composante si le vecteur représente un point, ou un zéro s'il représente un vecteur réel. Ensuite, nous devons ajouter ce quatrième composant pour le multiplier par le MATRIX_WORLD_VIEW_PROJECTION matrice, qui est une matrice 4x4. Cette multiplication projettera la position mondiale du sommet en coordonnées d'écran. Enfin, nous transmettons la couleur du sommet et la coordonnée de texture au shader fragment via nos variables variables. Ce shader doit être laissé seul si vous ne prévoyez pas de jouer avec les positions des sommets et il ne sera utilisé dans aucun des exemples donnés ci-dessous car tous les effets affichés seront créés en utilisant le shader fragment. Jetons un coup d'œil au shader fragment maintenant:// Passthrough Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
     void main() {
         gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord ); }
   Comme expliqué précédemment, l'idée derrière un shader fragment est de renvoyer la couleur du pixel actuel. Cela se fait en affectant la variable gl_FragColor la valeur de couleur finale. Le texture2D fonction prend une texture et un vec2 avec les coordonnées UV que vous souhaitez archiver dans cette texture, ce qui renvoie un vec4 avec la couleur. Dans le shader, tout ce que nous faisons est de saisir la couleur de la texture dans la coordonnée de ce pixel et de la multiplier par la couleur du sommet associé à ce pixel. Maintenant que nous avons notre premier shader, tout ce que nous avons à faire pour le tester est de créer un objet et de lui attribuer un sprite, puis dans l' événement Draw de l'objet, vous définissez le shader comme ceci:// Draw Event shader_set(shdrColorOverlay);
     draw_self();
     shader_reset();
   Chaque appel que nous faisons entre shader_set () et shader_reset () aura le shader appliqué. Ici, nous dessinons le sprite objet avec notre shader passthrough: Comme vous l'avez peut-être deviné, cela ne change rien visuellement, car il s'agit d'un simple shader pass-through. Cependant, les sections ci-dessous décrivent quelques étapes simples que vous pouvez suivre pour modifier cela et changer la façon dont le sprite sera dessiné. Chacune des sections montre un shader différent que vous pouvez créer et utiliser dans vos projets, en expliquant les étapes nécessaires pour les créer et pourquoi nous faisons les choses comme nous sommes. Shader superposition de couleur Nous pouvons shader base pour faire quelque chose de différent. Nous ne toucherons pas la partie vertex shdaer, et n'éditerons que le fragment shader, et pour commencer, nous allons faire une opération très simple, qui consiste à faire shader avec la couleur rouge. Nous allons faire cela en changeant simplement le gl_FragColor être rouge., comme ceci:// Color Overlay Fragment Shader void main() {
           gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }
     Cela nous donnera le résultat suivant: Pas exactement ce à quoi nous nous attendions! Ce que nous devons nous rappeler, c'est que chaque sprite est en fin de compte un rectangle, donc à moins que nous ne considérions la transparence - ce que nous n'avons pas - c'est le résultat que nous obtiendrons. REMARQUE: dans l'image ci-dessus, le rectangle change de taille car le sprite de base a eu l'espace «vide» autour de lui rogné automatiquement lorsqu'il a été placé sur la page de texture par GameMaker, de sorte que chaque image d'animation les triangles qui le composent sont de tailles différentes pour s'adapter à la taille recadrée du cadre. Si vous désactivez cette option, vous aurez simplement un carré rouge immobile à l'écran. Ci-dessus, nous avons mentionné le texture2D fonction, et nous l'utiliserons pour saisir la couleur du pixel sur lequel nous travaillons et en obtenir la transparence. La valeur de retour de esttexture2D est un vec4, où les composants sont le rouge, le vert, le bleu et l'alpha, dans cet ordre. On peut accéder au canal alpha soit en mettant un point suivi d'un a ou un w après le nom de la variable. Cela correspond respectivement à RGBA et XYZW. Voici le code mis à jour:// Color Overlay Fragment Shader varying vec2 v_vTexcoord;
       void main() {
           vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);     gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a); }
     Nous attribuons maintenant un nouveau vec4 à gl_FragColor, où le canal rouge est maximal, les canaux vert et bleu sont à zéro et le canal alpha est le même que la texture d'origine. La sortie ressemble à ceci: Voilà ce que nous recherchions! Nous avons remplacé la couleur de chaque pixel par du rouge, mais nous avons conservé le canal alpha intact. Devoir changer le shader chaque fois que nous voulons utiliser une couleur différente n'est pas une bonne idée, d'autant plus que nous aurions besoin d'un shader séparé pour chaque couleur que nous voulons. Au lieu de cela, nous transmettrons les informations de couleur au shader utilisant un uniforme. Pour ce faire, nous devons d'abord obtenir un pointeur vers l'uniforme. Nous allons faire cela dans l' événement Create de notre objet qui a le sprite en ajoutant:// Create Event _uniColor = shader_get_uniform(shdrColorOverlay, "u_colour"); _color    = [1.0, 1.0, 0.0, 1.0]; Tout ce que nous devons faire est d'appeler shader_get_uniform () pour obtenir un pointeur vers l'uniforme. Les paramètres que nous devons passer sont le shader (sans guillemets car nous voulons passer l'ID que GameMaker génère pour nous) et le nom de la variable uniforme à l'intérieur du shader, cette fois sous forme de chaîne. Ce nom doit correspondre exactement à celui shader dans le code du shader pour que cela fonctionne. Nous avons également ajouté une variable de couleur afin que nous puissions la modifier au runtime de l'exécution et qu'elle se souvienne de nos modifications. Maintenant, le code de notre événement draw changera légèrement pour passer la variable uniforme.// Draw Event shader_set(shdrColorOverlay);
       shader_set_uniform_f_array(_uniColor, _color); draw_self();
       shader_reset();
     C'est le même code qu'avant, mais avant de dessiner quoi que ce soit, nous devons transmettre toutes les valeurs uniformes au shader. Dans ce cas, nous transmettons la couleur sous la forme d'un tableau de flottants. Quant au shader, nous allons le changer pour inclure l'uniforme et l'utiliser, donc il devient:// Color Overlay Fragment Shader varying vec2 v_vTexcoord; uniform vec4 u_color; void main() {
           vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);     gl_FragColor = vec4(u_color.rgb, texColor.a); }
     Nous déclarons une variable avec le même nom que dans le shader create (u_color ) et nous le passons comme les trois premiers composants du gl_FragColor vecteur, profitant du swizzling. Si nous compilons à nouveau, nous devrions voir ceci: Maintenant, le shader est beaucoup plus utile et réutilisable. C'est à vous d'ajouter plus de fonctionnalités si vous en avez besoin pour définir la couleur (en utilisant la variable _color ) pendant l' runtime. Shader noir et blanc shader noir et blanc est un excellent moyen d'en savoir plus sur le fonctionnement des shaders, et de nombreux débutants commencent par essayer de le faire, car conceptuellement, c'est assez simple: obtenir chaque pixel et lui attribuer une nuance de gris. Mais est-ce simple? Pas assez... Lorsque vous utilisez la couleur RVB, si les trois composants ont la même valeur, nous obtenons une teinte grise. L'approche naïve pour créer un shader pour utiliser cette idée serait d'ajouter les trois canaux de couleur (rouge, vert et bleu), puis de le diviser par trois. Après cela, vous avez attribué la valeur aux trois canaux, créant ainsi une teinte grise. Voici à quoi ressemble shader// Black and white fragment shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       void main() {
           vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);     float gray = (texColor.r + texColor.g + texColor.b) / 3.0;     gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a); }
     Une chose que vous avez peut-être remarqué est que dans le gl_FragColor code, nous multiplions levec4 avec quelque chose qui s'appelle v_vColour. Il s'agit d'une variable passée par le vertex shader qui nous indique la couleur du sommet associé à ce pixel. C'est toujours une bonne idée de multiplier votre couleur calculée finale par la couleur des sommets. Dans la plupart des cas, cela ne fera rien, mais si vous avez changé la couleur du sommet dans GML, cela reflétera cela (en utilisant des fonctions telles que draw_sprite_ext() ou draw_sprite_general() pour changer le image_blend ). Quant au tirage au sort, c'est assez simple puisque nous n'avons pas d'uniforme à passer:// Draw Event shader_set(shdrBlackAndWhite);
       draw_self();
       shader_reset();
     Compilons et voyons ce que nous avons. Cela a déjà l'air génial, non? Eh bien, oui et non... il existe une solution plus «correcte», puisqu'au lieu d'ajouter les composants et de diviser par trois, nous multiplions chaque composant par les valeurs NTSC standard pour le noir et blanc. Voici le code du shader// Black and white fragment shader varying vec2 v_vTexcoord;
       void main() {
           vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);     float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));     gl_FragColor = vec4(gray, gray, gray, texColor.a); }
     Nous utilisons le produit scalaire comme un raccourci pour multiplier chaque composant de texColor avec les poids corrects, puis additionnez-les. Si vous n'êtes pas familier avec le produit scalaire, c'est essentiellement ce qui se passe:float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114); En fin de compte, cela semble très similaire, mais c'est techniquement plus correct. Shader arc-en-cielNotre dernier shader est amusant et peut être utilisé pour ajouter de la vie au texte, aux boutons et à d'autres choses. Nous commencerons simplement et ajouterons des fonctionnalités progressivement, car ce shader est hautement personnalisable. Il y a beaucoup à couvrir pour celui-ci, donc si vous vous sentez un peu perdu ou confus, veuillez revenir en arrière et relire certaines des sections ci-dessus. La première chose que nous voulons faire est de colorer les pixels avec chaque teinte, en fonction de la position horizontale du pixel. La façon de faire est de définir la position x comme la teinte, puis de passer du format HSV (teinte, saturation, luminosité) au format RVB (rouge, vert et bleu). Pour cela, nous devrons écrire une fonction d'assistance dans notre shader fragment qui prend les valeurs HSV et renvoie un vecteur RVB. Nous utiliserons une seule fonction qui fait cela sans avoir besoin d'aucune if instructions, car l'utilisation de conditions dans shader code de shaders très lents et doit être évitée. Voici à quoi shader à ce stade:// Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       vec3 hsv2rgb(vec3 c)  {
           vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
           vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;     gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha); }
     Il se passe un peu plus ici que dans les exemples précédents, mais la plupart devraient être assez évidents pour vous maintenant. Premièrement, il y a notre hsv2rgb fonction, qui prend un vec3 avec notre couleur HSV et renvoie un autre vec3 avec notre conversion RVB. Dans la fonction principale, nous commençons par créer notre couleur HSV, où la teinte est notre position x, et nous laisserons la saturation et la luminosité à 1.0 pour le moment. Ensuite, nous obtenons l'alpha de la texture afin qu'il ne colore que notre personnage de sprite et non le rectangle de sprite entier (comme nous l'avons fait dans l'exemple de superposition de couleurs, ci-dessus). Enfin, nous définissons notre couleur Fragment comme étant notre couleur HSV convertie en RVB avec l'alpha, multipliée par la couleur du sommet (bonne pratique pour toujours le faire). Quant à notre code de tirage, il est trivial pour le moment:// Draw Event shader_set(shdrRainbow);
       draw_self();
       shader_reset();
     Voyons ce que nous avons: Nous sommes proches de ce que nous voulons, mais il y a un problème: nous ne voyons pas toutes les couleurs à la fois dans chaque image de l'animation et les couleurs semblent changer de manière aléatoire. La raison en est que nous avons supposé que v_vTexcoord nous a donné les coordonnées du sprite, commençant dans le coin supérieur gauche (0,0) et se terminant dans le coin inférieur droit (1,1), qui est standard dans les shaders. Cependant, pour l'optimisation, GameMaker rassemble autant de textures qu'il peut en contenir dans ce qu'on appelle une page de texture, et à cause de cela, voici à quoi ressemble notre texture: Comme expliqué ci-dessus, v_vTexcoord nous donne les coordonnées absolues du sprite dans toute cette page de texture, mais ce que nous voulons, c'est une valeur de 0,0 à 1,0 qui ne couvre que notre sprite actuel. Ce processus est appelé normalisation (obtenir une valeur et la traduire dans une plage de 0 à 1). Pour normaliser nos valeurs horizontales, nous devons connaître les valeurs de x0 et x1 dans l'image ci-dessus. Heureusement, GameMaker a une fonction qui nous donne l'emplacement de chaque coin de notre sprite dans la page de texture. Tout d'abord, nous devons accéder à l'événement Create et créer un uniforme pour transmettre ces données au shader:// Create Event _uniUV = shader_get_uniform(shdrRainbow, "u_uv"); Et nous modifions l'événement draw pour obtenir les valeurs, puis les transmettons au shader:// Draw Event shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); draw_self();
       shader_reset();
     La fonction sprite_get_uvs() prend un sprite et un index, et il renvoie un tableau avec des tonnes d'informations, telles que les coordonnées de chaque coin, combien de pixels ont été rognés pour l'optimiser, etc. Nous nous intéressons à deux de ces valeurs: les coordonnées gauche et droite du sprite, qui sont stockés dans uv[0] et uv[2] respectivement. Dans le shader fragment, nous utiliserons ces valeurs maintenant pour calculer la position horizontale normalisée comme ceci:// Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       uniform vec2 u_uv;
       vec3 hsv2rgb(vec3 c)  {
           vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
           float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);     vec3 col = vec3(pos, 1.0, 1.0);     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;     gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);      }
     Ici, nous ajoutons la variable uniforme en haut du fichier avec le même nom que nous avons utilisé dans la création d'événement. Ensuite, nous calculons la position horizontale normalisée en traduisant notre courant x coordonnée à l'origine ( v_vTexcoord.x - u_uv[0] ) puis nous le divisons par la largeur du sprite pour faire la plage de 0 à 1 (u_uv[1] - u_uv[0] ). Le résultat est: On y va! C'est exactement ce que nous voulions. Nous pouvons voir toutes les couleurs du spectre à l'intérieur de notre sprite. Vous serez peut-être satisfait de cela, mais nous pouvons nous amuser encore plus avec ce shader. Et si nous ajoutions un décalage aux couleurs basé sur le temps pour produire du mouvement? Pour ce faire, nous aurons besoin de deux variables supplémentaires pour la vitesse et le temps. Nous aurons également besoin de deux uniformes supplémentaires, un pour chacune des nouvelles variables, de sorte que l'événement Create devienne:// Create Event _uniUV    = shader_get_uniform(shdrRainbow, "u_uv"); _uniTime  = shader_get_uniform(shdrRainbow, "u_time"); _uniSpeed = shader_get_uniform(shdrRainbow, "u_speed"); _time  = 0;      _speed = 1.0; Nous devons également augmenter le temps à chaque image, donc dans l'événement Step, nous ajoutons:// Step Event _time += 1 / room_speed; Passons maintenant à l'événement draw pour envoyer ces uniformes au shader:// Draw Event shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); shader_set_uniform_f(_uniSpeed, _speed); shader_set_uniform_f(_uniTime, _time); draw_self();
       shader_reset();
     Enfin, nous reviendrons à notre shader pour utiliser réellement ces variables maintenant. Ce que nous allons faire, c'est multiplier la vitesse avec le temps et l'ajouter à la position, comme ceci:// Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       uniform vec2 u_uv; uniform float u_speed; uniform float u_time;
       vec3 hsv2rgb(vec3 c)  {
           vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);   vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
           float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);     vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;     gl_FragColor = v_vColour * vec4(hsv2rgb(col),
      alpha);
       }
     Si vous avez tout fait correctement, vous devriez voir quelque chose comme ceci: Pour finir ce shader, nous ajouterons quelques uniformes supplémentaires pour le personnaliser encore plus. Les deux premiers sont de contrôler la saturation et la luminosité. La prochaine que nous appellerons "section" et sa fonction est de permettre à l'utilisateur de passer un nombre entre zéro et un pour déterminer quel pourcentage du spectre entier que nous voyons à la fois. Enfin, nous ajouterons une variable appelée "mix", qui précisera combien nous voulons mélanger la shader avec la couleur de la texture d'origine (1.0 est tout arc-en-ciel, 0.0 est toute texture). Comme toujours, commençons par ajouter les variables à l'événement Create:// Create Event _uniUV         = shader_get_uniform(shdrRainbow, "u_uv"); _uniTime       = shader_get_uniform(shdrRainbow, "u_time"); _uniSpeed      = shader_get_uniform(shdrRainbow, "u_speed"); _uniSection
         = shader_get_uniform(shdrRainbow, "u_section"); _uniSaturation = shader_get_uniform(shdrRainbow, "u_saturation");  _uniBrightness = shader_get_uniform(shdrRainbow, "u_brightness"); _uniMix        =
      shader_get_uniform(shdrRainbow, "u_mix");
       _time  = 0; _speed = 1.0; _section = 0.5; _saturation = 0.7; _brightness = 0.8; _mix = 0.5; Notre événement de tirage au sort change pour inclure ces uniformes comme ceci:// Draw Event shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); shader_set_uniform_f(_uniSpeed, _speed); shader_set_uniform_f(_uniTime, _time); shader_set_uniform_f(_uniSaturation, _saturation);      shader_set_uniform_f(_uniBrightness, _brightness); shader_set_uniform_f(_uniSection, _section); shader_set_uniform_f(_uniMix, _mix); draw_self();
       shader_reset();
     En ce qui concerne le shader, nous devons passer la saturation et la luminosité à la couleur, ce qui affectera la couleur générée par notre fonction d'assistance. La section doit être multipliée par notre position pour réduire la portée. Nous allons également saisir toute la couleur de la texture, afin de pouvoir calculer notre couleur finale en mélangeant la couleur de la texture avec la conversion RVB de notre couleur. Le dernier paramètre de la fonction de mixage détermine la quantité de la deuxième couleur que nous voulons ajouter. Voici notre code de shader// Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       uniform vec2 u_uv; uniform float u_speed; uniform float u_time; uniform float u_saturation; uniform float u_brightness; uniform float u_section; Uniform float u_mix;
       vec3 hsv2rgb(vec3 c)  {
           vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
           float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);          gl_FragColor = v_vColour * finalCol; }
     Et notre résultat final est le suivant! C'est la fin de ce petit guide et vous devriez maintenant avoir une meilleure compréhension du fonctionnement des shaders et de certaines des utilisations auxquelles ils peuvent être faits. Vous devriez prendre votre temps pour jouer avec les shaders vous avez créés en suivant ce guide et essayer de les expérimenter pour faire d'autres choses - que diriez-vous de créer un shader flou ou un shader qui crée un écran monochrome de style gameboy? - puisque les shaders sont un outil incroyablement puissant pour ajouter de la complexité visuelle et du style à vos jeux. YoYo Games tient à remercier Alejandro Hitti et Amazon de nous avoir permis de reproduire ce guide. Vous pouvez trouver la version originale sur le blog des développeurs Amazon. Retour: Informations complémentaires Suivant: Guide des primitives et de la construction de sommets © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

