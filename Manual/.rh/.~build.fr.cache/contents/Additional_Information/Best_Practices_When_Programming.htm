 Meilleures pratiques lors de la programmation Sur cette page, nous allons couvrir quelques "meilleures pratiques" lors de la programmation de votre jeu, et en même temps expliquer un peu le fonctionnement interne de GameMaker Studio 2. Avant de continuer, cependant, il convient de noter deux points très importants: Ceci est un guide, et non la méthode parfaite pour écrire votre jeu! Les choses mentionnées ici sont généralement plus à l'échelle de l'organisation et de la micro-optimisation et devraient être intégrées à vos habitudes de programmation lorsque vous vous sentez à l'aise avec GML et pensez qu'elles sont appropriées. Si votre jeu fonctionne bien et que vous êtes satisfait des choses telles qu'elles sont, ne vous précipitez pas pour tout changer juste pour tirer quelques FPS supplémentaires. Vous devez trouver un équilibre entre un code lisible, flexible et modulaire avec le temps et l'énergie nécessaires pour changer les choses, ainsi que le gain global à la fin. En gros, s'il n'est pas cassé, ne le réparez pas et gardez ce que vous avez appris ici pour votre prochain projet. Cela dit, passons à autre chose et examinons quelques conseils généraux pour écrire un bon GML que vous pouvez appliquer à tout moment... Style de programmation Quand il s'agit d'écrire du code, tout le monde a un style. Le style dans lequel vous programmez est la façon dont vous placez vos crochets, comment vous indentez les lignes, et comment vous déclarez et nommez les variables, etc., et est essentiel pour rendre votre code clair et lisible pour les autres (et pour votre futur moi, lorsque vous devez revenir sur ce projet après un certain temps sur autre chose). Il existe de très nombreux styles de programmation, et certains diront que le leur est le meilleur à utiliser, mais la vérité est que presque tous les styles conviennent à condition que vous soyez cohérent lorsque vous l'utilisez et que tout est clair et évident. Est-ce que. L'image ci-dessus est un exemple de déclaration de fonction dans un script pour illustrer les points ci-dessus. Vous pouvez voir qu'il utilise les commentaires de style JSDoc pour expliquer clairement ce que tout cela fait, et le style de codage est cohérent, avec 4 espaces en retrait, des traits de soulignement utilisés pour les variables locales, la sortie journalisée, etc. Notez également que si l'éditeur de script vous permet de plier le code à chacun des crochets ouverts / fermés, vous pouvez utiliser #region et #endregion des balises pour sectionner des parties de votre code et améliorer considérablement la lisibilité, en particulier lorsqu'il s'agit de scripts plus volumineux contenant plusieurs fonctions. Les régions peuvent également être commentées - voir la section Édition de cette page dans le manuel): Lorsque vous écrivez du code, vous devez savoir que lors de la compilation de votre jeu final, GameMaker Studio 2 supprime les commentaires, supprime les sauts de ligne et les espaces blancs inutiles, remplace les valeurs constantes / macro / enum et compresse généralement votre code dans le cadre du processus. Cela signifie que vous pouvez ajouter autant d'espaces blancs autour de votre code que nécessaire et que vous n'avez pas à vous soucier de garder vos commentaires courts ou de les utiliser avec parcimonie. Utiliser des variables locales En continuant à partir du point ci-dessus sur le style de programmation, une chose que beaucoup de débutants font est d'en entasser autant que possible dans une seule ligne de code. Par exemple:draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y))); Bien qu'il ne soit pas complètement illisible, il est inefficace (le point_direction() fonction est appelée deux fois, par exemple) et c'est compliqué et difficile à regarder. Ce serait beaucoup mieux exprimé comme suit:var p_dir = point_direction(x, y, mouse_x, mouse_y); var local_x = x + lengthdir_x(100, p_dir); var local_y = y + lengthdir_y(100, p_dir); draw_sprite(sprite_index, image_index, local_x, local_y); La mémoire et les ressources nécessaires pour créer ces variables locales sont négligeables et sont largement compensées par l'avantage instantané que vous (ou toute autre personne lisant le code plus tard) tire de sa clarté. La même idée doit également être appliquée aux fonctions, où vous devez attribuer des noms sensés aux variables d'entrée, et utiliser un formatage clair et des variables locales si nécessaire pour le rendre aussi lisible que possible. Les variables locales sont rapides à traiter dans le jeu, alors profitez-en au maximum, et si une expression apparaît dans un bloc de code ou un script deux fois ou plus, pensez à créer une variable locale pour elle. Lorsque vous utilisez les YoYo Compiler (YYC), si vous référencez global ou des variables d'instance à plusieurs reprises dans une fonction ou un bloc de code, il est particulièrement avantageux de les affecter à une variable locale au début de votre code, puis de référencer cette variable locale, car cela donnera de bien meilleures performances. Tableaux Les tableaux sont rapides à utiliser et nécessitent moins de mémoire que les structures de données, mais ils peuvent encore être optimisés. Lorsque vous créez un tableau, de la mémoire lui est allouée en fonction de sa taille, vous devriez donc essayer d'initialiser un tableau à sa taille maximale en premier, même si vous ne prévoyez de le remplir que plus tard. Par exemple, si vous savez que vous avez besoin d'un tableau pour contenir un maximum de 100 valeurs, vous l'initialisez immédiatement à 100 emplacements, en utilisant le array_create() fonction:array = array_create(100, 0); Cela alloue la mémoire pour lui dans un "morceau" avec toutes les valeurs du tableau étant définies sur la valeur par défaut de 0 et aide à garder les choses rapides, sinon chaque fois que vous ajoutez une nouvelle valeur au tableau, la mémoire entière doit être réallouée de nouveau. REMARQUE: sur la cible HTML5, l'attribution de tableaux comme celui-ci ne s'applique pas et vos tableaux doivent être initialisés à partir de 0 pour cette cible! Vous pouvez facilement gérer cela en vérifiant la variable os_browser, par exemple:if (os_browser == browser_not_a_browser)
    {
    array_create(100, 0);
    }
else
    {
    for (var i = 0; i < 100; ++i;)
        {
        array[i] = 0;
        }
    } Vous pouvez également libérer la mémoire associée à un tableau en définissant la variable utilisée sur 0. Ainsi, pour effacer le tableau de l'exemple de code ci-dessus, vous utiliseriez simplement:array = 0; Notez également que les tableaux sont passés par référence, mais copient le tout quand une modification est apportée (ce comportement est appelé copie en écriture ). Ainsi, si vous passez un tableau à une fonction, vous passez une référence au tableau d'origine et toutes les valeurs lues à partir de celui-ci proviendront de la source d'origine. C'est agréable et rapide, mais si vous devez modifier l'une des valeurs du tableau, le tableau lui-même est dupliqué au moment de l'écriture et toutes les modifications apportées doivent être renvoyées par la fonction ou elles seront perdues. Ceci est beaucoup plus lent et consomme plus de mémoire, alors faites attention à la manière dont vous utilisez les tableaux dans les fonctions. Cependant, vous pouvez éviter cette copie lors du comportement d'écriture en utilisant l' accesseur de tableau spécial@, car cela donne un accès direct au tableau sous-jacent. Par exemple:// Call a function, passing our array my_function(my_array);
    // The function looks like this:
       function my_function(_a) {
       // The array will be copied and the copy modified, // requiring you to use "return _a", later _a[0] = 100; // This will modify the ORIGINAL array directly and // does not require it to be returned _a[@0]
      = 100; }
     Structures de données Dans GameMaker Studio 2 les structures de données ont été optimisées pour être beaucoup plus rapides que les versions GameMaker Ils doivent encore être nettoyés (détruits) lorsqu'ils ne sont pas utilisés pour libérer de la mémoire, et ils peuvent toujours être plus lents que, par exemple, les tableaux, mais la facilité d'utilisation et les fonctions supplémentaires pour traiter les données qu'ils contiennent peuvent souvent être plus importantes. la différence de vitesse minimale, alors n'ayez pas peur de les utiliser dans vos jeux. Il convient de noter que de toutes les structures de données, DS Maps en particulier est très rapide, à la fois en lecture et en écriture, ce qui en fait une excellente option pour tous les types de tâches. Auparavant, nous avons mentionné les accesseurs pour les tableaux, mais ils sont également disponibles pour les structures de données, ce qui peut aider à nettoyer votre code et le rendre beaucoup plus facile à lire. Collisions Il existe plusieurs façons de gérer les collisions dans GameMaker Studio 2, et la plupart d'entre elles s'accompagnent d'un peu de surcharge CPU supplémentaire. Le collision_ et point_ les fonctions, place_ fonctions, et instance_ Les fonctions reposent toutes sur des vérifications de boîte englobante avec toutes les instances d'un type donné dans la salle, et bien qu'il y ait une certaine optimisation intégrée au moteur pour limiter ces vérifications, les collisions ne sont jamais la chose la plus efficace à gérer. Si vous commencez à utiliser des collisions précises, les performances seront également sensiblement pires, car non seulement vous ferez des vérifications de la boîte englobante, mais vous ferez également des vérifications par pixel, ce qui est en effet très lent. Il y a un YoYo Games qui en parle ici: Les dangers de la détection précise des collisions Cela ne veut pas dire que vous ne devriez pas utiliser ces fonctions, car elles peuvent être très pratiques. Cependant, vous devez savoir lesquels utiliser et quand, car ils fonctionnent tous légèrement différemment et auront des vitesses différentes. La règle de base approximative est que le place_ les fonctions sont plus rapides que les instance_ fonctions, qui sont plus rapides que les collision_ et point_ lisez les pages du manuel pour chacun de ces types de fonctions et assurez-vous de choisir la plus appropriée à chaque situation. Vous pouvez également envisager de créer un système de collision basé sur des tuiles, qui peut être créé à l'aide des fonctions de tilemap ou même d'un tableau 2D personnalisé ou d'une grille DS. Ceux-ci seront très rapides et aideront à augmenter la vitesse de votre jeu. Cependant, si vous utilisez un terrain irrégulier ou des murs et des objets qui ne s'alignent pas sur une grille, ils peuvent ne pas être appropriés. Vous pouvez trouver un tutoriel très simple sur les collisions de tilemap à partir du lien vidéo suivant Collisions de tuiles dans GameMaker Studio 2 Échange de texture et lots de sommets Si vous activez la superposition de débogage, vous verrez qu'il y a deux chiffres entre parenthèses en haut de votre écran lors du test. Le premier est le nombre de permutations de texture en cours et le second est le nombre de lots de sommets. Un certain nombre de facteurs influenceront ces chiffres et vous ne les réduirez jamais à (0) (0) car le moteur nécessite un ou deux de chaque étape, mais vous devriez viser à réduire ces valeurs aussi bas que possible. Pour les échanges de texture, le moyen le meilleur et le plus efficace de le faire est d'optimiser la façon dont vos sprites et arrière-plans sont stockés sur la page de texture. Cela se fait à partir des propriétés du sprite et vous pouvez créer des pages de texture dans l' éditeur de groupe de texture. Si vous avez un certain nombre d'images qui ne sont utilisées que dans le menu principal (par exemple), rassemblez-les sur une page de texture distincte. De même si vous avez des images spécifiques au niveau, ou le joueur et les ennemis, etc. Fondamentalement, vous voulez les regrouper par utilisation afin que les échanges soient réduits au maximum. De plus, pour aider à garder la VRAM optimisée, vous pouvez ensuite utiliser les différentes fonctions de prélecture et de vidage pour charger et supprimer des textures de la mémoire si nécessaire. REMARQUE: comme mentionné au début de cette page, si votre jeu fonctionne correctement avec un FPS décent, ne vous inquiétez pas trop des échanges de texture... en particulier lors de la création de projets sur les cibles du bureau. Ces optimisations sont optimales lorsqu'elles sont utilisées avec de grands jeux ou sur des appareils mobiles bas de gamme, et lorsqu'elles sont utilisées de manière incorrecte, elles peuvent en fait avoir un impact négatif sur les performances. Les informations sur les sommets sont envoyées par «lots» au GPU pour le dessin, et en général, plus le lot est grand, mieux c'est. Il faut donc éviter de «casser» le lot lors du dessin, car cela augmentera le nombre de lots de sommets envoyés au GPU. Il y a un certain nombre de choses qui vont casser le lot, les principaux étant les modes de fusion, la définition de la couleur de dessin, la définition de l' alpha de dessin et le dessin à l'aide des formes et des primitives intégrées. Donc, si vous avez un certain nombre d'instances de puces qui se dessinent à l'aide du bm_add mode de fusion - par exemple - vous allez créer un nouveau lot de sommets pour chacun d'eux, ce qui est certainement une mauvaise chose! Au lieu de cela, ayez un objet contrôleur dans votre jeu qui dessine toutes les balles à la place, comme ceci:gpu_set_blendmode(bm_add); with (obj_BULLET)     {     draw_self();     } gpu_set_blendmode(bm_normal);
     REMARQUE: cela ne s'applique pas uniquement à l'utilisation de bm_add - toute modification de fusion interrompra le lot et donnera un impact sur les performances. De cette manière, toutes les puces seront tirées dans le même lot. Cette méthode peut être appliquée à l'alpha et dessiner la couleur aussi, et en fait une utilisation judicieuse des fonctions gpu_set_blendenable(), gpu_set_alphatestref(), et gpu_set_alphatestenable() peuvent considérablement améliorer les performances et peuvent être activés / désactivés selon les besoins dans le code de votre projet, bien qu'ils ne conviennent pas à tous les types de graphiques ou de projets. REMARQUE: Si vous n'avez pas besoin que l'instance se dessine elle-même lorsque vous utilisez un contrôleur de cette manière, vous pouvez simplement ajouter un commentaire dans l'événement Draw pour supprimer le dessin par défaut, ou rendre l'instance invisible (bien que cela empêchera tout le code de s'exécuter pour l'instance dans tous les événements de tirage au sort). Une autre façon de réduire ces nombres consiste à désactiver l' option Séparer la page de texture pour les sprites, sauf si c'est absolument nécessaire. Chaque image stockée de cette manière est envoyée à sa propre page de texture et groupée différemment, il est donc préférable d'avoir ces images sur une page de texture régulière. Vous pouvez ensuite obtenir les coordonnées UVS en utilisant le sprite_get_uvs() fonction et stockez-les dans des variables pour une utilisation ultérieure. Cela peut être une petite quantité de code supplémentaire, mais le coup de pouce que vous obtiendrez en vaut la peine. Notez que cette méthode n'autorisera pas les répétitions de texture! Comme pour tous ces conseils, si cela vous rend la vie plus difficile de le changer et que votre jeu fonctionne bien, ne vous en faites pas trop... Particules Les particules offrent un moyen très rapide et efficace de créer des effets dynamiques dans votre jeu, et en général, elles donnent de bonnes performances. Cependant, il convient de noter que l'utilisation du mélange additif, du mélange alpha et du mélange de couleurs sur les particules peut réduire ces performances, en particulier sur les cibles mobiles, donc si vous n'en avez pas besoin, ne l'utilisez pas! Le mélange d'additifs, en particulier, peut augmenter considérablement les lots de sommets et doit être utilisé avec précaution. Notez que sur la cible HTML5 non WebGL, avoir des particules multicolores et décolorées nécessitera beaucoup de mise en cache d'image et sera très lent. Cependant, comme les sprites de particules peuvent être animés, vous pouvez créer un sprite animé qui a des sous-images qui changent de couleur, puis les utiliser pour la particule à la place. Cela ressemblera toujours à un changement de couleur progressif, mais ne nécessitera pas la création constante d'images de cache. Pour en savoir plus sur les particules, consultez la page Guide d'utilisation des particules. Surfaces Enfin, nous allons aborder brièvement l'utilisation des surfaces, car GameMaker Studio 2 a une optimisation assez importante lors de leur utilisation dans vos jeux: la possibilité d'activer et de désactiver le tampon de profondeur. Lorsque vous utilisez simplement des surfaces comme d'habitude, GMS2 crée en fait une surface et un tampon de profondeur qui l'accompagne pour assurer un tri de profondeur approprié lorsque vous dessinez quoi que ce soit en 3D. Cependant, pour la plupart des jeux 2D, ce tampon de profondeur supplémentaire n'est tout simplement pas nécessaire et prend donc de l'espace mémoire supplémentaire et du temps de traitement qui pourrait être utilisé pour d'autres choses. C'est là que la fonction surface_depth_disable() entre en jeu... Cette fonction peut être appelée avant de créer une surface pour désactiver la génération de tampon de profondeur, et toutes les surfaces créées par la suite n'auront pas de tampon de profondeur créé pour elles. Vous pouvez activer / désactiver cette fonction selon vos besoins, et même l'appeler une fois au début du jeu pour désactiver les tampons de profondeur pour tous les appels de surface ultérieurs (et dans la plupart des jeux 2D, c'est très bien). Cela n'augmentera pas considérablement les performances, mais c'est certainement quelque chose à garder à l'esprit si votre jeu repose fortement sur les surfaces et pourrait empêcher votre jeu de manquer de mémoire sur des appareils moins performants. Outre les principaux éléments mentionnés ci-dessus, il existe d'autres éléments plus généraux qui peuvent aider à la performance et qui sont également considérés comme des «bonnes pratiques»: n'ayez pas peur d'utiliser les fonctions trigonométriques car (contrairement à la croyance populaire) elles sont assez rapides, surtout par rapport aux particules, collisions, cordes, etc... ne mettez pas de code qui n'est pas pour dessiner des choses dans les événements Draw utiliser une alarme pour appeler tout code qui n'a pas besoin d'être appelé à chaque étape (plutôt que de simplement l'ajouter à l'événement Step de toute façon) Mais, comme nous l'avons mentionné au début de la page, toutes ces optimisations sont facultatives et si votre jeu fonctionne bien avec 60 lots de sommets, 80 swaps de texture, mélange additif, etc., alors ne vous inquiétez pas trop! Gardez ces choses à l'esprit lors de la programmation de votre prochain jeu...  Retour: Informations complémentaires Suivant: Le système de fichiers © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

