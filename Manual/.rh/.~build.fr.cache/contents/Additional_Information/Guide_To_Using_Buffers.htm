 Guide d'utilisation des tampons Un tampon (en programmation) est essentiellement un espace dans la mémoire système qui est utilisé pour stocker de petits paquets de données pour à peu près tout (par exemple: transfert de données, collisions, données de couleur, etc.). Puisqu'il est conservé dans la mémoire système, son accès est très rapide, et un tampon serait généralement utilisé pour un stockage à très court terme, comme recevoir des informations réseau avant de les traiter, ou pour stocker un point de contrôle dans votre jeu (cela est expliqué dans le exemple donné plus bas dans la page). Les buffers sont créés en allouant un espace dans la mémoire du système, calculée octet s, qui est ensuite réservée à votre jeu aussi longtemps que votre jeu est en cours d' exécution ou jusqu'à ce que vous supprimez le tampon en utilisant la fonction appropriée (vous pouvez trouver toutes les GML fonctions tampon listés ici ). Cela signifie que même lorsque votre jeu n'est pas mis au point (par exemple, sur un appareil mobile lorsque vous prenez un appel, le jeu sera mis en arrière-plan), le tampon existera toujours, mais si le jeu est fermé ou redémarré, le le tampon sera perdu. REMARQUE: le redémarrage du jeu n'effacera ni ne supprimera la mémoire tampon! Mais cela empêchera tout accès supplémentaire au tampon précédemment créé car la poignée d'ID aura été perdue, provoquant une fuite de mémoire qui finira par planter votre jeu. Ainsi, lorsque vous redémarrez un jeu, n'oubliez pas de supprimer d'abord les tampons. GameMaker Studio 2 permet la création de quatre types de tampons différents. La raison en est que les tampons sont conçus pour être un support de stockage temporaire hautement optimisé, et en tant que tel, vous devez créer un tampon adapté au type de données que vous souhaitez stocker, sinon vous pourriez obtenir des erreurs ou provoquer un goulot d'étranglement. dans votre code. Avant d'expliquer cela plus en détail, examinons les quatre types de tampons disponibles (définis comme des constantes dans GML ): Constant la descriptionbuffer_fixed Un tampon d'une taille fixe en octets. La taille est définie lors de la création du tampon et ne peut plus être modifiée.buffer_grow Un tampon qui se développera dynamiquement au fur et à mesure que des données sont ajoutées. Vous le créez avec une taille initiale (qui devrait être une approximation de la taille des données censées être stockées), puis il se développera pour accepter d'autres données qui dépassent cette taille initiale.buffer_wrap Un tampon dans lequel les données seront enveloppées. Lorsque les données ajoutées atteignent la limite de la taille de la mémoire tampon, l'écrasement sera replacé au début de la mémoire tampon et une nouvelle écriture se poursuivra à partir de ce point.buffer_fast Il s'agit d'un tampon spécial "dépouillé" qui est extrêmement rapide en lecture / écriture. Cependant, il ne peut être utilisé qu'avec buffer_u8 types de données et doit être aligné sur 1 octet. (Vous trouverez des informations sur les types de données et l' alignement des octets plus bas sur cette page). Ce sont les types de tampons disponibles lorsque vous utilisez GameMaker Studio 2, et celui que vous choisissez dépendra grandement de l'utilisation que vous souhaitez en faire. Par exemple, un tampon de croissance serait utilisé pour stocker un «instantané» de données pour créer une sauvegarde car vous ne connaissez pas la quantité réelle de données qui va y être placée, ou un tampon rapide serait utilisé lorsque vous sachez que les valeurs avec lesquelles vous travaillez sont toutes comprises entre 0 et 255 ou -128 et 127, par exemple lors du traitement de données ARVB à partir d'une image. Lors de la création d'un tampon, vous devez toujours essayer de le créer à une taille appropriée au type, la règle générale étant qu'il doit être créé pour accueillir la taille maximale des données à stocker, et en cas de doute, utilisez un tampon de croissance pour éviter les erreurs d'écrasement. Le code réel pour créer un tampon ressemblerait à ceci:player_buffer = buffer_create(16384, buffer_fixed, 2); Cela créerait un tampon fixe de 16 384 octets et aligné sur 2 octets, la fonction renvoyant une valeur d'ID unique qui est stockée dans une variable pour un référencement ultérieur de ce tampon. Lors de la lecture et de l'écriture de données dans un tampon, vous le faites par "morceaux" de données définis par leur "type de données". Le "type de données" définit le nombre d'octets alloués dans le tampon pour la valeur en cours d'écriture, et il est essentiel que vous obteniez cela correctement sinon vous obtiendrez des résultats très étranges (voire des erreurs) pour votre code. Les tampons sont écrits (et lus à partir de) séquentiellement, en ce qu'un élément de données est écrit après l'autre, chaque élément de données étant d'un type défini. Cela signifie que vous devriez idéalement être conscient des données que vous écrivez dans la mémoire tampon à tout moment. Ces types de données sont définis dans GML par les constantes suivantes: Constante de type de données Octets Descriptionbuffer_u8 1 Un entier 8 bits non signé. Il s'agit d'une valeur positive comprise entre 0 et 255.buffer_s8 1 Un entier signé de 8 bits. Cela peut être une valeur positive ou négative de -128 à 127 (0 est classé comme positif).buffer_u16 2 Un entier 16 bits non signé. Il s'agit d'une valeur positive comprise entre 0 et 65 535.buffer_s16 2 Un entier 16 bits signé. Cela peut être une valeur positive ou négative de -32 768 à 32 767 (0 est considéré comme positif).buffer_f16 2 Un nombre à virgule flottante de 16 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 65504. (Pas actuellement pris en charge!)buffer_u32 4 Un entier 32 bits non signé. Il s'agit d'une valeur positive comprise entre 0 et 4 294 967 295.buffer_s32 4 Un entier 32 bits signé. Cela peut être une valeur positive ou négative de -2 147 483 648 à 2 147 483 647 (0 est considéré comme positif).buffer_f32 4 Un nombre à virgule flottante de 32 bits. Cela peut être une valeur positive ou négative dans la plage de +/- 16777216.buffer_u64 8 Une valeur entière non signée de 64 bits. (Pas actuellement pris en charge par toutes les fonctions de tampon!)buffer_f64 8 Un nombre à virgule flottante de 64 bits.buffer_bool 1 Une valeur booléenne. Ne peut être que 1 ou 0 (true ou false )buffer_string N / A Il s'agit d'une chaîne à terminaison nulle (0x00) UTF-8. Fondamentalement, une GameMaker est sauvegardée dans le tampon et un 0 est placé à la fin. Donc, disons que vous avez créé un tampon et que vous souhaitez y écrire des informations, vous utiliserez quelque chose comme le code suivant:buffer_write(buff, buffer_bool, global.Sound); buffer_write(buff, buffer_bool, global.Music); buffer_write(buff, buffer_s16, obj_Player.x); buffer_write(buff, buffer_s16, obj_Player.y); buffer_write(buff, buffer_string, global.Player_Name); en regardant l'exemple ci-dessus, vous pouvez voir que vous pouvez écrire différents types de données dans un tampon en même temps (vous n'êtes limité qu'à un type de données spécifique lors de l'utilisation du type de tampon rapide ), et ces données seront ajoutées dans le tampon séquentiellement (bien que sa position réelle dans le tampon dépende de son alignement d'octets, expliqué ci-dessous). C'est la même chose pour la lecture des informations du tampon également, et dans le cas de l'exemple donné ci-dessus, vous liriez depuis le tampon dans le même ordre que vous avez écrit les données, en vérifiant le même type de données, par exemple:global.Sound = buffer_read(buff, buffer_bool); global.Music = buffer_read(buff, buffer_bool); obj_Player.x = buffer_read(buff, buffer_s16); obj_Player.y = buffer_read(buff, buffer_s16); global.Player_Name = buffer_read(buff, buffer_string); Comme vous pouvez le voir, vous lisez les informations dans le même ordre que vous les avez lues dans la mémoire tampon. Pour plus d'informations sur la façon d'ajouter et de supprimer des données du tampon, veuillez consulter les exemples ci-dessous. Si vous avez lu cette page, vous aurez vu des références à l' alignement d'octets d'un tampon. Cela fait essentiellement référence à la position à laquelle les nouvelles données seront stockées dans un tampon donné. Comment cela marche-t-il? Eh bien, pour un tampon aligné sur un seul octet, chaque élément de données est écrit dans le tampon de manière séquentielle, chaque nouvel élément de données étant ajouté directement après le précédent. Cependant, un tampon aligné sur 2 octets écrira chaque élément de données à des intervalles de 2 octets, de sorte que même si votre écriture initiale est de 1 octet de données, l'écriture suivante sera déplacée pour s'aligner sur deux octets: Donc, si votre alignement d'octets est défini sur, disons, 4 octets et que vous écrivez un seul élément de données d'une taille de 1 octet, alors faites un tell de tampon (un tell obtient la position actuelle de lecture / écriture pour le tampon), vous obtiendrez un décalage de 1 octet (le décalage dans ce cas est le nombre d'octets entre le début du tampon et la position actuelle de lecture / écriture). Cependant, si vous écrivez un autre élément de données, également d'une taille de 1 octet, puis faites un buffer tell, vous obtiendrez un décalage de 5 octets (même si vous n'avez écrit que 2 octets de données) car l'alignement a rempli les données pour l'aligner avec l'alignement de tampon de 4 octets. Fondamentalement, cela signifie que l'alignement n'affectera que l' endroit où les choses sont écrites, donc si vous faites un buffer tell après avoir écrit quelque chose, il retournera la position d'écriture actuelle qui suit immédiatement les données que vous avez écrites précédemment. Notez, cependant, que si vous écrivez ensuite un autre élément de données, le tampon déplacera en interne la position d'écriture le long du multiple suivant de la taille d'alignement avant d'écrire réellement l'élément de données. Ci-dessous, nous avons quelques exemples d'utilisation des tampons dans un projet: Point de contrôle du tampon Un exemple simple de la façon dont un tampon peut être utilisé dans n'importe GameMaker Studio 2 pour n'importe quelle plate-forme, est la fonction game_save_buffer(). Cette fonction prendra un "instantané" de l'état actuel du jeu et l'enregistrera dans un tampon prédéfini, qui pourra ensuite être lu pour charger à nouveau le jeu à ce moment-là. REMARQUE: Cette fonction est très limitée et est conçue pour que le débutant puisse mettre en place un système de point de contrôle et le faire fonctionner rapidement, mais les utilisateurs plus avancés peuvent préférer coder leur propre système en utilisant les fonctions de fichier, car le jeu ne sera pas sauvegardé. n'importe laquelle des ressources dynamiques que vous pouvez créer au moment de l'exécution comme des structures de données, des surfaces, des sprites ajoutés, etc. La première chose que nous devons faire est de créer un nouvel objet pour contrôler l'enregistrement et le chargement, donc vous en feriez un et lui donneriez un événement de création. Dans ce cas, vous pouvez placer le code suivant:SaveBuffer = buffer_create(1024, buffer_grow, 1); StateSaved = false; La première ligne crée un tampon de croissance (puisque nous ne connaissons pas la taille finale des données enregistrées) de 1024 octets et aligné sur 1 octet. Une variable est ensuite créée pour vérifier et voir si le jeu a été sauvegardé ou non (cela sera utilisé pour le chargement). Ensuite, nous ajouterions un événement Keypress (par exemple) dans lequel nous enregistrerons l'état actuel du jeu dans le tampon créé:StateSaved = true; buffer_seek(SaveBuffer, buffer_seek_start, 0); game_save_buffer(SaveBuffer);
     Ce qui précède définira d'abord la variable de contrôle sur true  (pour que cela soit sauvegardé lorsque nous sauvegardons le jeu dans la mémoire tampon), puis cherchons au début de la mémoire tampon avant d'y écrire l'état de sauvegarde actuel. Pourquoi utilisons-nous buffer_seek() ? Eh bien, comme mentionné déjà sur cette page, vous lisez et écrivez dans un tampon à partir de la dernière position où les données y ont été ajoutées. Cela signifie que si vous ne définissez pas le rappel du tampon au début, lorsque vous sauvegarderez, vous ajouterez les données dans le tampon à la position actuelle de lecture / écriture du tampon. Donc, nous utilisons la fonction buffer_seek() pour déplacer le tell au début du tampon. Nous avons maintenant enregistré l'état actuel du jeu dans une mémoire tampon. La prochaine étape serait de coder comment le charger, probablement dans un autre événement Keypress:if StateSaved    {    buffer_seek(SaveBuffer, buffer_seek_start, 0);    game_load_buffer(SaveBuffer);    } Le jeu sera alors chargé à la fin de l'événement dans lequel vous placez le code ci-dessus. REMARQUE: ceci est uniquement destiné à être utilisé dans la même pièce, et non pour générer des parties sauvegardées complètes après la fermeture ou le redémarrage de votre partie! La dernière chose à ajouter à l'objet contrôleur est un code de «nettoyage». Les tampons sont stockés en mémoire et, en tant que tels, si vous ne nettoyez pas lorsque vous en avez terminé, vous pouvez obtenir des fuites de mémoire qui finiront par ralentir et planter votre jeu. Vous ajouteriez donc probablement un événement de fin de salle (de la catégorie Autre événement) avec:buffer_delete(SaveBuffer); Cet objet peut maintenant être placé dans une pièce et sur une touche, enregistrer et charger l'état de la pièce à partir d'un tampon. Tampons réseau Lorsque vous travaillez avec les fonctions de mise en réseau de GameMaker Studio 2, vous devez utiliser des tampons pour créer le paquet de données envoyé via la connexion réseau. Cet exemple vise à montrer comment cela est fait, mais en raison de l'étendue des possibilités de mise en réseau, il est uniquement conçu pour montrer comment utiliser les tampons eux-mêmes, et non le système de mise en réseau complet. La première chose que nous allons montrer est la création et l'utilisation d'un tampon pour le côté client de la connexion réseau. Ce tampon sera utilisé pour créer de petits paquets de données qui peuvent ensuite être envoyés au serveur, donc dans l' événement de création d'une instance, nous attribuerions un tampon comme celui-ci:send_buff = buffer_create(256, buffer_grow, 1); Nous rendons le tampon petit (256 octets) - car il n'est pas destiné à contenir de grandes quantités de données - puis nous en faisons un tampon de croissance pour éviter les erreurs si nous devons ajouter plus de données à envoyer à tout moment, et l'alignement est réglé sur un pour plus de commodité. Maintenant, disons que nous voulons que notre client envoie des données au serveur. Pour cela, nous devons créer un "paquet" de tampon, et dans cet exemple, nous allons envoyer un événement de pression de touche, comme lorsque le joueur appuie sur la flèche gauche pour se déplacer dans le jeu. Pour ce faire, nous écrivons d'abord les données nécessaires dans le tampon, puis nous les envoyons:buffer_seek(buff, buffer_seek_start, 0); buffer_write(buff, buffer_u8, 1); buffer_write(buff, buffer_s16, vk_left); buffer_write(buff, buffer_bool, true); network_send_packet(client, buff, buffer_tell(buff)); Avant d'écrire dans le tampon, nous avons mis le "tell" au début du tampon car la mise en réseau prend toujours les données depuis le début d'un tampon. Nous écrivons ensuite la valeur de contrôle (celle-ci sera utilisée par le serveur pour déterminer le type d'événement à traiter), puis la clé utilisée, puis l'état de la touche (dans ce cas vrai pour enfoncée). Ce tampon est ensuite envoyé sous forme de paquet de données par la fonction réseau. Notez que nous n'envoyons pas tout le tampon! Nous n'envoyons que les données écrites, en utilisant la fonction buffer_tell pour renvoyer la position courante de lecture / écriture du tampon (rappelez-vous que l'écriture dans le tampon déplace le "tell" à la fin de ce qui a été écrit). C'est simplement pour éviter d'envoyer plus d'octets que nécessaire. Qu'en est-il de la réception des données sur le serveur? Le paquet de données reçu qui doit être écrit dans la mémoire tampon du serveur puis utilisé pour mettre à jour le jeu. Pour cela, nous utiliserions l' événement asynchrone de mise en réseau dans l'objet contrôleur de réseau du serveur, comme le montre ce code simplifié ci-dessous:var buff = ds_map_find_value(async_load, "buffer"); if cmd == buffer_read(buff, buffer_u8);    {    key = buffer_read(buff, buffer_s16);    key_state = buffer_read(buff, buffer_bool);    } L'événement asynchrone contiendra une carte DS temporaire spéciale async_load (il est automatiquement retiré de la mémoire à la fin de l'événement) qui contient des informations différentes selon le type de données entrantes du réseau. Dans ce cas, nous supposons que la carte a été vérifiée et s'est avérée être un paquet de données tampon envoyé par un client. Nous vérifions maintenant le premier élément de données qui se trouve dans la mémoire tampon pour voir quel type d'événement a été envoyé - dans ce cas, la valeur "1" représente un événement clé, mais lors du codage de ces éléments, vous devez définir des constantes pour contenir ces valeurs. simplifier les choses - puis stocker la touche enfoncée et son état (true = enfoncé, false = libéré). Ces informations seraient ensuite utilisées pour mettre à jour tous les clients avec le nouveau statut du lecteur client expéditeur. REMARQUE: le tampon qui est créé à partir du mappage DS est automatiquement supprimé à la fin de l'événement asynchrone réseau afin qu'il n'y ait pas besoin d'utiliser buffer_delete () ici.  Retour: Informations complémentaires Suivant: Opérateurs au niveau du bit © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

