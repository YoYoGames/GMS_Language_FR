 Opérateurs binaires et binaires Au début de l'ère informatique, le binaire et l' hex (hexadécimal) étaient un mode de vie, probablement parce que les langages de haut niveau (comme BASIC) étaient tout simplement trop lents à fonctionner. Par exemple, la multiplication de 32 x 32 aurait pu prendre plusieurs cycles de processeur pour obtenir l'utilisation de BASIC, mais avec le binaire, cela se fait en une seule opération dans un seul cycle de processeur. De nos jours, cependant, avec la puissance même d'un PC de base, vous n'avez plus à vous en soucier et vous pouvez faire les choses sur le "long chemin", car la vitesse de la machine et la construction de son processeur plus complexe compenseront tout court vient cette approche a. C'est une excellente nouvelle bien sûr, car cela signifie que vous n'avez plus besoin d'optimiser chaque ligne de code que vous écrivez, mais si tel est le cas, devriez-vous vraiment vous soucier du binaire? La réponse est définitivement "oui, vous devriez". Bien qu'il soit vrai que vous pouvez toujours obtenir des accélérations - et parfois celles-ci peuvent être importantes - l'utilisation de binaire et hexadécimal permet de mieux comprendre le fonctionnement du processeur et peut également conduire à écrire un meilleur code, à mieux emballer les données et à rendre certaines tâches beaucoup plus simples. Cette page va expliquer un peu ce qu'est le binaire ainsi que comment il peut être utilisé lors de la création de vos jeux. Examinons donc d'abord la théorie binaire la plus élémentaire - comment les nombres sont créés. Jetez un œil à ce tableau:000 = 0 001 = 1 010 = 2 100 = 4 Chaque 1 ou 0 représente un seul bit de données, et comme vous pouvez le voir, cela signifie qu'en binaire, 10 équivaut à 2! Chaque bit est 2 fois la valeur précédente, le premier bit étant égal à 1. Donc, bit 2 = 2, bit 3 = 4, bit 4 = 8 et ainsi de suite (comme indiqué ci-dessous dans ce tableau d' octets):00000001 = 1 00000010 = 2 00000100 = 4 00001000 = 8 00010000 = 16 00100000 = 32 01000000 = 64 10000000 = 128 C'est bien si vous voulez des nombres d'une puissance de 2, mais comment pouvons-nous créer des nombres plus complexes? Eh bien, un seul nombre binaire ne peut stocker qu'un 0 ou un 1, et c'est tout, donc pour les nombres plus complexes, nous devons ajouter des bits ensemble. Si par exemple nous voulions faire 6, nous ajouterions 4 et 2 ensemble ainsi.00000010 = 2 00000100 = 4 00000110 = 6 Cela est vrai de tous les nombres binaires et de la façon dont l'ordinateur compose n'importe quel nombre en interne. Prenons un nombre légèrement plus compliqué comme autre exemple: 23. Le nombre 23 est en fait composé de 1+2+4+16 ou 00010111. Que diriez-vous d'un exemple beaucoup plus complexe: 196? Eh bien, c'est fait de 128+64+4 ou 11000100. Donc en fait, ce n'est pas si complexe que ça! Si nous commençons à faire des valeurs en dehors de la plage d'un octet (qui peut stocker des nombres de 0 à 255), cela commence à devenir un peu plus difficile à suivre, cependant. Par exemple, 217361 est 110101000100010001 en binaire. Ou, 1+16+256+etc... Les règles sont les mêmes quelle que soit la valeur exprimée - chaque nombre est créé en ajoutant plusieurs bits ensemble. Maintenant, comment effectuer des opérations mathématiques sur ces valeurs? Disons que vous voulez stocker true ou false comme valeur. Habituellement, les compilateurs utilisent un INT (un INT est généralement défini comme un nombre 32 bits signé - signé signifie simplement qu'il peut avoir une valeur positive ou négative, tandis que non signé signifie qu'il ne peut être que positif), puis attribuez-le simplement à 0 ou 1. N'ayant que 2 états, un true / false la valeur est idéale pour stocker un peu, et si nous faisions cela, nous pourrions stocker 32 true / false bits pour chacun INT plutôt qu'un seul, puisqu'un INT est composé de 32 bits. Comment ferions-nous cela? Eh bien, assez facilement, il s'avère:flags = flags | 1; Le "| "l'opérateur est un bit à bit OR, et cela signifie l'instruction ci-dessus ORs 1 dans la valeur contenue dans la variable flags. Si vous vous souvenez de plus tôt, l'utilisation d'un 1 définira le premier bit. Si nous voulions définir le deuxième bit, nous le ferions:flags = flags | 2; Nous OR en 2, car le motif binaire 00000010 est égal à 2. Alors, que fait exactement le binaire OR opérateur faire? Eh bien, il fusionne tous les bits ensemble en une seule valeur, comme ceci:010110100 // Value 1 110011001 // value 2 110111101 // Value 1 OR Value 2 Voici ce que l'on appelle une table de vérité pour l'opérateur OR:00 | 00 = 00 00 | 01 = 01 01 | 01 = 01 01 | 00 = 01 Donc, là où il y a une valeur avec 2 zéros, elle restera zéro. L'avantage d'utiliser des bits comme celui-ci comme true /false état, est-ce que vous pouvez définir plusieurs bits comme "indicateurs" en une seule opération, ce que vous ne pouvez tout simplement pas faire avec une valeur booléenne normale. Par exemple, disons que le bit 1 est un indicateur "actif" et le bit 3 est un indicateur "visible". Nous pourrions définir les deux en faisant ceci:flags = flags | 5; C'est parce que 5 est 00000101 en binaire, et suivant la règle ci-dessus, la variable "flags" obtiendra ces deux bits fusionnés avec les siens. Ainsi, même si le bit 1 était déjà défini, l'opération fonctionne toujours et le bit 3 sera désormais également défini. Qu'en est-il de la compensation des drapeaux? Eh bien, c'est là que le bit "& "AND l'opération entre en jeu. Lorsque vous AND quelque chose, les bits qui sont définis dans le masque sont conservés, tandis que les bits qui sont clairs dans le masque sont supprimés - comme ceci:01110010101 // Value 1 00110000100 // Value 2 00110000100 // Value 1 AND value 2 Comme vous pouvez le voir, là où il y a un 1 dans chaque valeur, le 1 est conservé, et là où il y a un mélange ou des 0 et des 1, ils sont remis à 0. Voici la table de vérité pour AND ing:00 & 00 = 00 01 & 00 = 00 00 & 01 = 00 01 & 01 = 01 Donc, ce n'est que lorsqu'il y en a un peu à chaque endroit qu'il sera conservé. Cela signifie que tout comme vous pouvez définir plusieurs indicateurs à la fois, vous pouvez également effacer plusieurs indicateurs à la fois. Par exemple, prenons le cas ci-dessus, mais cette fois clarifiez-les. Nous voulons effacer les bits 1 et 3 (nous donnant la valeur 5), mais en nous souvenant de la table de vérité ci-dessus, ce que nous voulons faire est de conserver tous les autres bits et d'effacer les bits 1 et 3. Ce serait un masque binaire " "sur 11111111111111111111111111111010 (32 bits). Ce masque conserve tous les bits actuellement définis, mais efface les deux bits que nous voulons effacer. Donc, si j'avais une valeur de 1000111011 et que je voulais effacer les bits 1 et 3 en utilisant le masque ci-dessus, cela finirait comme ça...00000000000000000000001000111011 // Value 11111111111111111111111111111010 // Mask 00000000000000000000001000111010 // Value AND Mask C'est génial, mais si nous devions résoudre ce problème à chaque fois que nous devions effacer les drapeaux, cela deviendrait ennuyeux. Ce dont nous avons besoin, c'est d'un moyen de retourner les bits facilement (et de préférence sans coût CPU). Heureusement, il existe un moyen simple de le faire en utilisant le " ~ " NOT opérateur. le NOT l'opérateur est juste ce qu'il dit - pas ces bits. Voici une table de vérité pour NOT.~00 = 11 ~01 = 10 ~10 = 01 ~11 = 00 Cet opérateur rend la suppression des drapeaux très simple, et mieux encore, c'est généralement une optimisation du temps de compilation, ce qui signifie que si vous utilisez un nombre constant (c'est-à-dire pas une variable), le compilateur retournera automatiquement les bits pour vous. Prenez cette instruction où nous voulons effacer à nouveau les bits 1 et 3:a = a & ~5; Ce sera en fait compilé à seulement "a & 11111111111111111111111111111010 ". Cela rend la vie assez simple en termes de compensation des drapeaux. Le dernier opérateur que nous voulons examiner est "^ " EOR (Exclusive OR, appelé quelques fois XOR ), cet opérateur retourne les bits définis dans les deux valeurs. Ici se trouve le EOR table de vérité:0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0 Ceci est curieux, mais incroyablement utile. Par exemple, disons que nous voulons un compteur qui compte simplement de 0 à 1 et de retour à 0 (basculement entre 0 et 1), nous pourrions en ajouter un et faire un IF pour voir s'il est arrivé à 2, puis le réinitialiser à 1. Ou... nous pourrions ajouter 1 et ensuite AND avec 1 (depuis 01+01 = 10, et 10 & 01 = 0 ) ou nous pouvons le faire:a = a ^ 1; Ce que cela fait la première fois qu'il est exécuté est 0 ^ 1 = 1, puis la deuxième fois 1 ^ 1 = 0, basculant ainsi les choses dans les deux sens de 0 à 1. Alors - OR (| ), AND (& ), NOT (~ ) et EOR (^ ) manipulons les bits avec une relative facilité, nous permettant, au niveau le plus simple, de contrôler plusieurs bits à la fois. Nous pouvons évidemment utiliser ces opérations pour d'autres choses lors du développement de nos jeux, comme masquer des sprites, faire des entiers MOD opérations (utilisation AND ) ou faire de jolis compteurs en boucle. Donc, nous pouvons faire simplement des opérations au niveau du bit, mais regardons les choses plus complexes, en commençant par la question, comment un ordinateur ajoute-t-il? Regardons un exemple très simple: 1+1.00000001 00000001
     00000010
   Tout comme les additions normales, nous ajoutons des nombres ensemble puis nous débordons dans la colonne suivante, mais contrairement à une addition décimale normale, nous ne pouvons aller que de 0 à 1, pas de 0 à 9. Donc, ajouter un 1+1 signifie que nous débordons dans 10. Alors regardons un exemple plus complexe.01011011 = 91 00101101 = 45 10001000 = 136 C'est évidemment plus difficile à voir ici, mais les débordements ondulent jusqu'à ce qu'il n'y en ait plus dans une colonne. Il est à noter que les ordinateurs ne peuvent ajouter (ou soustraire, multiplier ou diviser) que 2 nombres à la fois. Prendre 19 + 19 + 19. Étant humain, nous pouvons additionner tous les 9 ensemble, porter le 2 et puis c'est parti! Mais les ordinateurs ne peuvent pas faire cela - ce qu'ils peuvent faire, c'est ceci: (19 + 19) + 19. Ils feront donc chaque calcul par blocs de 2. Les calculs binaires qui nous intéressent le plus en tant que programmeurs sont la multiplication et la division. Les ordinateurs ne se multiplient que par 2, et pour en faire plus, cela divisera un nombre, puis additionnera tous les résultats ensemble. Prenons d'abord quelques exemples très simples. 4 * 2 = 8. Maintenant, pour multiplier par 2 en binaire, on décale tous les bits vers la GAUCHE par un. Comme ça:00000100 * 2 = 00001000 = 8 Tous les bits dans ce cas se sont déplacés de un vers la gauche, le faisant passer du 3ème bit au 4ème et en changeant la valeur de 4 à 8. Que diriez-vous d'un plus grand nombre?101 = 01100101 * 2 = 11001010 = 202 Encore une fois, tous les bits se déplacent sur un, et cela se multiplie par 2. Alors, que diriez-vous d'un multiple de 4? Facile, on décale tout à gauche par 2, plutôt que par un. Alors qu'en est-il de 16 ou 128? Cela nécessiterait un décalage vers la gauche de 4 bits ou 7 bits respectivement. C'est incroyablement utile; cela signifie que nous pouvons faire de simples multiplications en déplaçant simplement des bits. Pour ce faire, nous utilisons l'opérateur de décalage gauche <<. Voici quelques exemples:00000001 << 1 = 000000010 = 2 00000001 << 2 = 000000100 = 4 00000001 << 3 = 000001000 = 8 00000001 << 4 = 000010000 = 16 00000001 << 5 = 000100000 = 32 00000001 << 6 = 001000000 = 64    00000001 << 7 = 010000000 = 128 00000001 << 8 = 100000000 = 256 Maintenant, en plus d'être très utile pour les multiplications rapides / simples, il est également très utile pour définir des bits spécifiques, sans avoir à déterminer la valeur du bit. Disons que nous voulions régler le bit 27, de quel numéro s'agit-il? (67108864 au fait!), Eh bien, nous pouvons utiliser la syntaxe ci-dessus pour définir facilement des indicateurs comme celui-ci:a = a | (1 << 27) D'accord... donc en fait, ce serait le bit 26 de la façon dont nous avons décrit les choses jusqu'à présent (car les bits ont commencé à un), mais en fait... les bits commencent au bit 0 et vont vers le haut, pas au bit 1 Ainsi, alors qu'il y a 32 bits dans un INTEGER, les bits vont de 0 à 31, et non de 1 à 32. C'est en fait assez utile, car nous pouvons maintenant configurer des constantes pour les nombres de bits. Disons que le bit 27 est un indicateur actif et le bit 0 est un indicateur explosif. Comment pouvons-nous définir les deux?ACTIVE = 27; BOOM = 0; A = A | (1 << ACTIVE) | (1 << BOOM); Cela peut ressembler à beaucoup de code, mais si ces nombres sont des constantes, le compilateur précompilera ces opérations en une seule valeur afin que nous finissions avec cela comme du code réel.A = A | 13421772; Effacer ces bits (comme nous l'avons vu ci-dessus) consiste simplement à utiliser le modificateur NOT, comme ceci:A = A & ~((1 << ACTIVE) | (1 << BOOM)); Cela nous permet donc de définir et d'effacer tous les bits que nous souhaitons, et cela nous permet également de compresser massivement les structures de données. La compression des structures de données est une bonne chose, car si vous utilisez moins de mémoire, vous obtenez moins d'erreurs de cache et votre code s'exécute plus rapidement. En d'autres termes, qu'est-ce qui est plus rapide, copier 32 Mo ou des données, ou 4 Mo? Eh bien, très clairement 4 est. Donc, si vous pouvez regrouper tous vos drapeaux en un seul accès mémoire, c'est bien! Voyons maintenant comment vous faites la division et pourquoi cela sera si utile. La division se fait en décalant les bits vers la droite à l'aide de l'opérateur de décalage droit >>. Prenons un simple nombre - 64 - et divisons-le par 32:64 / 32 = 01000000 >> 5 = 00000010 Donc là, vous décalez le bit unique de 5 (qui est le nombre de décalages requis pour 32 - regardez ci-dessus), ce qui nous donne 2. Mais que se passe-t-il s'il y a d'autres bits là-dedans? Jetons un coup d'oeil:68 / 32 = 01000100 >> 5 = 00000010 Alors voilà…. C'est exactement la même chose. Les bits que nous décrochons sont simplement perdus. C'est en fait très utile, car lors de la division si nous avons besoin du reste, il existe un moyen encore plus simple de l'obtenir, auquel nous reviendrons dans un instant. Mais d'abord, prenons un exemple pratique. J'ai une position X et Y, et je veux obtenir la cellule de grille dans laquelle se trouve, où la grille mesure 32x32. Cette méthode permet de stocker des objets, des collisions, des drapeaux - toutes sortes de choses, et d'y accéder très rapidement. Alors on y va:var X_index = x >> 5; var Y_index = y >> 5; cell_data = mygrid[# X_index,Y_index]; Alors, et si nous voulions le reste? Peut-être que ce reste est utilisé comme une sorte d'indicateur d'ordre ou quelque chose comme ça. Quelle que soit la raison, obtenir un reste est aussi simple que de faire un AND:var remainder = x & 31 var X_Index = x >> 5; Maintenant, vous avez peut-être remarqué que nous avons utilisé plusieurs lignes de code ici (comme c'est souvent le cas), mais ce n'est encore que quelques instructions très rapides. Mais pourquoi le 31? Eh bien, comme le bit 5 est 32, alors tous les bits ci-dessous seraient 31, et c'est le reste maximum, c'est ce que nous AND avec (on pourrait aussi utiliser (1 << 5) - 1 ce qui ferait 32 - 1 = 31 ). Maintenant, si je devais faire cela sans comprendre le binaire, cela ressemblerait à ceci:var r = x mod 32; var X_Index = floor(x / 32); Alors pourquoi est-ce bien pire? Eh bien, pour diviser par 32, nous devons exécuter une division en virgule flottante - ce qui prend évidemment du temps, mais pour faire le mod 32, vous devez en faire un autre! Si nous faisions cela en assembleur, nous obtenons en fait LES DEUX valeurs dans une division, mais vous n'obtenez pas cela dans des langages de haut niveau (enfin... pas très souvent), et vous devez donc faire tout le travail deux fois. Cela s'additionne, surtout si vous faites une boucle serrée avec beaucoup de calculs comme celui-ci. Les divisions entières en utilisant le décalage de bits comme indiqué ci-dessus aident vraiment à optimiser votre jeu. Comme cela peut être un concept assez complexe à appréhender puis à appliquer à des situations de programmation réelles, vous pouvez trouver ci-dessous une série de courts exemples qui pourraient être appliqués à n'importe quel jeu réalisé avec GameMaker Studio 2. Alignement des tuiles GameMaker Studio 2 utilisent souvent la fonction place_free(), puis lorsqu'une collision est trouvée, essayez de déplacer lentement l'objet en faisant une boucle autour d'un x ou y position tout en continuant à exécuter cette fonction, ou en utilisant le move_outside_all() une fonction. Alors, quel est le moyen le plus rapide de le faire? Eh bien, si nous utilisons des tuiles de puissance de 2 appropriées, nous avons une méthode très simple qui est également ultra-rapide. Si nous nous déplaçons à droite et que nous sommes passés dans un bloc de collision, alors comme nous savons que tout est aligné sur 32, nous devons également aligner le sprite sur une limite de 32 pixels - de préférence celle de gauche - donc le sprite est sorti de la collision. C'est vraiment facile, connaissant les règles que nous avons utilisées ci-dessus pour obtenir le reste, et sachant comment obtenir l'inverse des bits, nous pouvons simplement faire ceci:x = x & ~31; C'est vrai, c'est TOUT ce qu'il faut pour s'aligner sur une limite de 32 pixels. En changeant le 31, nous pouvons nous aligner sur tout ce que nous voulons - tant que c'est une puissance de 2. (C'est l'équivalent de diviser par 32, puis de multiplier par 32, supprimant ainsi les bits inférieurs.) Si nous voulions nous aligner à droite, nous ferions ce qui précède, mais en ajouterions 32 pour le déplacer dans la tuile suivante. Simple. Tout cela accélère considérablement le code de collision et vous permet de passer le temps du processeur là où vous en avez vraiment besoin. Clés et portes Disons que vous avez un niveau avec quelques portes et une clé pour chacune. Comment pouvez-vous facilement marquer une clé pour une porte spécifique? Eh bien, normalement, vous attribueriez simplement une pièce d'identité à la clé et à la porte. Et si vous vouliez une clé pour ouvrir 2 ou 3 portes? Facile. Vous utilisez un MASQUE. La porte aurait un seul bit attribué comme ceci:door_id = 1; // 0001 Les autres seraient quelque chose comme:door_id=2; // 0010door_id=4; // 0100door_id=8; // 1000etc... Si nous voulions que la clé ouvre les portes 1 et 3, alors la clé aurait la valeur MASK de 5 (qui est 101 en binaire). Si nous effectuons un AND de cela, et il sort "pas zéro", alors nous savons que la clé peut ouvrir la porte. Vous pouvez également avoir des clés qui n'ouvrent rien en ayant un MASQUE de 0. Voir le code ci-dessous pour la vérification réelle:if ((key_id & door_id) ! = 0)    {    opendoor();    } Compteurs en boucle Disons que nous voulons un compteur d'animation simple, allant de 0 à 15 (car nous avons 16 images d'animation). Normalement, vous feriez un incrément, puis un if check pour envelopper le nombre, mais pour cet exemple, utilisons l'opérateur AND(&)counter = (counter + 1) & 15; Puisque 16 est une puissance de 2, nous pouvons réduire ce nombre de 1 et l'utiliser comme masque, que nous pouvons ensuite utiliser pour envelopper notre valeur de compteur. Si le compteur passe de 15 à 16, on se retrouve avec un motif de bits 10000, et si nous AND celui avec 15 (motif binaire 01111 ) nous nous retrouvons avec 00000 (simplement zéro). Cela signifie que le code ci-dessus est utile pour encapsuler des valeurs dans la plage d'une puissance de 2. Puissance de 2 chèques Et si vous vouliez vérifier si quelque chose était une puissance de 2? Eh bien, voici un petit truc sympa.. Cela reviendra true si la valeur donnée est une puissance de 2:function is_pow2(_val)    {    return _val & (_val - 1)) == 0;    } Donc, si nous avions le nombre 51 (110011 ) qu'est-ce que cela fait? Eh bien, nous avons ceci... 110011 & 110010, ce qui nous laisse évidemment avec false, car il reste beaucoup de bits après le AND. Si nous avions 64 (1000000 ), alors ça devient ça... 1000000 & 0111111 ce qui nous laisse 0, donc c'est true. Alignement d'index Voici un petit bout de code pour s'aligner sur la puissance de 2 nombres. (1, 2, 4, 8, 16 et ainsi de suite). Cela peut être très utile pour l'allocation de mémoire ou pour vous assurer que vous écrivez les données dans les limites appropriées. Dans cet exemple, _val1 doit être aligné sur _val2 octets, où _val2 est une puissance de 2 nombres. Cette petite fonction arrondit à la limite suivante du nombre souhaité.function align_pow2(_val1, _val2)    {    return _val1 + (_val2 - 1)) & ~(_val2 - 1);    } Retour: Informations complémentaires Suivant: Tables de types © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

