 Guide d'utilisation des particules Ce guide s'adresse à ceux d'entre vous qui souhaitent comprendre comment utiliser et créer des particules. Cette page couvrira à la fois les fonctions du GameMaker Language et les actions Drag and Drop™ pour les particules, donc si vous n'avez jamais utilisé de particules auparavant, nous espérons que ce guide pourra vous aider à démarrer car elles sont très utiles et assez amusantes à réaliser. Avant d'aller plus loin, nous devrions probablement expliquer ce qu'est réellement une particule... Fondamentalement, une particule est une ressource graphique qui possède certaines propriétés qui sont définies par un système de particules. Ces propriétés ne peuvent pas être manipulées directement pour des particules individuelles, mais sont modifiées collectivement via le code ou les actions utilisées pour définir le système auquel elles appartiennent. Ils sont très utiles pour créer des effets magnifiques et flashy - ou des effets subtils et discrets - dans un jeu sans la surcharge de processeur que l'utilisation d'instances a. Nous avons mentionné les systèmes de particules, alors expliquons ce que c'est avant de continuer. Pensez à un système de particules comme un récipient que vous utiliserez pour contenir vos particules prêtes à l'emploi. Vous pouvez utiliser du code ou des actions pour définir l'aspect visuel des particules, puis elles sont placées dans le "conteneur" (le système de particules) afin que vous puissiez le retirer et l'utiliser quand et où vous en aurez besoin plus tard. Avant de configurer un système et de créer des particules, il est important de savoir quelques choses... Tout d'abord, la plupart du code d'un système de particules n'est appelé qu'une seule fois dans le jeu, généralement dans un type d'objet contrôleur dans la première salle ou niveau. - ce n'est pas toujours le cas, mais par souci de simplicité, nous utiliserons ce scénario pour le bref guide suivant car c'est la manière la plus courante d'utiliser les particules. Vous faites cela parce qu'un système de particules, une fois créé, reste en mémoire et est prêt à être utilisé à tout moment, donc si vous le créez plus d'une fois, il peut rapidement augmenter l'utilisation de la mémoire et provoquer un retard important, et a même le potentiel de écraser le jeu. Par souci de simplicité dans ce guide, vous allez créer un système de particules global qui peut être utilisé par n'importe quelle instance du jeu à tout moment. Créer un système de particules Pour commencer, vous devez définir le système de particules et lui donner un nom pour pouvoir l'utiliser. Comme il s'agira d'un système global que n'importe quel objet peut utiliser, vous le feriez dans un objet contrôleur ou une fonction d'initialisation exécutée au début du jeu. Le GML ressemblerait à ceci:global.P_System = part_system_create_layer("Instance_Layer", false); Et en utilisant DnD™: Notez que le nom du calque fourni doit être un calque valide dans la pièce où le système sera utilisé, sinon aucune particule ne sera visible. Notez également que nous définissons le drapeau "persistant" (à la fois dans le code et dans DnD™) sur false. Un système de particules persistant est celui qui «persistera» dans les pièces sans avoir à le détruire et à le recréer pour chaque pièce. Cependant, pour simplifier les choses pour ce guide, nous n'utiliserons pas la persistance. C'est donc le système créé, mais qu'en est-il des particules? Nous devons les définir aussi ou le système est inutile et ne fait rien. Définition d'un type de particule Pour utiliser une particule dans un système, vous devez d'abord définir ses propriétés générales. Ce sont comme des propriétés d'objet, mais elles ne s'appliquent que de manière générale aux particules individuelles. Cela signifie que si vous donnez aux particules une vitesse de déplacement minimum de 1 et une vitesse de déplacement maximum de 2, toute particule créée par le système aura une vitesse aléatoire comprise entre 1 et 2 pixels par pas, et que globalement elles auront un vitesse moyenne de 1,5. Vous devez nommer et ajouter votre première particule au système en utilisant le GML suivant dans le même objet que vous avez utilisé pour créer le système:global.Particle1 = part_type_create(); Et pour ceux d'entre vous qui utilisent DnD™: Notez qu'en utilisant DnD™, nous cochons également l'option de fusion. Cela permet un mélange additif pour la particule, dont nous parlerons un peu plus loin. Vous avez maintenant un système et une particule à y mettre, mais vous n'êtes pas encore prêt à créer vos effets exceptionnels! Vous devez encore définir les propriétés de la particule, c'est-à-dire: à quoi elle ressemble - sa vitesse, sa rotation, son alpha etc... Il y a beaucoup de détails qui peuvent être utilisés pour définir un effet de particule, donc ci-dessous est un aperçu des paramètres les plus importants, puis un extrait de code et DnD™ qui les utilise tous: shape: La forme de la particule est le sprite intégré qu'elle utilisera, la valeur par défaut étant la constante pt_shape_pixel. Il existe également une fonction pour ajouter une particule personnalisée si nécessaire -part_type_sprite() - ou l'action Set Particle Sprite. size: définit les paramètres de taille pour le type de particule. Vous spécifiez la taille de départ minimale, la taille de départ maximale et l'augmentation de la taille à chaque étape (utilisez un nombre négatif pour une diminution de la taille). Il s'agit d'une valeur scalaire qui modifiera également l'échelle x / y de l'image de base. couleur: définit la couleur de la particule si une seule couleur est utilisée. Si deux ou trois couleurs sont fournies, ce sera le mélange de couleurs, se mélangeant de l'une à l'autre au cours de sa durée de vie. alpha: définit la valeur alpha de la particule entre une valeur de 0 et 1. Si une seule valeur est transmise, ce sera l'alpha de la particule, si deux ou trois valeurs sont transmises, l'alpha se fondra entre celles-ci sur le durée de vie de la particule. speed: définit les propriétés de vitesse pour le type de particule. Vous spécifiez une vitesse minimale et maximale et une valeur aléatoire entre les limites données est choisie lors de la création de la particule. Vous pouvez indiquer une augmentation de la vitesse à chaque étape, et même utiliser des nombres négatifs pour ralentir la particule (la vitesse ne deviendra jamais inférieure à 0). direction: définit les propriétés de direction du type de particule. Encore une fois, vous spécifiez une plage de directions (en degrés dans le sens inverse des aiguilles d'une montre - 0 indique un mouvement vers la droite, 90 indique un mouvement vers le haut, etc.). Par exemple, pour laisser la particule se déplacer dans une direction aléatoire, vous choisiriez un minimum de 0 et un maximum de 360 comme valeurs. Vous pouvez également spécifier une augmentation de la direction pour chaque pas (peut également être négative). orientation: définit les propriétés d'angle d'orientation pour le type de particule. Vous spécifiez l'angle minimum, l'angle maximum et l'augmentation à chaque étape. Vous pouvez également indiquer si l'angle donné doit être relatif à la direction actuelle du mouvement ou absolu, par exemple: en définissant toutes les valeurs sur 0 mais par rapport à vrai, l'orientation de la particule suivra précisément le chemin de la particule. mélange: définit s'il faut utiliser le mélange additif ou le mélange normal pour le type de particule. Ceci est défini dans une fonction lors de l'utilisation de GML et dans le cadre de l'initialisation des particules lors de l'utilisation de DnD™. Le mélange additif signifie que les particules utiliseront le bm_add mode de fusion, en leur donnant un aspect "brillant" là où ils se chevauchent, et en les mélangeant également avec tout ce qui est dessiné en dessous (sprites, arrière-plans, tuiles, etc.) - très utile pour les effets de feu et de magie (par exemple), mais mieux à gauche pour quelque chose comme de la fumée. Expérimentez pour voir les différences! Notez que l'activation de cette option interrompra le traitement par lots des textures lors de la création des particules, et donc plus de lots seront nécessaires par étape pour les dessiner - ce qui peut affecter les performances, en particulier sur mobile. life: définit les limites de la durée de vie, en étapes (images de jeu) pour le type de particule. Comme les paramètres précédents, cela a une valeur minimale et maximale et les particules dureront un nombre aléatoire d'étapes dans ces valeurs. Ainsi, une durée de vie de 30 min et 30 max aura la particule existant pendant exactement 30 étapes, mais une durée de vie de 20 min et 60 max aura chaque particule existe pour un nombre aléatoire d'étapes entre 20 et 60. Maintenant, avant de vous présenter le code pour définir la particule, parlons simplement de " wiggle " pendant un moment... Croyez-le ou non, "wiggle" est une propriété de particule et peut être définie individuellement pour plusieurs des paramètres ci-dessus. Lorsque vous voyez «wiggle» comme argument pour une fonction ou une action de particule, cela signifie que si vous placez un nombre entre 1 et 20, la particule «remuera» ou fluctuera entre les valeurs min et max de la propriété, 1 étant un agitation lente et 20 étant très rapide. Ainsi, une vitesse de particule minimum de 2 et maximum de 5 avec une oscillation de 20 oscillera très rapidement entre les vitesses min / max pour la durée de vie de chaque particule créée. REMARQUE: Il existe également d'autres propriétés de particules mineures que nous ne couvrons pas ici, juste pour garder les choses aussi simples que possible pour commencer. Voir les pages appropriées pour plus de détails sur les propriétés des particules. Regardons maintenant un code qui définit une particule://This defines the particles shape part_type_shape(global.Particle1,pt_shape_pixel);
       //This is for the size part_type_size(global.Particle1,1,1,0,2);
       //This sets its colour. There are three different codes for this part_type_color1(global.Particle1,c_white);
       //This is its alpha. There are three different codes for this part_type_alpha1(global.Particle1,1);
       //The particles speed part_type_speed(global.Particle1,0.50,2,-0.10,0);
       //The direction part_type_direction(global.Particle1,0,359,0,20);
       //This changes the rotation of the particle part_type_orientation(global.Particle1,0,0,0,0,true);
       //This is the blend mode, either additive or normal part_type_blend(global.Particle1,1);
       //this is its lifespan in steps part_type_life(global.Particle1,5,30);
     Pour créer cette même définition de particule dans DnD™, nous aurions besoin de ces actions: Donc c'est tout! Nous avons maintenant défini nos particules et elles sont prêtes à être utilisées. Création de particules directement dans le jeu Il existe plusieurs façons de créer des particules, et chacune a ses avantages et ses inconvénients. Vous pouvez utiliser des émetteurs pour éclater ou diffuser des particules, ou vous pouvez créer des particules directement en un point. Celui que vous utilisez dépend vraiment de ce que vous essayez d'obtenir et de l'effet que vous souhaitez créer, mais nous commencerons par le plus simple des deux, qui consiste à créer directement des particules. En GML nous utiliserions la fonction suivante:part_particles_create(global.P_System, x, y, global.Particle1, 10); et dans DnD™, ce serait: Ce code / action unique ci-dessus créera 10 particules aux coordonnées x / y données de type «Particule1» à partir de notre système global. Simple! La grande chose à propos de cette ligne de code / action est qu'elle peut être utilisée n'importe où sans aucun problème. Par exemple, si vous le placez dans l' événement Global Left Pressed pour la souris dans un objet et changez les valeurs x / y pour la position mouse_x / y, il créera des particules à la position de la souris chaque fois que vous appuierez sur le bouton. Ou si vous avez une fusée, vous pouvez la placer dans l'événement d'étape et avoir des particules de fumée à chaque étape (bien que 1 ou 2 serait probablement mieux que 10!). Vous pouvez même lui demander de créer des particules sur une zone en modifiant les coordonnées x / y de manière aléatoire, par exemple:repeat(50)     {     var xx = x + 20 - random(40);     var yy = y + 20 - random(40);     part_particles_create(global.P_System, xx, yy, global.Particle1, 1);     } Le code ci-dessus créera 50 particules à une position aléatoire dans une zone carrée de 40 px. Création de particules avec des émetteurs Puisque nous avons expliqué la manière simple de créer des particules, passons maintenant à la manière légèrement plus complexe, qui consiste à utiliser des émetteurs. Les émetteurs sont une autre partie du système de particules qui doit être défini avant d'être utilisés, nous allons donc créer un émetteur global comme nous l'avons fait pour le système et les particules. Nous devons également décider d'avoir un émetteur statique (non mobile) ou non et si nous allons faire éclater ou diffuser les particules, ainsi que décider de la zone et du type de distribution que l'émetteur va utiliser.. Qu'est-ce que tout cela signifie? Eh bien, un émetteur statique est celui que vous pouvez définir une fois et oublier car il ne se déplacera nulle part pendant la durée du jeu, c'est-à-dire: pensez à un feu de bois - il ne bouge pas, il émet juste des flammes et ainsi de suite. statique, mais une boule de feu nécessiterait un émetteur dynamique et se déplacera sur l'écran. En ce qui concerne l'éclatement ou le ruissellement, une rafale est une explosion ponctuelle de particules, alors qu'un flux n'est que cela - un flux constant de particules à chaque étape. Pour la zone et la distribution, avec les émetteurs, vous pouvez définir une zone pour émettre des particules (qui peut être un rectangle, une ellipse, un losange ou une ligne) ainsi que la courbe de distribution (gaussienne, gaussienne inverse ou linéaire). Les images suivantes illustrent les différents types de forme de zone disponibles pour les émetteurs:  Et les courbes de distribution (linéaire, gaussienne et gaussienne inverse) sont illustrées ici: Vous trouverez ci-dessous un exemple du code / des actions nécessaires pour définir deux émetteurs, qui iraient normalement dans l' événement Créer un objet contrôleur, juste après avoir défini le système de particules. L'un sera statique et diffusera des particules sur toute la surface de la pièce, tandis que l'autre sera dynamique et suivra la souris et éclatera tous les 30 pas à partir d'une petite ellipse:global.Particle1_Emitter1 = part_emitter_create(global.P_System); global.Particle1_Emitter2 = part_emitter_create(global.P_System);
       //Set up the area that will emit particles part_emitter_region(global.P_System, global.Particle1_Emitter1, 0, room_width, 0, room_height, ps_shape_rectangle, ps_distr_linear); part_emitter_region(global.P_System, global.Particle1_Emitter2,
      mouse_x-10, mouse_x+10, mouse_y-10, mouse_y+10, ps_shape_ellipse, ps_distr_gaussian);
       //Set the first to stream 10 particles every step part_emitter_stream(global.P_System, global.Particle1_Emitter1, global.Particle1, 10);
       //This can now be forgotten as it will function until told to stop... //Set the alarm[0] event to burst the emitter2 particles... alarm[0] = 30; Nous créons donc ici deux émetteurs de particules qui sont affectés au système de particules que nous avons créé au départ. Les fonctions / actions pour créer ces émetteurs nous permettent de définir une zone dans la pièce sur laquelle ils émettront des particules, ainsi que de donner le type de particule à émettre, ainsi que la forme et la distribution à utiliser dans la zone définie. Les fonctions / actions renverront une valeur numérique, qui est la valeur de l'ID de l'émetteur, et nous la stockons dans une variable afin que nous puissions utiliser d'autres fonctions d'émetteur pour cibler ces émetteurs. Maintenant, nous avons le code / DnD™ aux particules flux (ces particules seront émises à chaque étape de jeu sans que nous ayons à quoi que ce soit d' autre), mais nous voulons aussi ajouter un A Larm [0] Événement de particules en rafale à des intervalles spécifiques:part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x - 10, mouse_x + 10, mouse_y - 10, mouse_y + 10, ps_shape_ellipse, ps_distr_gaussian); part_emitter_burst(global.P_System, global.Particle1_Emitter2, global.Particle1, 30);      alarm[0] = 30; Une explosion de particules est simplement une explosion ponctuelle de particules de l'émetteur, plutôt qu'un flux constant de celles-ci à chaque étape du jeu. Mais que faire si vous voulez que plusieurs objets émettent des particules? Un émetteur global ne peut se trouver qu'à un seul endroit à la fois, vous devrez donc créer des émetteurs locaux dans chaque objet. Ces émetteurs utiliseront toujours le système global de particules et toutes les particules qui s'y trouvent, mais ils peuvent être de formes et de tailles différentes et se déplacer avec l'objet, ce qui les rend idéaux pour les fusées, les balles ou les objets. Le code que vous utiliseriez est exactement le même que ci-dessus, mais sans le préfixe «global» avant les noms des émetteurs. C'est la création de particules dont on s'occupe, mais il y a encore une chose qui est très importante... Nettoyer quand on en a fini avec elles. Nettoyer Comme mentionné au début, une fois créé, un système de particules (et ses particules, émetteurs etc...) sont stockés en mémoire pour une utilisation instantanée. Génial, mais que se passe-t-il lorsque vous redémarrez le jeu? Ou si votre joueur meurt et redémarre la salle? Eh bien, si vous ne gérez pas le jeu correctement, vous obtenez une fuite de mémoire. C'est quand quelque chose a été créé et utilise de la mémoire, mais a été «dé-référencé», ce qui signifie que GameMaker n'y a plus accès. Ce genre de chose va lentement consommer de la mémoire et provoquer un retard dans votre jeu ou même bloquer l'ordinateur, ce qui fait planter votre jeu, et c'est un problème assez courant avec les nouveaux utilisateurs de systèmes de particules. Comment éviter ça? Eh bien, GameMaker Studio 2 a GML et DnD™ pour supprimer les systèmes de particules et leurs émetteurs et particules de la mémoire lorsqu'ils ne sont pas utilisés et avec un peu de planification lors de l'utilisation du code / actions suivants, vous pouvez facilement éviter ce problème potentiel. La première chose à faire est de décider où vous allez créer le système et comment vous allez l'utiliser. Vous pouvez créer un système global dans l' événement de début de jeu d'un objet qui se trouve dans votre première pièce (comme un menu ou un écran de titre), mais cela signifie que si vous redémarrez le jeu en utilisant le game_restart() fonction, il sera recréé et provoquera une fuite de mémoire. Ou vous pouvez créer un système local dans une instance dans n'importe quelle pièce, mais encore une fois, si vous quittez la pièce, le système sera inaccessible et provoquera une fuite de mémoire. Pour éviter cela, vous devez avoir quelque chose comme ça dans l' événement de fin de jeu ou l' événement de nettoyage de votre objet:part_type_destroy(global.Particle1); part_emitter_destroy(global.P_System, global.Particle1_Emitter); part_emitter_destroy(global.P_System, global.Particle2_Emitter); part_system_destroy(global.P_System);
     Cela supprimera les particules définies, les émetteurs, puis le système de la mémoire, prêt à vous permettre de redémarrer le jeu ou de changer de salle. N'oubliez pas qu'après avoir réfléchi à l'endroit le plus approprié pour créer le système, réfléchissez à l'endroit le plus approprié pour détruire le système aussi! Maintenant que vous connaissez les bases des particules, des systèmes de particules et des émetteurs, vous pouvez maintenant les ajouter à votre jeu! Mais avant de vous précipiter et d'ajouter des effets de particules à tout, veuillez noter que si les particules sont moins gourmandes en CPU que les instances, elles ne sont pas la solution à tout car elles entraîneront un décalage si vous en avez des milliers à la fois. La meilleure chose à faire est d'expérimenter et de les utiliser avec précaution pour «étoffer» visuellement un jeu et lui donner un peu plus de plaisir pour les yeux sans trop le faire. Titre déroulant Tapez votre texte déroulant ici  Retour: Informations complémentaires Suivant: Guide d'utilisation des Shaders © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

