 Lecture audio Cet événement ne peut être déclenché que par les fonctions de lecture de la file d'attente audio et renverra une DS Map stockée dans la variable  async_load, contenant différentes paires clé / valeur relatives à la file d'attente audio qui a déclenché l'événement. L'événement est déclenché par un rappel lorsque vous avez sélectionné une file d'attente audio à lire et qu'une mémoire tampon de cette file d'attente audio est terminée. Les clés suivantes seront disponibles dans la carte DS: "queue_id "- l'index de la file d'attente qui a fini de jouer, tel que renvoyé par la fonction audio_create_play_queue(). "buffer_id "- l'ID de la mémoire tampon à partir de laquelle la lecture n'est plus effectuée. "queue_shutdown "- il est réglé sur 0 pendant la lecture normale et 1 lorsque l'événement est reçu car audio_free_play_queue() a été appelé. Lorsqu'il est défini sur 1, vous ne souhaitez pas mettre d'autres données en file d'attente. Puisqu'une file d'attente audio peut être créée à partir de plusieurs tampons, cet événement peut être déclenché plusieurs fois pour une file d'attente lorsque la fin de chaque section d'audio tamponné est atteinte, d'où la clé "buffer_id". REMARQUE: la variable async_load n'est valide que dans les événements asynchrones, car la mappe DS qui pointe vers est créée au début de l'événement, puis supprimée à nouveau à la fin, cette variable étant réinitialisée à la valeur -1. Cependant, toutes les autres structures de données créées à partir de l'événement doivent être nettoyées à l'aide des fonctions appropriées. Dans l'exemple d'utilisation donné ci-dessous, nous allons créer une file d'attente audio avec 10 sons audio tamponnés ajoutés, puis lire la file d'attente:audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono); for (var i = 0; i < 10; i++;)    {    audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));    } audio_play_sound(audio_queue,
    0, true); Chaque étape du jeu maintenant que l'enregistrement est détecté déclenchera un événement d'enregistrement audio asynchrone où vous pouvez traiter l'entrée enregistrée quelque chose comme ceci:var queue = async_load[? "queue_id"]; var num = 0; if queue = audio_queue    {    for (var i = 0; i < 10; i++;)       {       if async_load[? "buffer_id"] == audio_buffer[i]          {  buffer_seek(audio_buffer[i],
    buffer_seek_start, 0);          num = i;          }       }    if num == 9       {       audio_stop_sound(audio_queue);       audio_free_play_queue(audio_queue);       }  }
   Ici, nous vérifions l'ID de la file d'attente et si c'est celui que nous voulons, nous vérifions ensuite l'ID du tampon pour voir quel tampon a fini d'être lu. Nous définissons également une variable locale sur cette valeur d'index pour vérification ultérieure et remettons le tampon au début de ce son. Une fois que notre variable locale atteint 9, indiquant que la file d'attente est terminée, nous arrêtons la lecture du son et libérons la file d'attente.  Retour: Événements asynchrones Suivant: Enregistrement audio © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

