
  
  Événements relatifs aux objets
  Alors, que sont les événements d'objets ? En gros, ce sont des moments discrets dans la boucle du jeu où les choses se produisent en fonction de ce que vous avez programmé pour elles. GameMaker Studio 2 fonctionne avec des cycles de ces événements.
    pièce est commencée jusqu'à ce qu'elle soit terminée, une boucle de jeu se déroule où, à chaque étape , une série d'événements est exécutée ou vérifiée, et vous pouvez choisir de placer du code ou des actions DnD™dans vos objets qui répondent à ces événements (une étape
    est un moment du temps de jeu, régi par le réglage de la vitesse de la pièce, et peut également être appelé une image) .
  Examinons la configuration typique d'un objet avec des événements et du code :
  Comme vous pouvez le voir dans notre exemple d'objet, il existe un certain nombre d'événements auxquels il doit répondre.
    un objet, cette liste est vide et vous devez décider des événements dont vous avez besoin et de ce que les instances de cet objet doivent faire lorsque ces événements sont déclenchés. Pour ajouter des événements à l'objet, vous appuyez sur le bouton Add Event (Ajouter un événement) qui se trouve en bas de la liste des événements.
    ce qui fait apparaître la fenêtre suivante :
  Il s'agit de la liste de tous les événements et catégories d'événements de base auxquels un objet peut répondre.
    événements pour affiner les comportements. Par exemple, si vous cliquez sur la catégorie d'événementKey Press , une autre fenêtre s'ouvrira avec les événements qui vous permettront de sélectionner le comportement de l'objet.
    une autre fenêtre s'ouvre avec les événements qui vous permettent de sélectionner la touche à laquelle l'objet doit répondre. Une fois que vous avez sélectionné votre événement, la fenêtre de code (ou fenêtre de l'espace de travail DnD™) sera enchaînée à celui-ci et s'ouvrira sur la droite.
    Vous pouvez maintenant modifier le code pour donner à votre objet un comportement ou une réaction spécifique à cet événement.
  Vous pouvez cliquer avec le bouton droit de la souris  sur n'importe quel événement qui a été ajouté à un objet pour obtenir les options de menu suivantes :
  Ces options sont :
  
    Ajouter un événement - Ajouter un nouvel événement à partir de la liste des événements.
    Couper / Copier / Coller des événements - Couper, copier ou coller l'événement sélectionné. Vous pouvez également utiliser les raccourcis clavier standard :  /  + X,  /  + C, et  /  + V.
    Dupliquer l'événement - Dupliquer l'événement choisi. Cette opération prend le contenu de l'événement choisi et le duplique dans un autre événement que vous spécifiez.
    Modifier l'événement - Pour modifier l'événement. Vous serez invité à choisir une autre catégorie d'événement et, une fois sélectionné, le contenu de l'événement actuel sera modifié en fonction du nouvel événement (en supprimant l'événement original).
    Convertir en glisser-déposer / code - Les événements d'objet seront créés à l'aide de la méthode choisie lors de la création du projet, soit en utilisant du code, soit en utilisant des actions de glisser-déposer™. Grâce à cette option, vous pouvez convertir de l'une à l'autre, indépendamment du
      du type de projet.
    Supprimer l'événement - Supprime l'événement (ou les événements).
  
  Lorsque vous supprimez des événements, vous pouvez utiliser  +  pour sélectionner plusieurs événements et les supprimer tous ensemble.
    Chaque objet que vous créez possède sa propre liste d'événements qui lui sont ajoutés à partir de l'éditeur d'objets. Ces événements se répartissent en deux catégories :
  
    ceux qui exécutent chaque étape du jeu
    celles qui sont "déclenchées" par un événement du jeu, comme le fait que l'instance atteigne le bord de la pièce ou une pression sur le clavier ou la souris.
  
  La liste complète des événements est donnée ci-dessous :
   
  Créer
  
    Cet événement se produit lorsqu'une instance de l'objet est créée pour la première fois, et c'est la toute première chose qui se produit dans une instance placée dans la pièce par le biais de l'éditeur de pièce lorsqu'on entre dans une pièce. Cet événement est donc l'endroit idéal pour initialiser des variables
      initialiser desvariables, lancer des lignes de temps, définir des chemins, etc... et faire tout ce qui ne doit être fait qu'une fois ou seulement lorsqu'une instance est créée.
      être fait une seule fois ou seulement lorsqu'une instance est créée pour la première fois dans la room. Si votre objet a des variables d'objet ou des variables d'instance ajoutées dans l'éditeur d'objet ou l'éditeur de salle, ces variables seront d'abord initialisées, puis l'événement de création sera lancé.
      variables seront d'abord initialisées, puis l'événement de création sera exécuté.
    Rappelez-vous que vous pouvez modifier tout ce que vous avez configuré dans l'événement de création à partir du code de création d'instance dans l'éditeur de salle, car celui-ci est exécuté directement après l'événement de création de l'instance et peut
      être utilisé pour créer des variables d'instance ou pour remplacer toute variable ajoutée en tant que variable d'objet ou dans l'événement de création actuel.
     
  
  Détruire
  
    Cet événement est l'événement à exécuter lorsqu'une instance est détruite. Il est souvent négligé lors de l'ajout de comportements aux objets, mais il peut être très utile, par exemple en créant des effets d'explosion ou de particules lorsqu'un ennemi est tué, ou pour faire réapparaître une nouvelle instance de l'objet dans une autre partie de la pièce, ou même pour ajouter des points au score.
      une nouvelle instance de l'objet dans une autre partie de la pièce, ou même pour ajouter des points à un score.
     
  
  Nettoyage
  
    Cet événement sera appelé après tout événement qui supprime une instance de l'objet de la pièce. Ainsi, il sera déclenché si :
    
      l'instance est détruite
      la pièce se termine
      le jeu se termine
    
    Il est conçu pour que vous l'utilisiez pour "nettoyer" toutes les ressources dynamiques que vous pouvez avoir dans votre jeu (comme les surfaces, les structures de données, etc...) ou pour effectuer toute tâche dont vous avez besoin une fois que l 'instance est retirée du jeu de quelque manière que ce soit.
    Notez que cet événement sera appelé immédiatement après l'événement qui l'a déclenché, mais l'instance ne sera pas réellement retirée du jeu avant la fin de l'événement en cours. Par exemple, si vous appelez instance_destroy() dans l'événement Step, l'événement Destroy sera appelé, puis l'événement Clean Up, et enfin le reste de l'événement Step se terminera. Cela signifie que tout code que vous avez après l'appel à instance_destroy() sera toujours exécuté et sera une cause potentielle d'erreurs si vous avez nettoyé une structure de données ou toute autre ressource dont le code a besoin, il faut donc faire attention en utilisant cet événement.
    
     
  
  Alarme
  
    La catégorie d'alarme est divisée en 12 événements, un pour chacune des alarmes possibles qui peuvent être définies dans une instance. Ainsi, lorsque vous cliquez sur la catégorie " Ajouter une alarme ", vous obtenez cette fenêtre :
    Vous sélectionnez ici l'alarme que vous souhaitez créer et, une fois que c'est fait, vous verrez qu'elle a été ajoutée à la fenêtre de l'événement, ce qui vous permet d'y ajouter du code comme d'habitude.
      ce qui vous permet d'y ajouter du code comme d'habitude. Mais qu'est-ce qu'une alarme ? Eh bien, il s'agit d'un événement spécial qui ne fait rien, sauf si l'alarme a été préalablement définie, et qui attendra que l'alarme ait décompté jusqu'à 0 avant d'exécuter les actions ou le code que vous lui avez ajoutés.
      ou le code que vous avez ajouté à l'alarme.
    Une fois que l'alarme a atteint 0 et que le code est exécuté, elle décompte alors jusqu'à -1, où elle reste jusqu'à ce qu'elle soit à nouveau activée (ce qui signifie que vous pouvez vérifier la valeur d'une alarme pour voir si elle est supérieure à -1, ce qui vous indiquera si elle est en cours d'exécution ou non). Ainsi, disons que
      vous définissez la valeur 30 pour alarm[0] dans l'événement create de l'objet, cela signifie que GameMaker Studio 2 effectuera un décompte de 30 étapes de jeu avant d'exécuter les actions ou le code placés dans l'événement alarm[0]. Notez que si vous définissez une alarme à 0, le code d'alarme ne sera pas exécuté, car l'événement est déclenché, mais l'alarme est immédiatement définie à -1, de sorte que le code est ignoré. Si vous avez besoin d'une alarme pour exécuter l'étape suivante, vous devez la définir sur 1.
    Cela peut s'avérer très utile car cela vous permet de déclencher des actions à des moments précis, et vous pouvez même les faire répéter car rien ne vous empêche de déclencher une alarme dans son propre événement. Imaginez que vous ayez un monstre et que vous vouliez qu'il tourne à droite toutes les trois secondes...
      trois secondes... Eh bien, vous définissez une alarme dans son événement de création à la vitesse de la pièce * 3 (si la vitesse de la pièce est de 30, c'est 30 pas par seconde, alors multipliez par 3 et vous obtenez 3 secondes !
      pour définir sa direction, ainsi que l'action (ou le code) pour régler son alarme sur la vitesse de la pièce * 3 à nouveau. De cette façon, vous pouvez mettre en place des boucles de jeu simples où les choses ne se produisent qu'à des intervalles spécifiques.
    Il convient de noter qu'une alarme ne contenant aucune action ni aucun code n 'effectuera pas de décompte. Cependant, même avec un simple commentaire et sans code ou action, l'alarme continuera à décompter et pourra être réglée et vérifiée comme vous le feriez normalement.
     
  
  Étape
  
    GameMaker Studio 2 divise le temps en étapes , la vitesse de la pièce définissant le nombre de ces étapes par seconde (une étape peut également être appelée une image). Une étape est en fait une boucle qui tourne en permanence.
      Ainsi, comme vous pouvez l'imaginer, l'événement Step est un événement qui est vérifié à chaque étape du jeu tant que l'instance existe.
    L'événement "step" est en fait composé de trois sous-événements qui sont décrits ci-dessous :
    Pour la plupart des choses, l'événement step standard sera parfait, mais parfois vous voulez un peu plus de contrôle sur le code qui s'exécute et à quel moment.
      et à quel moment. Pour cela, vous disposez des événements Begin et End step. Ces trois événements sont vérifiés à chaque étape, mais leur ordre ne variera jamais, même si des mises à jour ultérieures du moteur de GameMaker Studio 2 modifient d'autres événements de l'étape.
      ce qui signifie qu'il s'agit de la seule méthode fiable pour s'assurer que quelque chose se produit toujours avant quelque chose d'autre.
    A quoi peut servir l'événement step ? Eh bien, il peut être utilisé pour des actions ou du code qui doivent être exécutés en continu. Par exemple, si un objet doit en suivre un autre, vous pouvez ici adapter la direction du mouvement vers l'objet que nous suivons
      pour qu'il continue à se déplacer en douceur derrière. Faites cependant attention avec cet événement, et ne mettez pas d'actions compliquées dans l'événement step des objets, surtout si vous prévoyez d'avoir beaucoup d'instances de l'objet dans votre salle de jeu, car cela pourrait
      ralentir le jeu. Beaucoup de choses peuvent être placées dans des alarmes, ou réglées pour se déclencher en utilisant certains des autres événements, plutôt que de se produire tout le temps.
     
     
  
  Collision
  
    Il est évident que lorsque vous créez un jeu, il est très important que vous sachiez quand deux instances (ou plus) d'un objet sont entrées en collision, et pour cela nous avons l'événement de collision. Il s'agit d'un événement que vous placez dans un objet et pour lequel vous indiquez ensuite
      quel autre objet vous devez vérifier les collisions.
    Si la physique n'est pas activée, ces collisions seront calculées en fonction du masque des deux objets (le masque est défini dans les propriétés du sprite, ou peut être assigné indépendamment dans les propriétés de l'objet) et si elles se chevauchent
      ou non. Notez que si l'une ou l'autre des instances de la collision n'a pas de masque assigné (ou si le masque du sprite est vide), même si elle dessine quelque chose, aucune collision ne sera détectée.
    Si vous avez activé la physique , la collision sera basée sur le type de forme de collision(Fixture) que vous avez défini pour l'objet dans ses propriétés physiques, tout comme sa réaction à la collision. Ce site
      Cela signifie que vous n'aurez peut-être pas besoin de code pour gérer la collision, mais cet événement devra tout de même contenir au moins un commentaire pour que les collisions soient détectées.
    Enfin, il convient de noter que toutes les collisions seront calculées une fois par étape de jeu avant le déclenchement de l'événement de collision, de sorte que lorsque l'événement de collision s'exécute, toutes les collisions auront déjà été calculées et préaffectées. Cela signifie que
      si vous créez une instance dans cet événement et que vous essayez ensuite de vérifier une collision avec elle, la collision ne sera pas détectée ou résolue avant l'itération suivante de la boucle de jeu.
     
     
  
  Clavier,  Keyboard Press,      Libération du clavier
  
    Il est très important de laisser le joueur contrôler les différents aspects de votre jeu et, à cette fin, GameMaker Studio 2 vous fournit une liste très complète d'événements clavier qui peuvent être utilisés dans l'une des trois catégories principales de clavier. Pour la
      catégorie Clavier général, il est déclenché en continu à chaque étape tant que la touche sélectionnée est enfoncée, tandis que les événements de la catégorie Enfoncer et relâcher ne sont déclenchés qu'une seule fois lorsque la touche est initialement enfoncée ou relâchée.
    Il convient de noter que les événements clavier sont en fait déclenchés dans toutes les instances actives d'une pièce chaque fois qu'une touche est utilisée, mais seules celles qui ont un événement défini pour cette touche particulière répondront.
      Vous pouvez créer plusieurs événements clavier dans n'importe quel objet et les instances de cet objet répondront à tous les événements pendant le déroulement du jeu.
    Lorsque vous ajoutez un événement clavier à un objet, le menu des sous-événements clavier s'affiche et vous permet de spécifier la touche à vérifier :
    La plupart d'entre eux sont assez évidents, mais passons en revue les sections brièvement - en haut, nous avons les touches fléchées,
      suivies par les touches de modification les plus utilisées, puis le reste du clavier (divisé en sous-sections supplémentaires afin que vous puissiez obtenir la touche exacte requise, comme  ou ) et enfin deux sous-événements très spéciaux, No Key et Any Key. Comme leur nom l'indique, il s'agit de sous-événements
      événements qui vérifient si aucune touche n'est enfoncée ou si une touche est enfoncée. Veuillez noter que les touches du pavé numérique ne produisent les événements correspondants que lorsque le verrouillage numérique est activé.
    Les événements Press et Release du clavier sont presque exactement les mêmes que les événements normaux du clavier, sauf qu'au lieu d'être déclenchés en continu, ils ne le sont qu'une fois. Lorsque le clavier enregistre pour la première fois
      qu'une touche a été enfoncée, il génère un événement Keyboard Pressed ( ainsi qu'un événement Keyboard normal), et la première fois qu'une touche n'est plus détectée comme enfoncée, il déclenche un seul événement Keyboard Release.
     
     
  
  Souris
  
    La catégorie Souris est séparée en une série d'événements qui peuvent être sélectionnés pour vous donner un contrôle plus précis sur ce qui se passe dans votre jeu. Vous pouvez voir ici ce que sont exactement ces événements :
    Les événements des boutons de gauche , de droite  et du milieu  (qu'ils soient normaux, pressés ou relâchés) fonctionnent tous sur le masque de l'instance qui a l'événement.
      fonctionnent sur le masque de l'instance qui a l'événement. Cela signifie que GameMaker Studio 2 vérifiera la position de la souris dans la pièce lorsque ces boutons sont utilisés par rapport aux masques de collision des instances qui ont un événement souris. Si
      S'il y a une "collision" avec la boîte de délimitation de l'instance , l'événement sera déclenché. Assurez-vous donc que toute instance avec ces événements possède un sprite avec un masque de collision valide ou que l'objet possède un masque de collision valide.
      valide ou que l'objet possède un masque de sprite sélectionné dans les propriétés de l'objet. Comme leurs noms l'indiquent, ces événements seront déclenchés soit une fois, lorsque le bouton de la souris choisi est pressé ou relâché pour la première fois, soit de manière continue à chaque étape tant que le bouton est
      maintenu.
    
    Les événements d'entrée et de sortie de la souris sont également similaires aux événements de bouton dans la mesure où ils dépendent également du masque de l'instance pour fonctionner, mais cette fois-ci, ils sont déclenchés lorsque la souris "entre" (touche) l'instance pour la première fois ou lorsque la souris "quitte" (cesse de toucher) l'instance.
      (cesse de toucher) l'instance. Ces événements ne sont toutefois pas continus et ne sont déclenchés qu'une seule fois à chaque fois que la souris entre ou sort de l'objet. Ils constituent donc une méthode idéale pour créer, par exemple, des boutons qui doivent changer lorsque la souris
      Ils constituent donc une méthode idéale pour créer, par exemple, des boutons qui doivent changer lorsque la souris les survole, avant de revenir à la normale lorsque la souris est retirée.
    Enfin, nous avons une autre section pour les événements de la souris, appelée Souris globale. Dans ce sous-menu, vous trouverez une sélection d'événements permettant d'enregistrer les événements de la souris dans les instances, même si la souris n'est pas au-dessus ou à proximité.
      près d'elles. Ces événements sont générés pour toutes les instances et si des actions ou du code sont définis pour l'événement spécifié, ils seront exécutés, quelle que soit la position de la souris dans la salle de jeu.
    Veuillez noter que sur les appareils mobiles ou à écran tactile, le bouton gauche de la souris  peut également être utilisé pour vérifier la présence d'un doigt sur un écran tactile, et le bouton droit de la souris  est déclenché par une double tape sur l'écran (ce comportement peut être modifié à l'aide d'un code).
     
     
  
  Gestes
  
    Cet événement est celui qui sera déclenché lorsque l'utilisateur touchera l'écran (sur mobile) ou cliquera et déplacera la souris (sur toutes les autres plateformes). Ces événements sont similaires à ceux de la souris, en ce sens qu'il existe des versions régulières et des versions globales.
      Les versions régulières de ces événements ne sont déclenchées que lorsque les contacts se produisent sur une instance possédant un sprite (ou un masque) et que les contacts se produisent dans sa zone de délimitation. Les versions globales
      de ces événements seront déclenchés si l'utilisateur touche n'importe quel endroit de l'écran.
    Les événements gestuels détectent les éléments suivants :
    
       taps - lorsqu'un utilisateur clique/touche et relâche rapidement.
       drags - lorsqu'un utilisateur touche/clique et le maintient puis déplace son doigt/curseur.
       flics - lorsque l'utilisateur déplace et relâche un toucher/clic en un seul mouvement
       pincements - lorsque l'utilisateur a deux doigts sur l'écran et qu'il les rapproche ou les écarte.
       rotation - lorsque l'utilisateur pose deux doigts sur l'écran et les fait pivoter autour d'un point.
    
    Les différents événements contiendront toujours une carte DS appelée carte "event_data", qui contiendra un certain nombre de paires clé/valeur avec des données sur la position et le mouvement du toucher/clic.
      contiendra un certain nombre de paires clé/valeur contenant des données sur la position et le mouvement du toucher/clic. Pour plus de détails sur tous les sous-événements disponibles et leur fonctionnement, veuillez consulter la section suivante :
    
      L'événement Gesture
    
     
     
  
  Autre
  
    Il existe un certain nombre d'événements spéciaux à utiliser lors de la création de jeux avec GameMaker Studio 2. Ils sont pour la plupart regroupés sous l'événement Autre et peuvent être sélectionnés dans le menu contextuel des sous-événements qui s'affiche lorsque vous sélectionnez cet événement. Voici une image
      image de tous ces autres événements :
    Pour plus d'informations sur chacun des événements énumérés dans l'image ci-dessus, veuillez consulter la section suivante :
    
      Les autres événements
    
     
  
  Dessinez
  
    Cette catégorie d'événement est celle qui régit ce que vous voyez à l'écran lorsque vous exécutez votre jeu, et elle est divisée en plusieurs événements discrets :
    Comme vous pouvez le constater, la catégorie des événements de dessin comporte plusieurs types d'événements différents. Draw Begin, Draw et Draw End sont les événements de dessin "standard" que vous utiliserez probablement le plus. Par défaut, l'événement principal Draw est toujours appelé pour chaque instance, qu'elle ait un sprite ou non, bien que si vous marquez l'instance comme invisible, l'événement
      ne sera pas déclenché (gardez donc cela à l'esprit si vous avez une logique de jeu dans l'événement de dessin d'un objet invisible, car elle ne s'exécutera pas). L'événement de dessin principal est également l'endroit où GameMaker Studio 2 dessine par défaut le sprite de l'instance lorsqu'il n'y a pas de code ou d'actions dans l'événement (c'est-à-dire que GameMaker Studio 2 n'est pas en mesure de
      actions dans l'événement (c'est-à-dire que vous ne l'avez pas ajouté à la liste des événements de l'objet). Le dessin par défaut utilise le sprite associé à l'instance et le dessine avec toutes les transformations définies dans le code ou les actions appliquées.
    Les événements de dessin standard dessinent avant les événements Draw GUI et entre les événements Pre Draw et Post Draw , ce qui signifie que tout ce qui est dessiné dans cet événement est dessiné sous celui
      de l'événement Draw GUI , quelle que soit la couche (c'est-à-dire que tout ce qui est dessiné dans l'événement Draw GUI sera toujours dessiné par-dessus tout ce qui est dessiné dans l'événement normal de dessin, quel que soit l'ordre des couches).
    Notez que ce qui précède n'est qu'une vue d'ensemble du fonctionnement des événements de tirage au sort, mais pour des détails complets sur tous les sous-événements disponibles, veuillez consulter la section suivante :
    
      L'événement du tirage au sort
    
     
     
     
  
  Asynchrone
  
    Cette catégorie d'événements est particulière dans la mesure où les événements qu'elle contient ne sont pas déclenchés par défaut par GameMaker Studio 2, mais plutôt par la fin d'une autre action, comme le chargement d'un fichier ou la réponse d'un serveur Web. La catégorie est divisée en
      événements suivants :
    
    Imaginons que vous souhaitiez ajouter un fichier image à GameMaker Studio 2. Vous pourriez coder cette opération dans un autre événement (peut-être l'événement Create) d'un objet, puis faire en sorte que cet objet dessine une barre de chargement en attendant (par exemple), en interrogeant l'événement asynchrone approprié jusqu'au callback qui indique à GameMaker Studio 2 que le fichier a été chargé.
      approprié jusqu'au callback qui indique à GameMaker Studio 2 que le fichier a été chargé. Vous pouvez ensuite utiliser les données renvoyées dans cet événement pour faire d'autres choses, comme changer de pièce ou acheter un objet.
    Notez que ce qui précède n'est qu'une vue d'ensemble du fonctionnement de l'événement asynchrone, mais pour des détails complets sur tous les sous-événements disponibles, veuillez consulter la section suivante :
    
      Liste des événements asynchrones
    
     
  
   
  Vous devez également noter que vous pouvez nommer les événements, ou du moins leur donner un court texte descriptif qui sera affiché à côté d'eux dans l'éditeur d'événements. Pour ce faire, il suffit d'ajouter le texte suivant dans la toute première ligne de l'éditeur de code de l'événement :
  /// @description Votre texte ici
  Ainsi, vous pourriez avoir quelque chose comme ceci dans - par exemple - un événement d'alarme 
  /// @description This is the AI Fight alarm
  Et maintenant, dans votre éditeur d'événements, vous verrez ceci :
  
  Pour les utilisateurs de DnD™, l'ajout d'un commentaire nécessite l'utilisation de l'action Exécuter le code, qui doit être placée tout en haut des actions de l'événement, avant tout le reste. Lorsque vous ajoutez cette action, vous lui donnez alors la même ligne de code
    qui est montrée ci-dessus pour nommer l'événement, par ex :
  Pour de plus amples informations sur certains des événements ci-dessus et sur l'ordre général de déroulement des événements, veuillez consulter les sections suivantes :
  
    Ordre des événements
    Les autres événements
    Les événements du tirage au sort
    Les événements asynchrones
    Les événements du geste
  
   
   
   
  
    
      
        Retour : L'éditeur d'objets
        Suivant : Objets parents
      
    
    Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

