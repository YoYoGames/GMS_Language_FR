 Evénements d'objet Alors, que sont les événements d' objet? Fondamentalement, ce sont des moments discrets dans la boucle du jeu où les choses sont faites en fonction de ce que vous avez programmé pour elles. GameMaker Studio 2 fonctionne avec des cycles de ces événements - à partir du moment où une salle est démarrée jusqu'au moment où elle est terminée, il y a une boucle de jeu en cours où chaque étape une série d'événements est exécutée ou vérifiée, et vous pouvez choisir de placer du code ou DnD™ actions dans vos objets qui répondent à ces événements (une étape est un moment du temps de jeu, régi par le réglage de la vitesse de la pièce, et peut également être appelée une image ). Regardons une configuration d'objet typique avec des événements et du code: Comme vous pouvez le voir dans notre exemple d'objet, il y a un certain nombre d'événements répertoriés auxquels il doit répondre, mais au départ, lorsque vous créez un objet, cette liste est vide et vous devez décider quels événements vous avez besoin et quelles instances de cet objet doivent faire lorsque ceux-ci les événements sont déclenchés. Pour ajouter des événements dans l'objet, vous appuyez sur le bouton Ajouter un événement situé en bas de la liste des événements qui fera apparaître la fenêtre suivante: Il s'agit de la liste de tous les événements de base et catégories d'événements auxquels un objet peut répondre, et dans chaque catégorie se trouvent des sous-événements pour affiner davantage les comportements. Par exemple, si vous cliquez sur K ey Press catégorie d'événement, vous obtiendrez alors une fenêtre supplémentaire avec les événements qui vous permettent de sélectionner la clé à laquelle l'objet doit répondre. Une fois que vous avez sélectionné votre événement, la fenêtre de code (ou DnD de l'espace de travail DnD™) y sera enchaînée et s'ouvrira sur la droite. Vous pouvez maintenant modifier le code pour donner à votre objet un comportement ou une réaction spécifique à cet événement. Vous pouvez cliquer sur le bouton droit de la souris sur tout événement qui a été ajouté à un objet pour obtenir les options de menu suivantes: Ces options sont: Ajouter un événement - Ajoutez un nouvel événement à partir de la liste d'événements. Couper / copier / coller des événements - Coupez, copiez ou collez l'événement sélectionné. Vous pouvez également utiliser les raccourcis clavier standard: / + X, / + C, et / + V. Dupliquer l'événement - Dupliquer l'événement choisi. Cela prendra le contenu de l'événement choisi et le dupliquera dans un autre événement que vous spécifiez. Changer d'événement - Modifiez l'événement. Cela vous invitera à choisir une autre catégorie d'événement et une fois sélectionné, le contenu de l'événement actuel sera remplacé par le nouvel événement (en supprimant l'événement d'origine dans le processus). Convertir en Drag and Drop / code - Les événements d'objet seront créés à l'aide de la méthode choisie lors de la création du projet, soit en utilisant du code, soit en utilisant les Drag and Drop™. Avec cette option, vous pouvez convertir de l'un à l'autre, quel que soit le type de projet. Supprimer l'événement - Supprimez l'événement (ou les événements). Lors de la suppression d'événements, vous pouvez utiliser + pour sélectionner plusieurs événements, puis les supprimer tous ensemble. Chaque objet que vous créez possède sa propre liste discrète d'événements qui y sont ajoutés à partir de l' éditeur d'objets. Ces événements se divisent en deux catégories: ceux qui exécutent chaque étape du jeu ceux qui sont "déclenchés" par un événement de jeu, comme l'instance atteignant le bord de la salle ou une pression sur le clavier ou la souris. La liste complète des événements est donnée ci-dessous: Créer Cet événement se produit lorsqu'une instance de l'objet est créée pour la première fois et est la toute première chose qui se produit dans une instance placée dans la pièce via l'éditeur de pièce lorsqu'une pièce est entrée. Cela signifie que cet événement est le lieu idéal pour initialiser de variables s, commencent Échéances, définies chemins etc... et faire tout ce qui a généralement besoin que d'être fait une fois ou seulement lorsqu'une instance est créée dans la chambre. Si votre objet a des variables d'objet ou des variables d'instance ajoutées dans l'éditeur d'objets ou dans l'éditeur de salle, ces variables seront initialisées en premier, puis l' événement de création sera exécuté. N'oubliez pas que vous pouvez modifier tout ce que vous avez configuré dans Create Event à partir du code de création d'instance dans l'éditeur de salle, car il est exécuté directement après l'événement de création de l'instance et peut être utilisé pour créer des variables d'instance ou pour remplacer les variables ajoutées comme Variables d'objet ou dans l'événement de création réel. Détruire Cet événement est l'événement à exécuter lorsqu'une instance est détruite. Il est souvent négligé lors de l'ajout de comportements à des objets, mais il peut être très utile, par exemple en créant des effets d'explosion ou de particules lorsqu'un ennemi est tué, ou pour réapparaître une nouvelle instance de l'objet dans une autre partie de la pièce, ou même pour ajouter des points à un score. Nettoyer Cet événement sera appelé après tout événement qui supprime une instance de l'objet de la salle. Donc, il sera déclenché si: l'instance est détruite la salle se termine le jeu se termine Il est conçu pour que vous puissiez "nettoyer" toutes les ressources dynamiques que vous pourriez avoir dans votre jeu (comme les surfaces, les structures de données, etc.) ou pour effectuer toute tâche que vous devez effectuer une fois lorsque l'instance est supprimée de le jeu de quelque manière que ce soit. Notez que cet événement sera appelé instantanément après l'événement qui l'a déclenché, mais l'instance ne sera effectivement supprimée du jeu qu'à la fin de l'événement en cours. Par exemple, si vous appelez instance_destroy() dans l'événement Step, alors l'événement Destroy sera appelé, puis l'événement Clean Up, puis le reste de l'événement Step se terminera. Cela signifie que tout code que vous avez après l'appel à instance_destroy() sera toujours exécuté et sera une cause potentielle d'erreurs si vous avez nettoyé une structure de données ou une autre ressource requise par le code, vous devez donc faire attention lors de l'utilisation de cet événement. Alarme La catégorie d'alarme est divisée en 12 événements, un pour chacune des alarmes possibles pouvant être définies dans une instance. Ainsi, lorsque vous cliquez sur la catégorie Ajouter une alarme, cette fenêtre s'affiche: Ici, vous sélectionnez l'alarme que vous souhaitez créer et, une fois que cela est fait, vous verrez qu'elle a été ajoutée à la fenêtre d'événement vous permettant d'y ajouter du code comme d'habitude. Mais qu'est-ce qu'une alarme? Eh bien, c'est un événement spécial qui ne fait rien à moins que l'alarme n'ait été préalablement définie, puis il attendra que cette alarme ait compté à rebours jusqu'à 0 avant d'exécuter les actions ou le code que vous y avez ajouté. Une fois que l'alarme a atteint 0 et exécutera le code, elle comptera à rebours jusqu'à -1, où elle restera jusqu'à ce qu'elle soit à nouveau réglée (ce qui signifie que vous pouvez vérifier la valeur d'une alarme pour voir si elle est supérieure à -1, ce qui indiquera vous si c'est en cours d'exécution ou non). Alors, dis que tu as mis alarm[0] dans l'événement de création de l'objet à 30, cela signifie que GameMaker Studio 2 décompte 30 étapes de jeu avant d'exécuter les actions ou le code qui sont placés dans le alarm[0] un événement. Notez que définir une alarme sur 0 n'exécutera pas le code d'alarme, car l'événement est déclenché, mais l'alarme est immédiatement définie sur -1, le code est donc ignoré. Si vous avez besoin d'une alarme pour exécuter l'étape suivante, réglez-la sur 1. Cela peut être très utile car cela vous permet de mettre les choses en mouvement à des moments précis, et vous pouvez même les faire répéter car rien ne vous empêche de régler une alarme dans son propre événement. Imaginez que vous avez un monstre et que vous voulez qu'il tourne à droite toutes les trois secondes... eh bien, vous définiriez une alarme dans son événement de création à la vitesse de la pièce * 3 (si la vitesse de la pièce est de 30, c'est 30 pas par seconde, donc multipliez cela par 3 et vous obtenez 3 secondes!), puis en cas d'alarme, vous auriez le code ou l'action pour définir sa direction, ainsi que l'action (ou le code) pour régler à nouveau son alarme à la vitesse de la pièce * 3. De cette façon, vous pouvez configurer des boucles de jeu simples où les choses ne se produisent qu'à des intervalles spécifiques. Il est à noter qu'une alarme sans action ni code ne sera pas décomptée. Cependant, même avec juste un commentaire et aucun code ou action, l'alarme continuera à compter à rebours et pourra être réglée et vérifiée comme vous le feriez normalement. Étape GameMaker Studio 2 divise le temps en étapes, la vitesse de la pièce définissant le nombre de ces étapes supposées être par seconde (une étape peut également être appelée une image ). Une seule étape, est fondamentalement la boucle qui s'exécute constamment avec tous les événements vérifiés et déclenchés si nécessaire pendant que le jeu s'exécute, donc comme vous pouvez l'imaginer, l' événement Step est un événement qui est vérifié à chaque étape du jeu pendant que l'instance existe. L'événement d'étape est en fait composé de trois sous-événements décrits ci-dessous: Pour la plupart des choses, l'événement d'étape standard sera parfait à utiliser, mais parfois vous voulez un peu plus de contrôle sur le code qui s'exécute et à quelle heure, donc pour cela, les événements d'étape Begin et End vous sont fournis. Tous les trois sont vérifiés à chaque étape, mais leur ordre ne variera jamais même si les futures mises à jour du GameMaker Studio 2 modifient d'autres événements, ce qui signifie que c'est la seule méthode fiable pour s'assurer que quelque chose se passe toujours avant autre chose. À quoi peut servir l'événement step? Eh bien, il peut être utilisé pour des actions ou du code qui doivent être exécutés en continu. Par exemple, si un objet doit en suivre un autre, vous pouvez ici adapter la direction du mouvement vers l'objet que nous suivons pour le maintenir en mouvement en arrière. Soyez prudent avec cet événement cependant, et ne mettez pas beaucoup d'actions compliquées dans l'événement d'étape d'objets, surtout si vous prévoyez d'avoir beaucoup d'instances de l'objet dans votre salle de jeu, car cela pourrait ralentir le jeu. Beaucoup de choses peuvent être placées dans des alarmes ou configurées pour se déclencher en utilisant certains des autres événements, plutôt que de se produire tout le temps. Collision Évidemment, lors de la création d'un jeu, il est très important que vous sachiez quand deux (ou plus) instances d'un objet sont entrées en collision, et pour cela nous avons l' événement de collision. Il s'agit d'un événement que vous placez dans un objet et que vous spécifiez ensuite contre quel autre objet vous devez rechercher les collisions. Lorsque la physique n'est pas activée, ces collisions seront calculées en fonction du masque des deux objets (le masque est défini dans les propriétés du sprite, ou peut être attribué indépendamment dans les propriétés de l'objet) et si elles se chevauchent ou non. Notez que si l'une ou l'autre des instances de la collision n'a pas de masque affecté (ou si le masque de sprite est défini sur rien), même s'il dessine quelque chose, aucune collision ne sera détectée. Si vous avez activé Physique, la collision sera basée sur le type de forme de collision ( Fixture ) que vous avez défini pour l'objet dans ses propriétés physiques, tout comme sa réaction à la collision. Cela signifie que vous n'aurez peut-être pas besoin de code pour gérer la collision, mais cet événement devra tout de même contenir au moins un commentaire pour que les collisions soient détectées. Enfin, il convient de noter que toutes les collisions seront calculées une fois par étape de jeu avant le déclenchement de l'événement de collision, de sorte que lorsque l'événement de collision se déroule, toutes les collisions auront déjà été calculées et pré-assignées. Cela signifie que si vous créez une instance dans cet événement et que vous essayez ensuite de rechercher une collision avec elle, la collision ne sera pas détectée ou résolue avant la prochaine itération de la boucle de jeu. Clavier, Presse au clavier, Libération du clavier Laisser le joueur contrôler les différents aspects de votre jeu est très important, et à cette fin GameMaker Studio 2 vous fournit une liste très complète d'événements de clavier qui peuvent être utilisés dans l'une des trois principales catégories de clavier. Pour la catégorie générale du clavier, il est déclenché en continu à chaque pas tant que la touche sélectionnée est enfoncée, tandis que les événements de la catégorie Appuyer et relâcher ne seront déclenchés qu'une seule fois lorsque la touche est initialement enfoncée ou relâchée. Il convient de noter que les événements de clavier sont en fait déclenchés dans toutes les instances actives d'une pièce chaque fois qu'une touche est utilisée, mais seuls ceux qui ont un événement défini pour cette touche particulière répondront et vous pouvez créer plusieurs événements de clavier dans n'importe quel objet et les instances. de cet objet répondra à chacun d'eux pendant que le jeu est en cours d'exécution. Lorsque vous ajoutez un événement de clavier à un objet, le menu du sous-événement du clavier s'affiche dans lequel vous pouvez spécifier la touche à rechercher: La plupart d'entre eux sont assez évidents, mais passons brièvement en revue les sections - en haut, nous avons les touches fléchées, suivies des touches de modification les plus utilisées, puis le reste du clavier (divisé en sous-sections supplémentaires pour que vous puissiez obtenir la clé exacte requise comme ou ) et enfin deux sous-événements très spéciaux, No Key et Any Key. Comme leur nom l' indique, ce sont des événements sous qui vérifient si aucune touche est pressée ou quand une touche est enfoncée. Veuillez noter que les touches du pavé numérique ne produisent les événements correspondants que lorsque le verrouillage numérique est activé. Les événements Press and Release pour le clavier sont presque exactement les mêmes que l'événement clavier normal, sauf qu'au lieu d'être déclenchés en continu, ils sont déclenchés une seule fois. Lorsque le clavier enregistre pour la première fois qu'une touche a été enfoncée, il génère un événement Keyboard Pressed (ainsi qu'un événement Keyboard normal), et la première fois après, où une touche n'est plus détectée lorsqu'elle est enfoncée, il déclenchera un seul clavier. Événement de sortie. Souris La catégorie Souris est divisée en une série d'événements qui peuvent être sélectionnés pour vous donner un contrôle plus précis sur ce qui se passe dans votre jeu. Ici, vous pouvez voir exactement quels sont ces événements: La gauche, droit et milieu Les événements de bouton (qu'ils soient normaux, enfoncés ou relâchés ) fonctionnent tous sur le masque de l'instance qui contient l'événement. Cela signifie que GameMaker Studio 2 vérifiera la position de la souris dans la pièce lorsque ces boutons sont utilisés par rapport aux masques de collision des instances qui ont un événement de souris. S'il y a une "collision" avec la boîte englobante d' instance, l'événement sera déclenché, alors assurez-vous que toute instance avec ces événements a un sprite avec un masque de collision valide ou que l'objet a un sprite de masque sélectionné dans les propriétés de l'objet. Comme leur nom l'indique, ces événements seront déclenchés une fois lorsque le bouton de la souris choisi est enfoncé ou relâché pour la première fois, ou en continu à chaque étape pendant que le bouton est maintenu. Les événements d'entrée et de sortie de la souris sont également similaires aux événements de bouton en ce sens qu'ils reposent eux aussi sur le masque de l'instance pour fonctionner, mais cette fois ils sont déclenchés lorsque la souris "entre" (touche) pour la première fois dans l'instance ou lorsque la souris " quitte "(arrête de toucher) l'instance. Cependant, ces événements ne sont pas continus et ne sont déclenchés qu'une seule fois pour chaque fois que la souris entre ou sort de l'objet - ils constituent donc une méthode idéale pour créer, par exemple, des boutons qui doivent changer lorsque la souris les survole avant de revenir à normal lorsque la souris est retirée. Enfin, nous avons une autre section sur les événements de la souris qui s'appelle la souris globale. Dans ce sous-menu, vous trouverez une sélection d'événements destinés à enregistrer des événements de souris dans des instances même lorsque la souris n'est pas au-dessus ou même à proximité. Ce sont des événements générés pour toutes les instances et s'il y a des actions ou du code définis pour l'événement spécifié, il sera exécuté, quelle que soit la position de la souris dans la salle de jeux. Veuillez noter que sur les appareils mobiles ou à écran tactile, le bouton gauche de la souris peut également être utilisé pour rechercher une languette sur un écran tactile et le bouton droit de la souris est déclenché par un double tap sur l'écran (ce comportement peut être modifié à l'aide du code). Gestes Cet événement est celui qui sera déclenché par l'utilisateur touchant l'écran (sur mobile) ou cliquant et déplaçant la souris (sur toutes les autres plates-formes). Ces événements sont similaires aux événements de souris, en ce sens que vous avez des versions régulières et des versions globales. Les versions régulières de ces événements ne seront déclenchées que lorsque les touches se produisent sur une instance qui a un sprite (ou un masque) et que les touches se produisent dans sa boîte englobante. Les versions globales de ces événements, cependant, seront déclenchées par l'utilisateur touchant n'importe où sur l'écran. Les événements de geste détectent les éléments suivants: taps - lorsqu'un utilisateur clique / touche et relâche rapidement traîne - lorsqu'un utilisateur touche / clique et le maintient, puis déplace son doigt / curseur flicks - lorsque l'utilisateur bouge et relâche une touche / un clic en un seul mouvement pincements - lorsque l'utilisateur a deux doigts sur l'écran, puis les écarte / les rapproche tourne - lorsque l'utilisateur a deux doigts sur l'écran, puis les fait pivoter autour d'un point Les différents événements contiendront toujours une carte DS appelée "event_data ", qui contiendra un certain nombre de paires clé / valeur avec des données sur la position tactile / clic et le mouvement. Pour plus de détails sur tous les sous-événements disponibles et leur fonctionnement, veuillez consulter la section suivante: L'événement Gesture Autre Il existe un certain nombre d'événements spéciaux à utiliser lors de la création de jeux avec GameMaker Studio 2 et ils sont principalement regroupés sous l'événement Autre et peuvent être sélectionnés dans le menu contextuel des sous-événements qui apparaissent lorsque vous sélectionnez cette option. Voici une image de tous ces autres événements: Pour plus d'informations sur chacun des événements répertoriés dans l'image ci-dessus, veuillez consulter la section suivante: Les autres événements Tirer Cette catégorie d'événements est celle qui régit ce que vous voyez à l'écran lorsque vous exécutez votre jeu, et est divisée en divers événements discrets: Comme vous pouvez le voir, la catégorie d'événements de dessin a plusieurs types d'événements différents. Draw Begin, Draw et Draw End sont les événements de dessin «standard» que vous utiliserez probablement le plus. Par défaut, l'événement principal Draw est toujours appelé pour chaque instance, qu'il ait ou non un sprite, bien que si vous marquez l'instance comme invisible, l'événement ne sera pas déclenché (gardez cela à l'esprit si vous avez une logique de jeu dans l'événement draw d'un objet invisible, car il ne fonctionnera pas). L'événement de dessin principal est également l'endroit où GameMaker Studio 2 dessine par défaut le sprite d'instance lorsqu'il n'y a pas de code ni d'actions dans l'événement (c'est-à-dire que vous ne l'avez pas ajouté dans la liste d'événements de l'objet). Le dessin par défaut utilise le sprite associé à l'instance et le dessinera avec toutes les transformations définies dans le code ou les actions appliquées. Les événements de dessin standard sont dessinés avant les événements de l' interface graphique Draw et entre les événements Pre Draw et Post Draw, ce qui signifie que tout ce qui est dessiné dans cet événement est dessiné sous celui de l' événement Draw GUI, quel que soit le calque (c'est-à-dire: tout ce qui est dessiné dans L'événement Draw GUI sera toujours dessiné sur tout ce qui est dessiné dans l'événement Draw normal, quel que soit l'ordre des calques). Notez que ce qui précède n'est qu'un aperçu du fonctionnement des événements de dessin, mais pour plus de détails sur tous les sous-événements disponibles, veuillez consulter la section suivante: L'événement Draw Asynchrone Cette catégorie d'événements a la particularité que les événements qu'elle contient ne sont pas déclenchés par défaut par GameMaker Studio 2, mais plutôt à la fin d'une autre action, comme le chargement d'un fichier ou la réponse d'un serveur Web. La catégorie est divisée en les événements suivants: Supposons donc que vous souhaitiez ajouter un fichier image à GameMaker Studio 2. Eh bien, vous coderiez cela dans un autre événement (peut-être l'événement de création) d'un objet, puis demandez à cet objet de dessiner une barre de chargement en attendant (par exemple), en interrogeant l'événement asynchrone approprié jusqu'au rappel qui indique à GameMaker Studio 2 le fichier a chargé. Vous pouvez ensuite utiliser les données renvoyées dans cet événement pour faire d'autres choses, comme changer de salle ou acheter un article. Notez que ce qui précède est simplement un aperçu du fonctionnement de l'événement asynchrone, mais pour plus de détails sur tous les sous-événements disponibles, veuillez consulter la section suivante: Liste des événements asynchrones Vous devez également noter que vous pouvez nommer les événements, ou au moins leur donner un court texte descriptif qui sera affiché à côté d'eux dans l'éditeur d'événements. Pour ce faire, ajoutez simplement ce qui suit dans la toute première ligne de l'éditeur de code de l'événement:/// @description Your text here Ainsi, vous pourriez avoir quelque chose comme ça dans - par exemple - un événement d' alarme/// @description This is the AI Fight alarm Et maintenant, dans votre éditeur d'événements, vous verrez ceci: Pour les DnD™, l'ajout d'un commentaire nécessite l'utilisation de l' action Exécuter le code, qui doit être placée tout en haut des actions de l'événement, avant tout le reste. Lorsque vous ajoutez cette action, vous lui donnez ensuite la même ligne de code que celle indiquée ci-dessus pour nommer l'événement, par exemple: Pour plus d'informations sur certains des événements ci-dessus et l'ordre de déroulement général des événements, veuillez consulter les sections suivantes: Ordre des événements Les autres événements Les événements de tirage au sort Les événements Async Les événements gestuels  Retour: l' éditeur d'objets Suivant: Objets parents © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

