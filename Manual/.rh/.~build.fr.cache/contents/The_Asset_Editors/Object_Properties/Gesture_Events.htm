 Les événements gestuels Les événements de la catégorie Événement GameMaker Studio 2 détecte un «geste» de la souris ou un événement d'écran tactile (alors que ces événements gestuels sont conçus spécifiquement pour une utilisation mobile, ils peuvent également être utilisés sur d'autres cibles pour détecter la souris., bien qu'ils ne détectent pas plusieurs touches dans ce cas). Le but du système gestuel est d'essayer de reconnaître les entrées à un niveau plus élevé que les fonctions de lecture directe souris / tactile, et est conçu pour simplifier la mise en œuvre des entrées couramment utilisées sur les appareils tactiles. REMARQUE: ces événements ne seront pas déclenchés sur la plate-forme HTML5 en raison du manque de prise en charge du multi-touch en utilisant ces événements sur cette plate-forme. Si vous recherchez des gestes sur cette cible, vous devez utiliser les fonctions de l'appareil. Vous pouvez choisir de détecter les gestes d' instance ou les gestes globaux, où les événements de geste d'instance ne seront déclenchés que lorsque le toucher / clic initial est sur une instance dans la pièce. Notez que l'instance doit avoir un masque de collision valide (voir les sections Éditeur de sprite - Masque de collision et Éditeur d'objets - Masque de collision pour plus de détails) pour que cet événement soit déclenché. Les événements globaux, cependant, seront déclenchés en touchant / cliquant n'importe où dans la salle de jeu, et pour toutes les instances qui ont l'événement. Lorsqu'un geste est reconnu, il déclenchera un ou plusieurs des événements disponibles, et l'événement déclenché dépendra du type de geste qui a été détecté. Dans tous les cas, cependant, une carte DS sera générée pour vous et stockée dans la variable intégrée event_data. Les clés disponibles dépendent du type d'événement par lequel il a été créé et sont affichées dans chacune des sous-sections ci-dessous. REMARQUE: la variable event_data n'est valable que dans ces événements, car la carte DS vers laquelle elle pointe est automatiquement créée au début de l'événement, puis détruite à nouveau à la fin, cette variable étant réinitialisée à la valeur -1 à tous les autres moments. Il est intéressant de noter que si vous avez plusieurs instances sous la position d' être touché et ils ont tous un événement geste, alors tous les déclenchera, non seulement l'instance « supérieure ». Notez également que lorsque vous utilisez plusieurs vues de caméra et faites glisser une instance, les valeurs renvoyées seront basées sur la vue dans laquelle vous étiez lorsque le toucher / clic initial a été reçu - cela est vrai pour tous les événements ultérieurs de ce geste pour cette instance. Ainsi, toucher et faire glisser une instance dans une vue, puis relâcher le toucher dans une autre vue, renverra des valeurs relatives à la vue initiale où le geste a été détecté pour la première fois. Événements Tap, Drag et Flick Les événements "Tap", "Drag" et "Flick" sont tous basés sur une simple pression ou un clic de souris sur l'écran et le event_data DS Map contiendra les clés suivantes: Clé Description "gesture " Il s'agit d'une valeur d'identifiant unique au geste en cours de lecture. Cela vous permet de lier les différentes parties de gestes en plusieurs parties (comme faire glisser le début, faire glisser et faire glisser la fin) ensemble. "touch " Il s'agit de l'index du toucher utilisé pour le geste. En général, cela commencera à 0 et augmentera pour chaque doigt maintenu enfoncé, puis reviendra à 0 lorsque tous les doigts sont retirés, mais si l'utilisateur touche l'écran ailleurs lorsque cet événement est déclenché par une autre touche, alors la valeur sera supérieur à 0. "posX " Il s'agit de la position X de l'espace de la pièce du toucher. "posY " Il s'agit de la position Y de l'espace de la pièce du toucher. "rawposX " Il s'agit de la position X brute de l'espace fenêtre du toucher (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_x() ). "rawposY " Il s'agit de la position Y brute de l'espace fenêtre du toucher (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_y() ). "guiposX " Il s'agit de la position X du gui-space du toucher (équivalent à obtenir la position de la souris en utilisant device_mouse_x_to_gui() ). "guiposY " Il s'agit de la position Y de l'espace graphique du toucher (équivalent à obtenir la position de la souris en utilisant device_mouse_y_to_gui() ). "diffX " Il s'agit de la différence espace-pièce X entre la position du toucher actuel et la position du dernier toucher dans ce geste. "diffY " Il s'agit de la différence Y d'espace-pièce entre la position du toucher actuel et la position du dernier toucher dans ce geste. "rawdiffX " Il s'agit de la différence X brute entre la position du toucher actuel et la position du dernier toucher dans ce geste. "rawdiffY " Il s'agit de la différence Y brute entre la position du toucher actuel et la position du dernier toucher dans ce geste. "guidiffX " Il s'agit de la différence gui-space X entre la position du toucher actuel et la position du dernier toucher dans ce geste. "guidiffY " Il s'agit de la différence Y de l'espace graphique entre la position du toucher actuel et la position du dernier toucher dans ce geste. "viewstartposX " Il s'agit de la position de départ de la pièce X du geste actuel. "viewstartposY " Il s'agit de la position de départ de la pièce Y du geste actuel. "rawstartposX " Il s'agit de la position de départ X brute du geste actuel. "rawstartposY " Il s'agit de la position de départ Y brute du geste actuel. "guistartposX " Il s'agit de la position de départ X du gui-space du geste actuel. "guistartposY " Il s'agit de la position de départ Y de l'espace graphique du geste actuel. "isflick " Uniquement disponible dans l'événement Drag End. Ce paramètre est défini sur 1 si la fin du glissement est détectée comme un petit coup, ce qui signifie que vous n'avez pas besoin d'un événement Flick séparé si vous gérez le glissement quand même. Robinet L'événement Tap sera déclenché lorsqu'une instance a été touchée ou cliquée ou - s'il s'agit d'un événement global - lorsque le jeu enregistre un contact ou un clic n'importe où dans la pièce. Un tap est considéré comme un toucher et un relâchement rapides, et si le toucher dure trop longtemps, il sera considéré comme un glisser (et déclenchera les événements de mouvement de glisser au lieu de l'événement de tap). Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Créer un évènementx_goto = x; y_goto = y; Appuyez sur Événementx_goto = event_data[? "posX"]; y_goto = event_data[? "posY"]; Événement d'étapevar _pd = point_distance(x, y, x_goto, y_goto); move_towards_point(x_goto, y_goto, clamp(_pd, 0, 5); Le code ci-dessus détectera un tap sur l'écran, puis obtiendra la position du tap pour déplacer l'instance vers cette position. Notez que si vous souhaitez avoir un temps de détection de prise plus ou moins long, vous pouvez le régler avec la fonction gesture_drag_time(). Cela définit le temps entre la détection initiale et le tap devenant un glissement, alors réglez-le sur une valeur plus élevée pour allonger la détection du tap ou sur une valeur inférieure pour la raccourcir (la valeur est en secondes et par défaut à 0,16). Tapez deux fois L'événement Double Tap sera déclenché lorsqu'une instance a été touchée ou cliquée deux fois en succession rapide (ou - s'il s'agit d'un événement global - lorsque le jeu enregistre deux touches rapides ou clics n'importe où dans la pièce). Un double tap est considéré comme deux touches et relâchements rapides, mais si l'une des touches dure trop longtemps, elle sera considérée comme un glisser (et déclenchera les événements de mouvement de glisser au lieu de l'événement de double pression). Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Créer un évènementx_goto = x; y_goto = y; Événement Double Tapinstance_destroy(); Le code ci-dessus détecte simplement un double tap, puis détruit l'instance. Notez que vous pouvez régler le temps entre les tapotements pour déclencher un double tap à l'aide de la fonction gesture_double_tap_time() (qui a une valeur par défaut - en secondes - de 0,16) et vous pouvez également définir la distance de détection entre les robinets avec la fonction gesture_double_tap_distance() (si un deuxième tap est détecté en dehors de cette distance, il sera considéré comme un événement de prise régulier). Faites glisser le début L'événement Drag Start sera déclenché lorsque l'utilisateur maintient un toucher ou un clic sans le relâcher. Il sera déclenché une fois lorsqu'un temps défini s'est écoulé après le toucher initial, qui est de 0,16 seconde par défaut (bien que vous puissiez le définir sur n'importe quelle autre valeur en secondes à l'aide de la fonction gesture_drag_time() ). Une fois que cet événement a été déclenché, et tant que l'utilisateur maintient un toucher / clic enfoncé, l'événement Glisser sera déclenché à chaque étape jusqu'à ce que le toucher / clic soit relâché. Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Créer un évènementdrag_offsetX = 0; drag_offsetY = 0; Faites glisser l'événement de débutdrag_offsetX = x - event_data[?"posX"]; drag_offsetY = y - event_data[?"posY"]; Le code ci-dessus utilise l'événement Drag Start pour obtenir la position du toucher / clic et l'utiliser pour définir une valeur de décalage pour les axes x et y. Cela peut ensuite être utilisé lors du glissement de l'instance pour s'assurer qu'elle ne «saute» pas à la position à laquelle le toucher / clic a été détecté (voir l'événement Glisser ci-dessous pour une suite de cet exemple). Glisser L'événement Dragging est déclenché après l'événement Drag Start, et sera déclenché à chaque étape pendant laquelle l'utilisateur maintient le toucher / clic sur l'instance (ou l'écran, s'il s'agit d'un événement global) et se déplace au-delà du seuil de glissement défini. Cette distance est de 0,1 pouce par défaut mais peut être définie à l'aide de la fonctiongesture_drag_distance(). S'il n'y a pas de mouvement ou si le mouvement est sous le seuil défini, l'événement ne sera pas déclenché. Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Créer un évènementdrag_offsetX = 0; drag_offsetY = 0; Faites glisser l'événement de débutdrag_offsetX = x - event_data[?"posX"]; drag_offsetY = y - event_data[?"posY"]; Événement glissantx = event_data[?"posX"] + drag_offsetX; y = event_data[?"posY"] + drag_offsetY; L'exemple de code ci-dessus utilise les variables de décalage définies dans l'événement Drag Start pour déplacer l'instance lorsque l'événement Dragging est déclenché. Faire glisser la fin L'événement Drag End est déclenché lorsque l'utilisateur relâche le toucher / clic sur l'instance (ou l'écran si l'événement est global). Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement, mais dans ce cas, la carte aura une clé supplémentaire: "isflick ". Flick est calculé comme la distance par seconde sur laquelle la traînée s'est produite et la valeur de"isflick "sera true si elle est supérieure à la valeur de distance définie par seconde, ou false dans le cas contraire. Notez que la valeur par défaut est de 2 pouces par seconde, mais vous pouvez la définir sur une autre valeur à l'aide de la fonction gesture_flick_speed(). Notez également qu'il existe un événement Flick dédié qui sera également déclenché si la variable "isflick" est vraie. Un exemple d'utilisation serait: Créer un évènementflickVelX = 0.0; flickVelY = 0.0; Faire glisser l'événement de finisFlick = event_data[?"isflick"]; if (isFlick)     {     flickVelX = event_data[?"diffX"];     flickVelY = event_data[?"diffY"];     } else
             {     flickVelX = 0;     flickVelY = 0;     } Événement d'étapex += flickVelX; y += flickVelY; flickVelX *= 0.7; flickVelY *= 0.7; Le code ci-dessus obtient simplement la différence entre les positions x et y du dernier événement Dragging et de l'événement Drag End actuel, et si le mouvement a été supérieur au seuil de flick, il définit certaines variables qui sont utilisées pour déplacer l'instance dans le événement d'étape. Feuilleter L'événement Flick n'est déclenché que lorsqu'un toucher / clic a été maintenu, déplacé puis relâché et que la distance entre la dernière position de glissement et la position de relâchement est supérieure à 2 pouces par seconde (il s'agit du paramètre par défaut, bien que cela puisse être modifié en utilisant la fonction gesture_flick_speed() ). Cet événement générera un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Créer un évènementflickVelX = 0.0; flickVelY = 0.0; Événement FlickflickVelX = event_data[?"diffX"]; flickVelY = event_data[?"diffY"]; Événement d'étapex += flickVelX; y += flickVelY; flickVelX *= 0.7; flickVelY *= 0.7; Le code ci-dessus obtient simplement la différence de position x et y du dernier événement Dragging et de l'événement Flick actuel, et si le mouvement a été supérieur au seuil de flick, il définit certaines variables qui sont utilisées pour déplacer l'instance dans l'étape un événement. Événements de pincement Les événements «Pinch» sont basés sur deux touches à l'écran des appareils étant reconnus à la fois, où l'un (ou les deux) s'est déplacé de plus d'une certaine distance. L'angle de mouvement des touches avec le mouvement de chaque touche est ce qui déterminera la détection d'un événement de pincement ou de rotation, où (dans le cas du type d'événement de pincement): Si l'une des touches ne bouge pas, l'autre doit se déplacer vers elle ou s'en éloigner dans un angle de seuil (qui peut être réglé à l'aide des fonctions gesture_pinch_angle_towards() et - gesture_pinch_angle_away() ). Si les deux touches se déplacent, leurs vitesses doivent être dans des directions approximativement opposées et la même vérification de seuil angulaire est également effectuée pour s'assurer que les touches se déplacent dans un alignement approximatif. Lorsque deux touches et un mouvement sont détectés avec les critères ci-dessus, un événement de pincement sera déclenché, et dans chacun des événements, le event_data DS Map sera renseigné avec les clés suivantes:Clé Description "gesture" Il s'agit d'une valeur d'identifiant unique au geste en cours de lecture. Cela vous permet de lier les différentes parties de gestes en plusieurs parties (comme faire glisser le début, faire glisser et faire glisser la fin) ensemble. "touch1" Il s'agit de l'index du premier contact utilisé dans le cadre du geste de pincement. En général, ce sera 0, mais si l'utilisateur touche l'écran n'importe où ailleurs lorsque cet événement est déclenché par une autre touche, alors la valeur sera supérieure à 0. "touch2" Il s'agit de l'index du deuxième toucher qui est utilisé dans le cadre du geste de pincement. En général, ce sera 1 de plus que la valeur de touch1, mais peut être une autre valeur en fonction du nombre de touches détectées ailleurs. "posX1" Il s'agit de la position X de l'espace de la pièce du premier contact. "posY1" Il s'agit de la position Y de l'espace de la pièce du premier contact. "rawposX1" Il s'agit de la position X brute de l'espace fenêtre du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_x() ). "rawposY1" Il s'agit de la position Y brute de l'espace fenêtre du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_y() ). "guiposX1" Il s'agit de la position X du gui-space du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_x_to_gui() ). "guiposY1" Il s'agit de la position Y de l'espace graphique de la deuxième touche (équivalent à obtenir la position de la souris en utilisant device_mouse_y_to_gui() ). "posX2" Il s'agit de la position X de l'espace de la pièce de la deuxième touche. "posY2" Il s'agit de la position Y de l'espace de la pièce de la deuxième touche. "rawposX2" Il s'agit de la position X brute de l'espace fenêtre du premier contact. "rawposY2" Il s'agit de la position Y brute de l'espace fenêtre de la seconde touche. "guiposX2" Il s'agit de la position X de l'espace graphique de la deuxième touche. "guiposY2" Il s'agit de la position Y de l'espace graphique de la deuxième touche. "midpointX" La position X du point médian entre les deux touches dans l'espace de la pièce. "midpointY" La position Y du point médian entre les deux touches dans l'espace de la pièce. "rawmidpointX" Il s'agit de la position X brute de l'espace fenêtre du point médian. "rawmidpointY" Il s'agit de la position Y brute de l'espace fenêtre du point médian. "guimidpointX" C'est la position X de l'espace graphique du point médian. "guimidpointY" Il s'agit de la position Y de l'espace graphique du point médian. "relativescale" Il s'agit de la différence d'échelle par rapport au dernier événement de ce geste (donc pour les événements Pinch In, ce sera toujours inférieur à 1,0, alors que pour les événements Pinch Out, il sera toujours supérieur à 1,0) "absolutescale" Il s'agit de l'échelle par rapport à l'endroit où se trouvaient les doigts lorsque le geste a commencé (donc si la distance entre les doigts a diminué de moitié, ce sera 0,5 alors que si la distance a doublé, elle sera de 2,0). Début par pincement L'événement Pinch Start sera déclenché lorsqu'une instance (ou l'écran si l'événement est global) a été touchée par deux "doigts" (et le toucher est maintenu), puis un ou les deux "doigts" sont déplacés. Si les touches s'éloignent l'une de l'autre ou l'une vers l'autre plus que la distance de contrôle minimale (qui est de 0,1 pouce par défaut, mais elle peut être définie à l'aide de la fonction gesture_pinch_distance() ), et l'angle entre eux est compris dans la valeur définie (cette valeur par défaut est de 45 ° mais peut être définie à l'aide de gesture_pinch_angle_towards() et GameMaker _Language / GML _Reference / Game_Input / Gesture_Input / gesture_pinch_angle_away.htm ">gesture_pinch_angle_away() ), puis un événement Pinch Start sera déclenché. Dans ce cas, vous pouvez définir des variables ou enregistrer la date de position pour une utilisation future. Par exemple: Événement de début de pincementpinching = true; pinch_x = event_data[? "midpointX"]; pinch_y = event_data[? "midpointY"]; Le code ci-dessus détectera un pincement et enregistrera la position médiane de ce pincement. Pincer / Pincer Les événements Pinch In et Pinch Out seront déclenchés à chaque étape où la distance entre les deux touches qui composent le pincement change au-dessus du seuil minimum (réglé à +/- 0,1 pouce par défaut, mais vous pouvez le modifier à l'aide de la fonction gesture_pinch_distance). S'il n'y a aucun mouvement des touches de pincement, ces événements ne se déclencheront pas. Ces événements généreront un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Événement global de pincement / pincementvar _scale = event_data[? "relativescale"]; var _w = camera_get_view_width(view_camera[0]); var _h = camera_get_view_height(view_camera[0]); var _x = camera_get_view_x(view_camera[0]) + (_w / 2); var _y = camera_get_view_y(view_camera[0])
        + (_h / 2);
         _w *= _scale; _h = _w * (room_height / room_width); _x -= _w / 2; _y -= _h / 2;
         camera_set_view_pos(view_camera[0], _x, _y); camera_set_view_size(view_camera[0], _w, _h); Le code ci-dessus mettra à l'échelle la vue en fonction de l'échelle relative des touches de pincement. Fin de pincement L'événement Pinch End sera déclenché lorsque l'utilisateur relâche une (ou les deux) des touches de l'appareil. Cet événement va générer un event_data Carte DS que vous pouvez ensuite utiliser pour obtenir des informations sur l'événement. Par exemple: Événement de fin de pincementvar _pinchx = event_data[? "midpointX"]; var _pinchy = event_data[? "midpointY"]; var _w = camera_get_view_width(view_camera[0]); var _h = camera_get_view_height(view_camera[0]); var _x = _pinchx - (_w / 2);        var _y = _pinchy - (_h / 2);
         camera_set_view_pos(view_camera[0], _x, _y); Le code ci-dessus définira la position de la vue centrée sur le milieu des deux touches qui composent le pincement lorsque les touches sont relâchées. Faire pivoter les événements Les événements «Rotation» sont basés sur la reconnaissance simultanée de deux touches sur l'écran des appareils et sur lesquelles il y a eu une rotation angulaire cohérente entre les deux dans un laps de temps spécifique. L'angle de mouvement des touches avec le mouvement de chaque touche est ce qui déterminera la détection d'un événement Pincement ou Rotation, où (dans le cas du type Événement Rotation): Deux touches doivent être maintenues enfoncées pendant une durée minimale spécifiée (la durée par défaut est de 0,16 seconde, mais vous pouvez la modifier à l'aide de la fonction gesture_rotate_time() ). Dans ce laps de temps minimum, ils doivent tourner dans une direction cohérente (si la direction de rotation change dans ce laps de temps, aucune rotation n'est lancée). La quantité de rotation doit dépasser l'angle de seuil minimum (qui est réglé à 5 ° par défaut, mais cela peut être modifié à l'aide de la fonction gesture_rotate_angle() ). Lorsque deux touches et un mouvement sont détectés avec les critères ci-dessus, un événement de rotation sera déclenché, et dans chacun des événements, le event_data DS Map sera renseigné avec les clés suivantes: Clé Description "gesture" Il s'agit d'une valeur d'identifiant unique au geste en cours de lecture. Cela vous permet de lier les différentes parties de gestes en plusieurs parties (comme faire glisser le début, faire glisser et faire glisser la fin) ensemble. "touch1" Il s'agit de l'index du premier contact utilisé dans le cadre du geste de pincement. En général, ce sera 0, mais si l'utilisateur touche l'écran n'importe où ailleurs lorsque cet événement est déclenché par une autre touche, alors la valeur sera supérieure à 0. "touch2" Il s'agit de l'index du deuxième toucher qui est utilisé dans le cadre du geste de pincement. En général, ce sera 1 de plus que la valeur de touch1, mais peut être une autre valeur en fonction du nombre de touches détectées ailleurs. "posX1" Il s'agit de la position X de l'espace de la pièce du premier contact. "posY1" Il s'agit de la position Y de l'espace de la pièce du premier contact. "rawposX1" Il s'agit de la position X brute de l'espace fenêtre du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_x() ). "rawposY1" Il s'agit de la position Y brute de l'espace fenêtre du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_raw_y() ). "guiposX1" Il s'agit de la position X du gui-space du premier contact (équivalent à obtenir la position de la souris en utilisant device_mouse_x_to_gui() ). "guiposY1" Il s'agit de la position Y de l'espace graphique de la deuxième touche (équivalent à obtenir la position de la souris en utilisant device_mouse_y_to_gui() ). "posX2" Il s'agit de la position X de l'espace de la pièce de la deuxième touche. "posY2" Il s'agit de la position Y de l'espace de la pièce de la deuxième touche. "rawposX2" Il s'agit de la position X brute de l'espace fenêtre du premier contact. "rawposY2" Il s'agit de la position Y brute de l'espace fenêtre de la seconde touche. "guiposX2" Il s'agit de la position X de l'espace graphique de la deuxième touche. "guiposY2" Il s'agit de la position Y de l'espace graphique de la deuxième touche. "pivotX" La position X du point de pivot de rotation dans l'espace de la pièce. "pivotY" La position Y du point de pivot de rotation dans l'espace de la pièce. "rawpivotX" Il s'agit de la position X brute de l'espace fenêtre du point de pivot de rotation. "rawpivotY" Il s'agit de la position Y brute de l'espace fenêtre du point de pivot de rotation. "guipivotX" Il s'agit de la position X de l'espace graphique du point de pivot de rotation. "guipivotY" Il s'agit de la position Y de l'espace graphique du point de pivot de rotation. "relativeangle" Il s'agit de la différence de rotation par rapport au dernier événement de ce geste, mesurée en degrés "absoluteangle" Il s'agit de la différence d'angle par rapport à l'endroit où se trouvaient les doigts lorsque le geste a commencé, mesurée en degrés. Ainsi, par exemple, si les doigts ont tourné d'un quart de cercle depuis le début du geste alors cette valeur sera de 90 ° ou -90 °, selon le sens de rotation. Rotation de départ L'événement Rotate Start sera déclenché lorsqu'une instance (ou l'écran si l'événement est global) a été touchée par deux "doigts" (et le toucher est maintenu), puis un ou les deux "doigts" sont tournés depuis son début positionner. La rotation des touches doit avoir commencé dans un court laps de temps (0,16 seconde par défaut, mais elle peut être réglée à l'aide de la fonction gesture_rotate_time() ) et être supérieur au seuil angulaire minimum (par défaut 5 °, mais cela peut être modifié à l'aide de la fonction gesture_rotate_angle() ). Si ces vérifications sont vraies, un événement Rotate Start sera déclenché et vous pourrez l'utiliser pour stocker des valeurs ou définir des variables à utiliser avec le reste des événements de rotation. Par exemple: Créer un évènementrotating = false; view_a = camera_get_view_angle(view_camera[0]); Faire pivoter l'événement de débutrotating = true; Le code ci-dessus configure simplement certaines variables pour faire pivoter la caméra de vue, puis dans l'événement Rotate Start, il définit l'une d'entre elles sur true. Tournant L'événement Rotation sera déclenché à chaque pas que les touches sur l'écran tournent l'une autour de l'autre, tant que le mouvement est supérieur au seuil angulaire minimum (par défaut 5 °, mais cela peut être modifié à l'aide de la fonction gesture_rotate_angle() ). Cet événement peut être utilisé pour définir des variables et manipuler des instances, par exemple: Événement tournantvar _relangle = event_data[?"relativeangle"]; var _a = camera_get_view_angle(view_camera[0]); _a += _relangle; camera_set_view_angle(view_camera[0], _a); Le code ci-dessus fait pivoter la vue de la caméra en fonction du mouvement de rotation des touches dans l'événement. Faire pivoter la fin L'événement Rotate End sera déclenché lorsqu'une (ou les deux) touches qui composent le geste sont libérées de l'écran de l'appareil. Cet événement peut être utilisé pour définir des variables et manipuler des instances, par exemple: Faire pivoter l'événement de finrotating = false; Événement d'étapeif !rotating     {     var _a = camera_get_view_angle(view_camera[0]);     var _adif = angle_difference(view_a, _a);     _a += median(-5, _adif, 5);     camera_set_view_angle(view_camera[0], _a);     } Le code ci-dessus utilise l'événement Rotate End pour détecter le moment où l'utilisateur arrête le geste, puis définit une variable. Cette variable est ensuite utilisée dans l'événement d'étape pour faire pivoter la caméra de vue vers sa position d'origine.  Retour: Evénements d'objets Suivant: Ordre des événements © Copyright YoYo Games Ltd. 2021 Tous droits réservés
  
  
  

