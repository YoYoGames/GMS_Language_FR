<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Opérateurs au niveau du bit</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page qui explique le fonctionnement des opérateurs au niveau du bit" />
  <meta name="rh-index-keywords" content="Opérateurs au niveau du bit" />
  <meta name="search-keywords" content="bit à bit,opérateurs au niveau du bit" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Opérateurs binaires et binaires</h1><p> Au début de l&#39;ère informatique, le <strong>binaire</strong> et l&#39; <strong>hex</strong> (hexadécimal) étaient un mode de vie, probablement parce que les langages de haut niveau (comme BASIC) étaient tout simplement trop lents à fonctionner. Par exemple, la multiplication de 32 x 32 aurait pu prendre plusieurs cycles de processeur pour obtenir l&#39;utilisation de BASIC, mais avec le binaire, cela se fait en une seule opération dans un seul cycle de processeur.</p><p> De nos jours, cependant, avec la puissance même d&#39;un PC de base, vous n&#39;avez plus à vous en soucier et vous pouvez faire les choses sur le &quot;long chemin&quot;, car la vitesse de la machine et la construction de son processeur plus complexe compenseront tout court vient cette approche a. C&#39;est une excellente nouvelle bien sûr, car cela signifie que vous n&#39;avez plus besoin d&#39;optimiser chaque ligne de code que vous écrivez, mais si tel est le cas, devriez-vous vraiment vous soucier du binaire?</p><p> La réponse est définitivement &quot;oui, vous devriez&quot;. Bien qu&#39;il soit vrai que vous pouvez toujours obtenir des accélérations - et parfois celles-ci peuvent être importantes - l&#39;utilisation de binaire et hexadécimal permet de mieux comprendre le fonctionnement du processeur et peut également conduire à écrire un meilleur code, à mieux emballer les données et à rendre certaines tâches beaucoup plus simples. Cette page va expliquer un peu ce qu&#39;est le binaire ainsi que comment il peut être utilisé lors de la création de vos jeux.</p><p> Examinons donc d&#39;abord la théorie binaire la plus élémentaire - comment les nombres sont créés. Jetez un œil à ce tableau:</p><p class="code">000 = 0<br/> 001 = 1<br/> 010 = 2<br/> 100 = 4</p><p> Chaque 1 ou 0 représente un seul <a class="glossterm" data-glossterm="bit" href="#">bit</a> de données, et comme vous pouvez le voir, cela signifie qu&#39;en binaire, 10 équivaut à 2! Chaque bit est 2 fois la valeur précédente, le premier bit étant égal à 1. Donc, bit 2 = 2, bit 3 = 4, bit 4 = 8 et ainsi de suite (comme indiqué ci-dessous dans ce tableau d&#39; <a class="glossterm" data-glossterm="octet" href="#">octets):</a></p><p class="code">00000001 = 1<br/> 00000010 = 2<br/> 00000100 = 4<br/> 00001000 = 8<br/> 00010000 = 16<br/> 00100000 = 32<br/> 01000000 = 64<br/> 10000000 = 128</p><p> C&#39;est bien si vous voulez des nombres d&#39;une puissance de 2, mais comment pouvons-nous créer des nombres plus complexes? Eh bien, un seul nombre binaire ne peut stocker qu&#39;un 0 ou un 1, et c&#39;est tout, donc pour les nombres plus complexes, nous devons ajouter des bits ensemble. Si par exemple nous voulions faire 6, nous ajouterions 4 et 2 ensemble ainsi.</p><p class="code">00000010 = 2<br/> 00000100 = 4<br/> 00000110 = 6</p><p> Cela est vrai de <strong>tous</strong> les nombres binaires et de la façon dont l&#39;ordinateur compose n&#39;importe quel nombre en interne. Prenons un nombre légèrement plus compliqué comme autre exemple: 23. Le nombre 23 est en fait composé de <span class="inline">1+2+4+16</span> ou <span class="inline">00010111</span>. Que diriez-vous d&#39;un exemple beaucoup plus complexe: 196? Eh bien, c&#39;est fait de <span class="inline">128+64+4</span> ou <span class="inline">11000100</span>. Donc en fait, ce n&#39;est pas si complexe que ça!</p><p> Si nous commençons à faire des valeurs en dehors de la plage d&#39;un octet (qui peut stocker des nombres de 0 à 255), cela commence à devenir un peu plus difficile à suivre, cependant. Par exemple, 217361 est <span class="inline">110101000100010001</span> en binaire. Ou, <span class="inline">1+16+256+etc...</span> Les règles sont les mêmes quelle que soit la valeur exprimée - chaque nombre est créé en ajoutant plusieurs bits ensemble.</p><p> Maintenant, comment effectuer des opérations mathématiques sur ces valeurs? Disons que vous voulez stocker <span class="inline">true</span> ou <span class="inline">false</span> comme valeur. Habituellement, les compilateurs utilisent un <span class="inline">INT</span> (un <span
      class="inline">INT</span> est généralement défini comme un nombre 32 bits signé - signé signifie simplement qu&#39;il peut avoir une valeur positive ou négative, tandis que non signé signifie qu&#39;il ne peut être que positif), puis attribuez-le simplement à <span class="inline">0</span> ou <span class="inline">1</span>. N&#39;ayant que 2 états, un <span class="inline">true</span> / <span class="inline">false</span> la valeur est idéale pour stocker un peu, et si nous faisions cela, nous pourrions stocker 32 <span class="inline">true</span> / <span class="inline">false</span> bits pour chacun <span class="inline">INT</span> plutôt qu&#39;un seul, puisqu&#39;un <span class="inline">INT</span> est composé de 32 bits.</p><p> Comment ferions-nous cela? Eh bien, assez facilement, il s&#39;avère:</p><p class="code">flags = flags | 1;</p><p> Le &quot;<span class="inline">|</span> &quot;l&#39;opérateur est un bit à bit <span class="inline">OR</span>, et cela signifie l&#39;instruction ci-dessus <span class="inline">ORs</span> 1 dans la valeur contenue dans la variable <span class="inline">flags</span>. Si vous vous souvenez de plus tôt, l&#39;utilisation d&#39;un 1 définira le premier bit. Si nous voulions définir le deuxième bit, nous le ferions:</p><p class="code">flags = flags | 2;</p><p> Nous <span class="inline">OR</span> en 2, car le motif binaire <span class="inline">00000010</span> est égal à 2. Alors, que fait exactement le binaire <span class="inline">OR</span> opérateur faire? Eh bien, il fusionne tous les bits ensemble en une seule valeur, comme ceci:</p><p class="code">010110100 // Value 1<br/> 110011001 // value 2<br/> 110111101 // Value 1 OR Value 2</p><p> Voici ce que l&#39;on appelle une <a class="glossterm" data-glossterm="table de vérité" href="#">table de vérité</a> pour l&#39;opérateur OR:</p><p class="code">00 | 00 = 00<br/> 00 | 01 = 01<br/> 01 | 01 = 01<br/> 01 | 00 = 01</p><p> Donc, là où il y a une valeur avec 2 zéros, elle restera zéro. L&#39;avantage d&#39;utiliser des bits comme celui-ci comme <span class="inline">true</span> /<span class="inline">false</span> état, est-ce que vous pouvez définir plusieurs bits comme &quot;indicateurs&quot; en une seule opération, ce que vous ne pouvez tout simplement pas faire avec une valeur booléenne normale. Par exemple, disons que le bit 1 est un indicateur &quot;actif&quot; et le bit 3 est un indicateur &quot;visible&quot;. Nous pourrions définir les deux en faisant ceci:</p><p class="code">flags = flags | 5<span class="inline"></span>;</p><p> C&#39;est parce que 5 est <span class="inline">00000101</span> en binaire, et suivant la règle ci-dessus, la variable &quot;flags&quot; obtiendra ces deux bits fusionnés avec les siens. Ainsi, même si le bit 1 était déjà défini, l&#39;opération fonctionne toujours et le bit 3 sera désormais également défini.</p><p> Qu&#39;en est-il de la compensation des drapeaux? Eh bien, c&#39;est là que le bit &quot;<span class="inline">&amp;</span> &quot;<span class="inline">AND</span> l&#39;opération entre en jeu. Lorsque vous <span class="inline">AND</span> quelque chose, les bits qui sont définis dans le masque sont conservés, tandis que les bits qui sont clairs dans le masque sont supprimés - comme ceci:</p><p class="code">01110010101 // Value 1<br/> 00110000100 // Value 2<br/> 00110000100 // Value 1 AND value 2</p><p> Comme vous pouvez le voir, là où il y a un 1 dans chaque valeur, le 1 est conservé, et là où il y a un mélange ou des 0 et des 1, ils sont remis à 0. Voici la table de vérité pour <span class="inline">AND</span> ing:</p><p class="code">00 &amp; 00 = 00<br/> 01 &amp; 00 = 00<br/> 00 &amp; 01 = 00<br/> 01 &amp; 01 = 01</p><p> Donc, ce n&#39;est que lorsqu&#39;il y en a un peu à chaque endroit qu&#39;il sera conservé. Cela signifie que tout comme vous pouvez définir plusieurs indicateurs à la fois, vous pouvez également effacer plusieurs indicateurs à la fois. Par exemple, prenons le cas ci-dessus, mais cette fois clarifiez-les. Nous voulons effacer les bits 1 et 3 (nous donnant la valeur 5), mais en nous souvenant de la table de vérité ci-dessus, ce que nous voulons faire est de conserver tous les autres bits et d&#39;effacer les bits 1 et 3. Ce serait un masque binaire &quot; &quot;sur 11111111111111111111111111111010 (32 bits). Ce masque conserve tous les bits actuellement définis, mais efface les deux bits que nous voulons effacer. Donc, si j&#39;avais une valeur de 1000111011 et que je voulais effacer les bits 1 et 3 en utilisant le masque ci-dessus, cela finirait comme ça...</p><p class="code">00000000000000000000001000111011 // Value<br/> 11111111111111111111111111111010 // Mask<br/> 00000000000000000000001000111010 // Value AND Mask</p><p> C&#39;est génial, mais si nous devions résoudre ce problème à chaque fois que nous devions effacer les drapeaux, cela deviendrait ennuyeux. Ce dont nous avons besoin, c&#39;est d&#39;un moyen de retourner les bits facilement (et de préférence sans coût CPU). Heureusement, il existe un moyen simple de le faire en utilisant le &quot; <span class="inline">~</span> &quot; <span class="inline">NOT</span> opérateur.</p><p> le <span class="inline">NOT</span> l&#39;opérateur est juste ce qu&#39;il dit - <em>pas</em> ces bits. Voici une table de vérité pour <span class="inline">NOT</span>.</p><p class="code">~00 = 11<br/> ~01 = 10<br/> ~10 = 01<br/> ~11 = 00</p><p> Cet opérateur rend la suppression des drapeaux très simple, et mieux encore, c&#39;est généralement une optimisation du temps de compilation, ce qui signifie que si vous utilisez un nombre constant (c&#39;est-à-dire pas une variable), le compilateur retournera automatiquement les bits pour vous. Prenez cette instruction où nous voulons effacer à nouveau les bits 1 et 3:</p><p class="code">a = a &amp; ~5;</p><p> Ce sera en fait compilé à seulement &quot;<span class="inline">a &amp; 11111111111111111111111111111010</span> &quot;. Cela rend la vie assez simple en termes de compensation des drapeaux.</p><p> Le dernier opérateur que nous voulons examiner est &quot;<span class="inline">^</span> &quot; <span class="inline">EOR</span> (<span class="inline">Exclusive OR</span>, appelé quelques fois <span class="inline">XOR</span> ), cet opérateur retourne les bits définis dans les deux valeurs. Ici se trouve le <span class="inline">EOR</span> table de vérité:</p><p class="code">0 ^ 0 = 0<br/> 0 ^ 1 = 1<br/> 1 ^ 0 = 1<br/> 1 ^ 1 = 0</p><p> Ceci est curieux, mais incroyablement utile. Par exemple, disons que nous voulons un compteur qui compte simplement de 0 à 1 et de retour à 0 (basculement entre 0 et 1), nous pourrions en ajouter un et faire un <span class="inline">IF</span> pour voir s&#39;il est arrivé à 2, puis le réinitialiser à 1. Ou... nous pourrions ajouter 1 et ensuite <span class="inline">AND</span> avec 1 (depuis <span class="inline">01+01 = 10</span>, et <span class="inline">10 &amp; 01 = 0</span> ) ou nous pouvons le faire:</p><p class="code">a = a ^ 1;</p><p> Ce que cela fait la première fois qu&#39;il est exécuté est <span class="inline">0 ^ 1 = 1</span>, puis la deuxième fois <span class="inline">1 ^ 1 = 0</span>, basculant ainsi les choses dans les deux sens de 0 à 1.</p><p> Alors - <span class="inline">OR</span> (<span class="inline">|</span> ), <span class="inline">AND</span> (<span class="inline">&amp;</span> ), <span class="inline">NOT</span> (<span class="inline">~</span> ) et <span class="inline">EOR</span> (<span class="inline">^</span> ) manipulons les bits avec une relative facilité, nous permettant, au niveau le plus simple, de contrôler plusieurs bits à la fois. Nous pouvons évidemment utiliser ces opérations pour d&#39;autres choses lors du développement de nos jeux, comme masquer des sprites, faire des entiers <span class="inline">MOD</span> opérations (utilisation <span class="inline">AND</span> ) ou faire de jolis compteurs en boucle.</p><p> Donc, nous pouvons faire simplement des opérations au niveau du bit, mais regardons les choses plus complexes, en commençant par la question, comment un ordinateur ajoute-t-il? Regardons un exemple très simple: <span class="inline">1+1</span>.</p><p class="code">00000001<br/> 00000001
    <br/> 00000010
  </p><p> Tout comme les additions normales, nous ajoutons des nombres ensemble puis nous débordons dans la colonne suivante, mais contrairement à une addition décimale normale, nous ne pouvons aller que de 0 à 1, pas de 0 à 9. Donc, ajouter un <span class="inline">1+1</span> signifie que nous débordons dans <span class="inline">10</span>. Alors regardons un exemple plus complexe.</p><p class="code">01011011 = 91<br/> 00101101 = 45<br/> 10001000 = 136</p><p> C&#39;est évidemment plus difficile à voir ici, mais les débordements ondulent jusqu&#39;à ce qu&#39;il n&#39;y en ait plus dans une colonne. Il est à noter que les ordinateurs ne peuvent ajouter (ou soustraire, multiplier ou diviser) que 2 nombres à la fois. Prendre <span class="inline">19 + 19 + 19</span>. Étant humain, nous pouvons additionner tous les 9 ensemble, porter le 2 et puis c&#39;est parti! Mais les ordinateurs ne peuvent pas faire cela - ce qu&#39;ils peuvent faire, c&#39;est ceci:<span class="inline"> (19 + 19) + 19</span>. Ils feront donc chaque calcul par blocs de 2.</p><p> Les calculs binaires qui nous intéressent le plus en tant que programmeurs sont la multiplication et la division. Les ordinateurs ne se multiplient que par 2, et pour en faire plus, cela divisera un nombre, puis additionnera tous les résultats ensemble. Prenons d&#39;abord quelques exemples très simples. <span class="inline">4 * 2 = 8</span>. Maintenant, pour multiplier par 2 en binaire, on <em>décale</em> tous les bits vers la GAUCHE par un. Comme ça:</p><p class="code">00000100 * 2 = 00001000 = 8</p><p> Tous les bits dans ce cas se sont déplacés de un vers la gauche, le faisant passer du 3ème bit au 4ème et en changeant la valeur de 4 à 8. Que diriez-vous d&#39;un plus grand nombre?</p><p class="code">101 = 01100101 * 2 = 11001010 = 202</p><p> Encore une fois, tous les bits se déplacent sur un, et cela se multiplie par 2. Alors, que diriez-vous d&#39;un multiple de 4? Facile, on décale tout à gauche par 2, plutôt que par un. Alors qu&#39;en est-il de 16 ou 128? Cela nécessiterait un décalage vers la gauche de 4 bits ou 7 bits respectivement. C&#39;est incroyablement utile; cela signifie que nous pouvons faire de simples multiplications en déplaçant simplement des bits. Pour ce faire, nous utilisons l&#39;opérateur de <strong>décalage gauche</strong> <span class="inline">&lt;&lt;</span>. Voici quelques exemples:</p><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br/> 00000001 &lt;&lt; 2 = 000000100 = 4<br/> 00000001 &lt;&lt; 3 = 000001000 = 8<br/> 00000001 &lt;&lt; 4 = 000010000 = 16<br/> 00000001 &lt;&lt; 5 = 000100000 = 32<br/> 00000001 &lt;&lt; 6 = 001000000 = 64<br/>    00000001 &lt;&lt; 7 = 010000000 = 128<br/> 00000001 &lt;&lt; 8 = 100000000 = 256</p><p> Maintenant, en plus d&#39;être très utile pour les multiplications rapides / simples, il est également très utile pour définir des bits spécifiques, sans avoir à déterminer la valeur du bit. Disons que nous voulions régler le bit 27, de quel numéro s&#39;agit-il? (67108864 au fait!), Eh bien, nous pouvons utiliser la syntaxe ci-dessus pour définir facilement des indicateurs comme celui-ci:</p><p class="code">a = a | (1 &lt;&lt; 27)</p><p> D&#39;accord... donc en fait, ce serait le bit 26 de la façon dont nous avons décrit les choses jusqu&#39;à présent (car les bits ont commencé à un), mais en fait... les bits commencent au bit 0 et vont vers le haut, pas au bit 1 Ainsi, alors qu&#39;il y a 32 bits dans un INTEGER, les bits vont de 0 à 31, et non de 1 à 32. C&#39;est en fait assez utile, car nous pouvons maintenant configurer des constantes pour les nombres de bits.</p><p> Disons que le bit 27 est un indicateur actif et le bit 0 est un indicateur explosif. Comment pouvons-nous définir les deux?</p><p class="code">ACTIVE = 27;<br/> BOOM = 0;<br/> A = A | (1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM);</p><p> Cela peut ressembler à beaucoup de code, mais si ces nombres sont des constantes, le compilateur précompilera ces opérations en une seule valeur afin que nous finissions avec cela comme du code réel.</p><p class="code">A = A | 13421772;</p><p> Effacer ces bits (comme nous l&#39;avons vu ci-dessus) consiste simplement à utiliser le modificateur NOT, comme ceci:</p><p class="code">A = A &amp; ~((1 &lt;&lt; ACTIVE) | (1 &lt;&lt; BOOM));</p><p> Cela nous permet donc de définir et d&#39;effacer tous les bits que nous souhaitons, et cela nous permet également de compresser massivement les structures de données. La compression des structures de données est une bonne chose, car si vous utilisez moins de mémoire, vous obtenez moins d&#39;erreurs de cache et votre code s&#39;exécute plus rapidement. En d&#39;autres termes, qu&#39;est-ce qui est plus rapide, copier 32 Mo ou des données, ou 4 Mo? Eh bien, très clairement 4 est. Donc, si vous pouvez regrouper tous vos drapeaux en un seul accès mémoire, c&#39;est bien!</p><p> Voyons maintenant comment vous faites la division et pourquoi cela sera si utile. La division se fait en décalant les bits vers la <em>droite</em> à l&#39;aide de l&#39;opérateur de <strong>décalage droit</strong> <span class="inline">&gt;&gt;</span>. Prenons un simple nombre - 64 - et divisons-le par 32:</p><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010</p><p> Donc là, vous décalez le bit unique de 5 (qui est le nombre de décalages requis pour 32 - regardez ci-dessus), ce qui nous donne 2. Mais que se passe-t-il s&#39;il y a d&#39;autres bits là-dedans? Jetons un coup d&#39;oeil:</p><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010</p><p> Alors voilà…. C&#39;est exactement la même chose. Les bits que nous décrochons sont simplement perdus. C&#39;est en fait très utile, car lors de la division si nous avons besoin du reste, il existe un moyen encore plus simple de l&#39;obtenir, auquel nous reviendrons dans un instant. Mais d&#39;abord, prenons un exemple pratique. J&#39;ai une position X et Y, et je veux obtenir la cellule de grille dans laquelle se trouve, où la grille mesure 32x32. Cette méthode permet de stocker des objets, des collisions, des drapeaux - toutes sortes de choses, et d&#39;y accéder très rapidement. Alors on y va:</p><p class="code">var X_index = x &gt;&gt; 5;<br/> var Y_index = y &gt;&gt; 5;<br/> cell_data = mygrid[# X_index,Y_index];</p><p> Alors, et si nous voulions le reste? Peut-être que ce reste est utilisé comme une sorte d&#39;indicateur d&#39;ordre ou quelque chose comme ça. Quelle que soit la raison, obtenir un reste est aussi simple que de faire un <span class="inline">AND</span>:</p><p class="code">var remainder = x &amp; 31<br/> var X_Index = x &gt;&gt; 5;</p><p> Maintenant, vous avez peut-être remarqué que nous avons utilisé plusieurs lignes de code ici (comme c&#39;est souvent le cas), mais ce n&#39;est encore que quelques instructions très rapides. Mais pourquoi le 31? Eh bien, comme le bit 5 est 32, alors tous les bits ci-dessous seraient 31, et c&#39;est le reste maximum, c&#39;est ce que nous <span class="inline">AND</span> avec (on pourrait aussi utiliser <span class="inline">(1 &lt;&lt; 5) - 1</span> ce qui ferait <span class="inline">32 - 1 = 31</span> ). Maintenant, si je devais faire cela sans comprendre le binaire, cela ressemblerait à ceci:</p><p class="code">var r = x mod 32;<br/> var X_Index = floor(x / 32);</p><p> Alors pourquoi est-ce bien pire? Eh bien, pour diviser par 32, nous devons exécuter une division en virgule flottante - ce qui prend évidemment du temps, mais pour faire le <span class="inline">mod 32</span>, vous devez en faire un autre! Si nous faisions cela en assembleur, nous obtenons en fait LES DEUX valeurs dans une division, mais vous n&#39;obtenez pas cela dans des langages de haut niveau (enfin... pas très souvent), et vous devez donc faire tout le travail deux fois. Cela s&#39;additionne, surtout si vous faites une boucle serrée avec beaucoup de calculs comme celui-ci. Les divisions entières en utilisant le décalage de bits comme indiqué ci-dessus aident vraiment à optimiser votre jeu.</p><p> Comme cela peut être un concept assez complexe à appréhender puis à appliquer à des situations de programmation réelles, vous pouvez trouver ci-dessous une série de courts exemples qui pourraient être appliqués à n&#39;importe quel jeu réalisé avec <span class="notranslate">GameMaker Studio 2</span>.</p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Alignement des tuiles</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> <span class="notranslate">GameMaker Studio 2</span> utilisent souvent la fonction <span class="inline">place_free()</span>, puis lorsqu&#39;une collision est trouvée, essayez de déplacer lentement l&#39;objet en faisant une boucle autour d&#39;un <span class="inline">x</span> ou <span class="inline">y</span> position tout en continuant à exécuter cette fonction, ou en utilisant le <span class="inline">move_outside_all()</span> une fonction.</p><p class="dropspot"> Alors, quel est le moyen le plus rapide de le faire? Eh bien, si nous utilisons des tuiles de puissance de 2 appropriées, nous avons une méthode très simple qui est également ultra-rapide. Si nous nous déplaçons à droite et que nous sommes passés dans un bloc de collision, alors comme nous savons que tout est aligné sur 32, nous devons également aligner le sprite sur une limite de 32 pixels - de préférence celle de gauche - donc le sprite est sorti de la collision. C&#39;est vraiment facile, connaissant les règles que nous avons utilisées ci-dessus pour obtenir le reste, et sachant comment obtenir l&#39;inverse des bits, nous pouvons simplement faire ceci:<br/></p><p class="code">x = x &amp; ~31;</p><p class="dropspot"> C&#39;est vrai, c&#39;est TOUT ce qu&#39;il faut pour s&#39;aligner sur une limite de 32 pixels. En changeant le 31, nous pouvons nous aligner sur tout ce que nous voulons - tant que c&#39;est une puissance de 2. (C&#39;est l&#39;équivalent de diviser par 32, puis de multiplier par 32, supprimant ainsi les bits inférieurs.)</p><p class="dropspot"> Si nous voulions nous aligner à droite, nous ferions ce qui précède, mais en ajouterions 32 pour le déplacer dans la tuile suivante. Simple. Tout cela accélère considérablement le code de collision et vous permet de passer le temps du processeur là où vous en avez vraiment besoin.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Clés et portes</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> Disons que vous avez un niveau avec quelques portes et une clé pour chacune. Comment pouvez-vous facilement marquer une clé pour une porte spécifique? Eh bien, normalement, vous attribueriez simplement une pièce d&#39;identité à la clé et à la porte. Et si vous vouliez une clé pour ouvrir 2 ou 3 portes? Facile. Vous utilisez un MASQUE. La porte aurait un seul bit attribué comme ceci:<br/><br/></p><p class="code">door_id = 1; // 0001<br/></p><p class="dropspot"> Les autres seraient quelque chose comme:<br/><br/></p><p class="code">door_id=2; // 0010<br/>door_id=4; // 0100<br/>door_id=8; // 1000<br/>etc...<br/></p><p class="dropspot"> Si nous voulions que la clé ouvre les portes 1 et 3, alors la clé aurait la valeur MASK de 5 (qui est 101 en binaire). Si nous effectuons un <span class="inline">AND</span> de cela, et il sort &quot;pas zéro&quot;, alors nous savons que la clé peut ouvrir la porte. Vous pouvez également avoir des clés qui n&#39;ouvrent rien en ayant un MASQUE de 0. Voir le code ci-dessous pour la vérification réelle:</p><p class="code">if ((key_id &amp; door_id) ! = 0)<br/>    {<br/>    opendoor();<br/>    }<br/></p><p class="dropspot"><br/></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Compteurs en boucle</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"> Disons que nous voulons un compteur d&#39;animation simple, allant de 0 à 15 (car nous avons 16 images d&#39;animation). Normalement, vous feriez un incrément, puis un <span class="inline">if</span> check pour envelopper le nombre, mais pour cet exemple, utilisons l&#39;opérateur <tt><span class="notranslate">AND(&amp;)</span></tt></p><p class="code">counter = (counter + 1) &amp; 15;</p><p class="dropspot"> Puisque 16 est une puissance de 2, nous pouvons réduire ce nombre de 1 et l&#39;utiliser comme masque, que nous pouvons ensuite utiliser pour envelopper notre valeur de compteur. Si le compteur passe de 15 à 16, on se retrouve avec un motif de bits <span class="inline">10000</span>, et si nous <span class="inline">AND</span> celui avec 15 (motif binaire <span class="inline">01111</span> ) nous nous retrouvons avec <tt><span class="notranslate">00000</span></tt> (simplement zéro). Cela signifie que le code ci-dessus est utile pour encapsuler des valeurs dans la plage d&#39;une puissance de 2.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Puissance de 2 chèques</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot"> Et si vous vouliez vérifier si quelque chose était une puissance de 2? Eh bien, voici un petit truc sympa.. Cela reviendra <span class="inline">true</span> si la valeur donnée est une puissance de 2:<br/></p><p class="code">function is_pow2(_val)<br/>    {<br/>    return _val &amp; (_val - 1)) == 0;<br/>    }</p><p class="dropspot"> Donc, si nous avions le nombre 51 (<span class="inline">110011</span> ) qu&#39;est-ce que cela fait? Eh bien, nous avons ceci... <span class="inline">110011 &amp; 110010</span>, ce qui nous laisse évidemment avec <span class="inline">false</span>, car il reste beaucoup de bits après le <span class="inline">AND</span>. Si nous avions 64 (<span class="inline">1000000</span> ), alors ça devient ça... <span class="inline">1000000 &amp; 0111111</span> ce <em>qui</em> nous laisse 0, donc c&#39;est <span class="inline">true</span>.</p><p class="dropspot"><br/></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Alignement d&#39;index</a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot"> Voici un petit bout de code pour s&#39;aligner sur la puissance de 2 nombres. (1, 2, 4, 8, 16 et ainsi de suite). Cela peut être très utile pour l&#39;allocation de mémoire ou pour vous assurer que vous écrivez les données dans les limites appropriées. Dans cet exemple, <span class="inline">_val1</span> doit être aligné sur <span class="inline">_val2</span> octets, où <span class="inline">_val2</span> est une puissance de 2 nombres. Cette petite fonction arrondit à la limite suivante du nombre souhaité.<br/></p><p class="code">function align_pow2(_val1, _val2)<br/>    {<br/>    return _val1 + (_val2 - 1)) &amp; ~(_val2 - 1);<br/>    }<br/></p><p class="dropspot"><br/></p><p class="dropspot"><br/></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="Additional_Information.htm">Informations complémentaires</a></div><div style="float:right"> Suivant: <a href="Type_Tables.htm">Tables de types</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Bitwise Operators
-->
  <!-- TAGS
bitwise_operators
-->
</body>
</html>