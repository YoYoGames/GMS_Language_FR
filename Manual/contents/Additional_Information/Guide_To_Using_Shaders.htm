<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guide d'utilisation des shaders</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Guide d'utilisation des <span class="notranslate">shaders</span></h1>
  <p>Les<span class="notranslate">shaders</span> sont souvent utilisés pour créer de magnifiques effets graphiques dans les jeux. Ils font également partie des fonctions les plus avancées proposées par <span class="notranslate">GameMaker Studio 2</span>. Il est donc nécessaire que vous ayez une connaissance de base de la programmation et du fonctionnement de <span class="notranslate">GameMaker Studio 2</span> 
    avant de commencer à les utiliser.</p>
  <p>Alors, qu'est-ce qu'un <span class="notranslate">shader</span>? Au départ, ils ont été créés pour fournir un ombrage pour l'éclairage (d'où leur nom), mais ils sont maintenant utilisés pour produire une grande variété d'effets. Le code des <span class="notranslate">shaders</span> est similaire au code ordinaire, mais il est (presque toujours) exécuté par le GPU, et non par le CPU.
    le CPU. Cette différence s'accompagne de son propre ensemble de règles et de limitations, mais nous les aborderons plus tard.</p>
  <p>Chaque <span class="notranslate">shader</span> est composé de deux éléments distincts : un <strong> <span class="notranslate">shader de</span> </strong>sommets et un <strong> <span class="notranslate">shader de</span> </strong> fragments (également appelé <strong> <span class="notranslate">shader de</span></strong> pixels). Commençons par le vertex <span class="notranslate">shader</span>. Chaque sprite est formé par un rectangle,
    mais les ordinateurs aiment dessiner des triangles, donc ces rectangles sont divisés en deux triangles (parfois appelés <em>quad</em>). Cela nous laisse six vertices (coins) par sprite, mais deux d'entre eux sont les mêmes, nous ne devons donc nous préoccuper que de quatre.
    Imaginons maintenant que nous ayons une boucle for qui passe en revue tous les sommets et exécute le code du vertex <span class="notranslate">shader</span> pour chacun d'entre eux. Cela nous permet de changer la position et la couleur du vertex avant de le passer au fragment <span class="notranslate">shader</span> puisque le vertex <span class="notranslate">shader</span> est exécuté
    plus tôt.</p>
  <p>Voici à quoi cela ressemblerait :</p>
  <p><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif">Pour le fragment <span class="notranslate">shader</span>, vous pouvez imaginer la même boucle que précédemment, mais cette fois-ci, elle passe en revue chaque pixel de votre sprite.
    sprite, en vous donnant des informations telles que l'emplacement et la couleur de ce pixel. Dans le code de votre fragment <span class="notranslate">shader</span>, vous effectuez des opérations et des calculs pour déterminer la couleur de ce pixel et obtenir l'effet souhaité. Par exemple, si vous voulez qu'un <span class="notranslate">shader</span> fasse que
    votre sprite en noir et blanc, vous calculez la nuance de gris que chaque pixel doit avoir pour créer cet effet.</p>
  <p>Cela ressemblerait à quelque chose comme ça :</p>
  <p><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif">La raison pour laquelle le code de <span class="notranslate">shaders</span> est généralement exécuté par le GPU est qu'il est plus efficace. Les processeurs modernes possèdent généralement
    de deux à huit cœurs. Chaque cœur peut effectuer une tâche à la fois, donc en tirant parti de plusieurs cœurs, nous pouvons effectuer autant de tâches simultanément. En revanche, les GPU modernes peuvent exécuter des milliers, voire des dizaines de milliers, de tâches en même temps.
    en même temps. Cela est utile pour <span class="notranslate">les shaders</span> car nous pouvons exécuter le code de <span class="notranslate">shaders</span> de milliers de pixels simultanément. La limitation réside dans le fait que nous n'avons accès qu'à l'état initial du sprite.
    aux autres pixels, car nous ne pouvons pas être sûrs que le code a déjà été exécuté sur eux.</p>
  <p class="note"><strong>REMARQUE</strong>: <span class="notranslate">GameMaker Studio 2</span> permet aux utilisateurs d'écrire des <span class="notranslate">shaders</span> en <strong>GLSL</strong> (OpenGL <span class="notranslate">Shader</span> Language), <strong>HLSL</strong> (High-level <span class="notranslate">Shader</span> Language, utilisé lors du travail avec DirectX) et <strong>GLSL ES</strong> (un sous-ensemble de GLSL commun aux appareils mobiles).
    GLSL qui est courant dans les appareils mobiles). Ici, nous utilisons <strong>GLSL ES</strong> comme langage de <span class="notranslate">shaders</span> car c'est celui qui offre la meilleure compatibilité entre les plateformes cibles. En général, c'est celui que vous souhaitez toujours utiliser, sauf si vous
    besoins très spécifiques et que vous compreniez les limites des autres langages de <span class="notranslate">shaders</span>. Les mathématiques et les techniques devraient être similaires entre les trois langages, à l'exception de quelques différences de syntaxe ici et là.</p>
  <p>Le vertex <span class="notranslate">shader</span> est exécuté en premier, et comme nous l'avons expliqué plus haut, il traite les <strong>sommets</strong>. Il est utilisé pour calculer les positions, les normales et les coordonnées de la texture. Ces <span class="notranslate">shaders</span> ne sont pas particulièrement utiles en 2D, puisque chaque sprite est généralement un carré.
    un carré, mais ils peuvent être utilisés pour faire de l'inclinaison, de la mise à l'échelle, etc... Ils deviennent beaucoup plus utiles en 3D pour les calculs d'éclairage et les déformations de maillage. Les fragment <span class="notranslate">shaders</span> sont beaucoup plus intéressants et c'est ce qui sera abordé ici, puisque le fragment shader est l'endroit où l'on obtient des informations sur la forme du sprite.
    est l'<span class="notranslate">endroit</span> où nous obtenons des informations sur nos textures et où nous pouvons modifier la couleur finale de chaque pixel de notre image.</p>
  <p> </p>
  <h2>Variables d'<span class="notranslate">ombrage</span> </h2>
  <p>Si vous avez créé un <span class="notranslate">shader</span> dans <span class="notranslate">GameMaker Studio 2</span>, vous avez peut-être remarqué les mots-clés suivants dans le <span class="notranslate">shader</span> <strong>pass-through</strong> par défaut. Ces mots-clés aident le <span class="notranslate">shader</span> à comprendre l'objectif et la portée de chaque variable :</p>
  <ul class="colour">
    <li><strong>Attribut</strong>: Ce sont des variables transmises par OpenGL au <strong>vertex </strong><span class="notranslate">shader</span>. Elles peuvent changer par sommet et sont en lecture seule. Elles comprennent des informations telles que la position du sommet, les coordonnées de la texture, la couleur du sommet et la normale du sommet.
      normal.</li>
    <li><strong>Variable</strong>: Ce sont des variables utilisées pour faire passer des données entre les <strong>vertex </strong>et <strong>fragment </strong><span class="notranslate">shaders</span>. Elles peuvent être écrites dans le vertex <span class="notranslate">shader</span>, mais sont en lecture seule dans le fragment <span class="notranslate">shader</span>.</li>
    <li><strong>Uniformes</strong>: Ce sont des variables qui changent par objet et qui sont transmises par l'utilisateur au <span class="notranslate">shader</span>. Elles peuvent être utilisées à la fois dans les vertex et les fragment <span class="notranslate">shaders</span>, mais sont en lecture seule.</li>
  </ul>
  <p>Vous verrez également l'utilisation de vec <strong>comme</strong> mot-clé. Il est utilisé pour identifier une variable vectorielle dans le <span class="notranslate">shader</span> et vous verrez bientôt que les vecteurs sont très importants lorsque vous travaillez avec des shaders <span class="notranslate">.</span> C'est pourquoi ils sont implémentés comme un type de base
    de base dans le GLSL. Si vous n'êtes pas familier avec eux, ils sont un terme mathématique représenté comme une matrice avec une seule colonne. En programmation, nous les représentons généralement comme un tableau où le nombre de composants correspond à la dimension. Les vecteurs à deux ou trois dimensions
    sont souvent utilisés pour les positions, les coordonnées de texture ou les couleurs sans canal alpha, tandis que les vecteurs quadridimensionnels sont utilisés pour les couleurs avec un canal alpha. Nous pouvons également préciser s'ils contiennent des booléens, des entiers ou des valeurs à virgule flottante. La syntaxe
    pour déclarer un vecteur est la suivante :</p>
  <p class="code">vec2 firstVec ; // vecteur bidimensionnel de flottants<br> vec3 secondVec ; // vecteur tridimensionnel de flottants<br> vec4 thirdVec ; // vecteur quadridimensionnel de flottants<br>
    <br> bvec3 boolVec ; // vecteur tridimensionnel de booléens<br> ivec4 intVec ; // vecteur quadridimensionnel de booléens</p>
  <p>Pour les initialiser, nous pouvons utiliser le constructeur pour créer le vecteur. Vous devez fournir le même nombre de valeurs que la longueur du vecteur, mais vous pouvez mélanger des scalaires et des vecteurs plus petits pour atteindre la longueur cible. Voici quelques exemples
    exemples de ceci :</p>
  <p class="code">// Vecteur 2D simple avec 2 valeurs scalaires<br> vec2 firstVec = vec2(2.0, 1.0) ;<br> // Un vecteur 4D utilisant 2 scalaires et un vec2 pour créer les 4 valeurs<br> vec4 secondVec = vec4(1.0, firstVec, 0.0) ;<br> // Un vecteur 3D utilisant 1 composante d'un vec4 plus un
    vec2 pour créer les 3 valeurs<br> vec3 thirdVec = vec3(secondVec.x, firstVec) ;</p>
  <p>Nous pouvons également leur assigner un autre vecteur de la même longueur (ou <em>remuer le </em>vecteur jusqu'à ce qu'il ait la bonne longueur, mais nous expliquerons cela dans un moment) :</p>
  <p class="code">vec3 firstVec ;<br> vec3 secondVec = firstVec ;<br> vec4 thirdVec = secondVec.xyz ;<br> vec2 fourthVec = thirdVec.zx ;</p>
  <p>Lorsque nous accédons aux composants d'un vecteur dans GLSL, nous avons quelques options. La plus basique est de traiter le vecteur comme un tableau et d'accéder aux composants en utilisant des crochets, comme ceci :</p>
  <p class="code">vec4 myVec ;<br> myVec[0] = 1.0 ;<br> myVec[1] = 0.0 ;<br> myVec[2] = 2.0 ;<br> myVec[3] = 1.0 ;</p>
  <p>Cependant, il existe un autre moyen d'accéder aux composants avec la syntaxe suivante :</p>
  <p class="code">vec4 myVec ;<br> myVec.x = 1.0 ;<br> myVec.y = 2.0 ;</p>
  <p>Cette méthode utilise les noms des composants à l'intérieur du vecteur pour y accéder. Vous pouvez utiliser x, y, z ou w pour obtenir la première, la deuxième, la troisième ou la quatrième composante, respectivement. Nous appelons cette méthode " <strong>swizzling" </strong>car la syntaxe suivante est également
    valide :</p>
  <p class="code">vec4 firstVec ;<br> vec3 secondVec = firstVec.xyz ;<br> vec2 thirdVec = secondVec.zy ;<br> vec4 fourthVec = thirdVec.yxxy ;</p>
  <p>Comme vous pouvez le constater, nous pouvons utiliser n'importe quelle combinaison de quatre lettres au maximum pour créer un vecteur de cette longueur. Nous ne pouvons pas tenter d'accéder à un composant qui serait hors limites (par exemple, essayer d'accéder à w dans <span class="inline">secondVec</span> ou
   <span class="inline">thirdVec</span>, puisqu'ils n'ont pas de quatrième composant). De plus, nous pouvons répéter des lettres et les utiliser dans n'importe quel ordre, à condition que la variable vectorielle à laquelle elle est affectée soit de la même taille que le nombre de lettres utilisées.</p>
  <p>Pour des raisons évidentes, lorsque vous utilisez swizzle pour définir les valeurs des composants, vous ne pouvez pas utiliser deux fois le même composant. Par exemple, l'exemple ci-dessous n'est pas valide car vous essayez de définir le même composant à deux valeurs différentes :</p>
  <p class="code">monVec.xx = vec2(2.0, 3.0) ;</p>
  <p>Enfin, nous avons utilisé le site <span class="inline">xyzw</span> comme masque, ce qui est généralement le cas lorsqu'il s'agit de positions. Il existe deux autres ensembles de masques que vous pouvez utiliser : <span class="inline">rgba</span> (utilisé pour les couleurs), ou <span class="inline">stpq</span> (utilisé pour les coordonnées de texture). En interne, il n'y a aucune différence entre ces masques, et nous les utilisons uniquement pour rendre le code plus clair quant à ce que le vecteur représente dans ce cas. De plus, nous ne pouvons pas combiner des masques de type "swizzle" dans la même opération, donc
    ceci n'est pas valable :</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp ;</p>
  <p>Cela fait beaucoup de définitions et d'informations, mais il est nécessaire de connaître ces éléments pour comprendre les <span class="notranslate">shaders</span> eux-mêmes.</p>
  <p> </p>
  <h2>Création d'un <span class="notranslate">shader</span></h2>
  <p>Lorsque vous créez un <span class="notranslate">shader</span> dans <span class="notranslate">GameMaker Studio 2</span>, il ouvre deux fichiers pour vous : un vertex <span class="notranslate">shader</span> (<span class="inline">.vsh</span>) et un fragment <span class="notranslate">shader</span> (<span class="inline">.fsh</span>). Il s'agit du <span class="notranslate">shader</span> le plus basique que vous pouvez créer, qui prend un sprite,
    lit la texture, et colorie chaque pixel avec cette couleur. Si vous spécifiez des couleurs de vertex lors du dessin, ces couleurs se mélangeront à la texture.</p>
  <p>Parcourons le code d'un actif <span class="notranslate">shader</span> nouvellement créé et analysons-le, en commençant par le vertex <span class="notranslate">shader</span>.</p>
  <p class="code">// Passthrough Vertex <span class="notranslate">Shader</span><br> attribut vec3 in_Position ; // (x,y,z)<br> //attribut vec3 in_Normal ; // (x,y,z) inutilisé dans ce <span class="notranslate">shader</span>.<br> attribut vec4 in_Colour ; // (r,g,b,a)<br> attribut
    vec2 in_TextureCoord ; // (u,v)<br>
    <br> variable vec2 v_vTexcoord ;<br> variable vec4 v_vColour ;<br>
    <br> void main()<br> {
    <br> vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0) ;<br> gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos ;<br>     <br> v_vColour = in_Colour ;<br> v_vTexcoord = in_TextureCoord ;<br> }
  </p>
  <p>En dehors de la fonction principale, nous voyons quelques déclarations de variables et leurs qualificatifs. Les attributs nous sont donnés par <span class="notranslate">GameMaker</span>. Les variables sont créées par l'utilisateur pour transmettre cette information au fragment <span class="notranslate">shader</span>. Dans la fonction principale,
    nous avons les calculs pour trouver la position du vertex à l'écran :</p>
  <ul class="colour">
    <li>Tout d'abord, nous créons un <span class="inline">vec4</span> et l'initialisons avec les composantes de la position, en ajoutant un comme quatrième composante. En algèbre linéaire, la convention veut que nous ajoutions un un à la quatrième composante si le vecteur représente un point, ou un zéro s'il représente un vecteur réel.
      un point, ou un zéro s'il représente un vecteur réel.</li>
    <li>Ensuite, nous devons ajouter cette quatrième composante pour la multiplier avec la matrice <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, qui est une matrice 4x4. Cette multiplication va projeter la position mondiale du vertex en coordonnées écran.</li>
    <li>Enfin, nous transmettons la couleur du vertex et les coordonnées de la texture au fragment <span class="notranslate">shader</span> par le biais de nos variables variables.</li>
  </ul>
  <p>Ce <span class="notranslate">shader</span> doit être laissé de côté si vous n'avez pas l'intention de jouer avec les positions des vertex et il ne sera utilisé dans aucun des exemples donnés ci-dessous car tous les effets montrés seront créés à l'aide du fragment <span class="notranslate">shader</span>.</p>
  <p>Jetons un coup d'oeil rapide au fragment <span class="notranslate">shader</span> maintenant :</p>
  <p class="code">// <span class="notranslate">Shader de</span>fragment de traversée<br> variable vec2 v_vTexcoord ;<br> variable vec4 v_vColour ;<br>
    <br> void main()<br> {
    <br> gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord ) ;<br> }
  </p>
  <p>Comme expliqué précédemment, l'idée derrière un fragment <span class="notranslate">shader</span> est de retourner la couleur du pixel actuel. Ceci est fait en assignant à la variable <span class="inline">gl_FragColor</span> la valeur de la couleur finale. La fonction <span class="inline">texture2D</span> 
    prend une texture et un <span class="inline">vec2</span> avec les coordonnées UV que vous voulez vérifier dans cette texture, qui renvoie un <span class="inline">vec4</span> avec la couleur. Dans le <span class="notranslate">shader de</span> passage, tout ce que nous faisons est de saisir la couleur de la texture dans la coordonnée de ce pixel.
    la texture dans les coordonnées de ce pixel et la multiplier par la couleur du vertex associé à ce pixel.</p>
  <p>Maintenant que nous avons notre premier <span class="notranslate">shader</span>, tout ce que nous avons à faire pour le tester est de créer un objet et de lui attribuer un sprite, puis dans l'<strong>événement Draw</strong> de l'objet, vous définissez le <span class="notranslate">shader</span> comme ceci :</p>
  <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrColorOverlay) ;
    <br> draw_self() ;
    <br> <span class="notranslate">shader_reset</span>() ;
  </p>
  <p>Chaque appel de dessin effectué entre <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline"><span class="notranslate">shader</span>_set()</a> et <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline"><span class="notranslate">shader</span>_reset()</a> se verra appliquer un
    le <span class="notranslate">shader</span> lui sera appliqué. Ici, nous dessinons le sprite de l'objet avec notre <span class="notranslate">shader</span> passthrough :</p>
  <p><img alt="Drawing Sprite Using Passthough Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_PassThrough.gif">Comme vous l'avez sans doute deviné, cela ne change rien visuellement, car il s'agit d'un simple shader de passage
   <span class="notranslate">shader</span>. Cependant, les sections ci-dessous décrivent quelques étapes simples que vous pouvez suivre pour le modifier et changer la façon dont le sprite sera dessiné. Chaque section montre un <span class="notranslate">shader</span> différent que vous pouvez créer et utiliser dans vos projets, en expliquant les étapes requises pour les créer et pourquoi nous le faisons.
    pour les créer et pourquoi nous faisons les choses comme nous le faisons.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"> <span class="notranslate">Shader de</span>superposition de couleurs</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Nous pouvons maintenant éditer le <span class="notranslate">shader de</span> base pour faire quelque chose de différent. Nous ne toucherons pas à la partie vertex shader, et n'éditerons que le fragment shader <span class="notranslate">,</span> et pour commencer nous allons faire une opération très simple, qui est de faire en sorte que le shader <span class="notranslate">dessine</span> le sprite
      en utilisant la couleur rouge. Nous ferons cela en changeant simplement le <span class="inline">gl_FragColor</span> pour qu'il soit rouge, comme ceci :</p>
    <p class="code">// <span class="notranslate">Shader de</span>fragment de superposition de couleur<br> void main()<br> {
      <br> gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) ;<br> }
    </p>
    <p class="dropspot">Cela nous donne le résultat suivant :</p>
    <p class="dropspot"><img alt="Initial Colour Overlay Block" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Block.gif">Pas exactement ce que nous attendions ! Ce qu'il faut retenir, c'est que chaque sprite est en fait un rectangle,
      donc à moins de considérer la transparence - ce que nous n'avons pas fait - c'est le résultat que nous obtiendrons.</p>
    <p class="note"><strong>NOTE</strong>: Dans l'image ci-dessus, le rectangle change de taille parce que l'espace &quot;vide&quot; autour du sprite de base a été automatiquement rogné lorsqu'il a été placé sur la page de texture par GameMaker <span class="notranslate">.</span>
      qui le composent sont de tailles différentes pour s'adapter à la taille rognée de l'image. Si vous désactivez cette option, vous aurez simplement un carré rouge immobile à l'écran.</p>
    <p class="dropspot">Plus haut, nous avons mentionné la fonction <span class="inline">texture2D</span>, et nous allons l'utiliser pour saisir la couleur du pixel sur lequel nous travaillons et en obtenir la transparence. La valeur de retour de <span class="inline">texture2D</span> est un
      <span class="inline">vec4</span> , où les composants sont le rouge, le vert, le bleu et l'alpha, dans cet ordre. Nous pouvons accéder au canal alpha en mettant un point suivi d'un <span class="inline">a</span> ou d'un <span class="inline">w</span> après le nom de la variable. Cela correspond à RGBA et XYZW, respectivement.</p>
    <p class="dropspot">Voici le code mis à jour :</p>
    <p class="code">// Color Overlay Fragment <span class="notranslate">Shader</span><br> varying vec2 v_vTexcoord ;<br>
      <br> void main()<br> {
      <br> vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord) ;<br> gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a) ;<br> }
    </p>
    <p class="dropspot">Nous assignons maintenant un nouveau <span class="inline">vec4</span> à <span class="inline">gl_FragColor</span>, où le canal rouge est maximisé, les canaux vert et bleu sont à zéro et le canal alpha est le même que celui de la texture originale. La sortie ressemble à
      ressemble à ceci :</p>
    <p class="dropspot"><img alt="Overlay Shader Making Sprite Red" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay.gif">Voilà ce que nous cherchions ! Nous avons remplacé la couleur de chaque pixel par du rouge, mais nous avons gardé
      le canal alpha intact.</p>
    <p class="dropspot">Devoir changer le <span class="notranslate">shader</span> à chaque fois que nous voulons utiliser une couleur différente n'est pas une bonne idée, d'autant plus que nous aurions besoin d'avoir un <span class="notranslate">shader</span> séparé pour chaque couleur que nous voulons. Au lieu de cela, nous allons transmettre les informations de couleur au <span class="notranslate">shader</span> en utilisant un <strong>uniforme</strong>.
      Pour ce faire, nous devons d'abord obtenir un <strong>pointeur </strong>vers l'uniforme. Nous le ferons dans l'<strong>événement Create</strong> de notre objet qui contient le sprite en ajoutant :</p>
    <p class="code">// Créer un événement<br> _uniColor = <span class="notranslate">shader_get_uniform</span>(shdrColorOverlay, &quot;u_colour&quot;) ;<br> _color = [1.0, 1.0, 0.0, 1.0] ;</p>
    <p class="dropspot">Tout ce que nous devons faire est d'appeler <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline"><span class="notranslate">shader</span>_get_uniform()</a> pour obtenir un pointeur sur l'uniforme. Les paramètres que nous devons passer sont le <span class="notranslate">shader</span>
      (sans guillemets car nous voulons passer l'ID que <span class="notranslate">GameMaker</span> génère pour nous) et le nom de la variable de l'uniforme dans le <span class="notranslate">shader</span>, cette fois sous forme de chaîne. Ce nom doit correspondre exactement à celui du code du <span class="notranslate">shader</span> pour que cela fonctionne.
      pour que cela fonctionne. Nous avons également ajouté une variable de couleur afin que nous puissions la modifier au <span class="notranslate">moment de l'exécution</span> et qu'elle se souvienne de nos changements.</p>
    <p class="dropspot">Maintenant, le code dans notre événement de dessin sera légèrement modifié pour passer la variable uniforme.</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrColorOverlay) ;
      <br> <span class="notranslate">shader_set_uniform_f_array</span>(_uniColor, _color) ;<br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">C'est le même code que précédemment, mais avant de dessiner quoi que ce soit, nous devons transmettre toutes les valeurs uniformes au <span class="notranslate">shader</span>. Dans ce cas, nous passons la couleur comme un tableau de flottants. Quant au <span class="notranslate">shader</span>, nous allons le modifier pour inclure l'uniforme et l'utiliser,
      ainsi il devient :</p>
    <p class="code">// <span class="notranslate">Shader de</span>fragment de superposition de couleurs<br> varying vec2 v_vTexcoord ;<br> uniform vec4 u_color ;<br> void main()<br> {
      <br> vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord) ;<br> gl_FragColor = vec4(u_color.rgb, texColor.a) ;<br> }
    </p>
    <p class="dropspot">Nous déclarons une variable avec le même nom que dans le <span class="notranslate">shader de</span> création (<span class="inline">u_color</span>) et nous la passons comme les trois premières composantes du vecteur <span class="inline">gl_FragColor</span>, en profitant du swizzling. Si nous compilons
      nous devrions voir ceci :</p>
    <p class="dropspot"><img alt="Overlay Shader Making Sprite Yellow" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Yellow.gif">Maintenant le <span class="notranslate">shader</span> est beaucoup plus utile et réutilisable. C'est à vous d'ajouter des fonctionnalités supplémentaires.
      si vous avez besoin qu'il définisse la couleur (en utilisant la variable <span class="inline">_color</span>) pendant l <span class="notranslate">'exécution</span>.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"> <span class="notranslate">Shader</span>noir et blanc</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Réaliser un <span class="notranslate">shader</span> noir et blanc est un excellent moyen d'en apprendre davantage sur le fonctionnement des <span class="notranslate">shaders</span>, et beaucoup de débutants commencent par essayer de le faire, car conceptuellement c'est assez simple : prendre chaque pixel et lui attribuer une nuance de gris. Mais est-ce simple ? Pas
      pas tout à fait...
    </p>
    <p class="dropspot">Lorsqu'on utilise la couleur RVB, si les trois composantes ont la même valeur, on obtient un ton gris. L'approche naïve de la création d'un <span class="notranslate">shader</span> pour utiliser cette idée serait d'additionner les trois canaux de couleur (rouge, vert et bleu), puis de les diviser par trois. Après
      Ensuite, vous assignez la valeur aux trois canaux, créant ainsi un ton gris. Voici à quoi ressemble ce <span class="notranslate">shader de</span> fragment :</p>
    <p class="code">// <span class="notranslate">Shader de</span>fragment noir et blanc<br> vec2 variable v_vTexcoord ;<br> vec4 variable v_vColour ;<br>
      <br> void main()<br> {
      <br> vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord) ;<br> float gray = (texColor.r + texColor.g + texColor.b) / 3.0 ;<br> gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a) ;<br> }
    </p>
    <p class="dropspot">Vous avez peut-être remarqué que dans le code <span class="inline">gl_FragColor</span>, nous multiplions <span class="inline">vec4</span> avec une variable appelée <span class="inline">v_vColour</span>. Il s'agit d'une variable transmise par le
      vertex <span class="notranslate">shader</span> qui nous indique la couleur du vertex associé à ce pixel. C'est toujours une bonne idée de multiplier la couleur finale calculée par la couleur du vertex. Dans la plupart des cas, cela ne fera rien, mais si vous avez changé la couleur du vertex en <span class="notranslate">GML</span>,
      cela le reflétera (en utilisant des fonctions telles que <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> ou <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> pour
      changer la <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Quant à l'événement de tirage au sort, il est assez simple puisque nous n'avons pas d'uniforme à passer :</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrBlackAndWhite) ;
      <br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">Compilons et voyons ce que nous avons.</p>
    <p class="dropspot"><img alt="Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite.gif">C'est déjà très bien, non ? Eh bien, oui et non... il existe une solution plus "correcte", puisqu'au lieu
      d'additionner les composants et de les diviser par trois, nous multiplions chaque composant par les valeurs standard NTSC pour le noir et le blanc. Voici le code modifié du fragment <span class="notranslate">shader</span>:</p>
    <p class="code">// <span class="notranslate">Shader de</span>fragment noir et blanc<br> variant vec2 v_vTexcoord ;<br>
      <br> void main()<br> {
      <br> vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord) ;<br> float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114)) ;<br> gl_FragColor = vec4(gray, gray, gray, texColor.a) ;<br> }
    </p>
    <p class="dropspot">Nous utilisons le produit scalaire comme raccourci pour multiplier chaque composant de <span class="inline">texColor</span> avec les pondérations correctes, puis les additionner. Si vous n'êtes pas familier avec le produit scalaire, c'est essentiellement ce qui se passe :</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114) ;</p>
    <p class="dropspot">Au final, cela ressemble beaucoup, mais c'est techniquement plus correct.</p>
    <p class="dropspot"><img alt="Corrected Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite_Improved.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"> <span class="notranslate">Shader</span>arc-en-ciel</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Notre dernier exemple de <span class="notranslate">shader</span> est amusant et peut être utilisé pour ajouter de la vie au texte, aux boutons et à d'autres choses. Nous allons commencer simplement et ajouter des fonctionnalités progressivement, car ce shader <span class="notranslate">est</span> hautement personnalisable. Il y a beaucoup de choses à couvrir pour cet exemple,
      donc si vous vous sentez un peu perdu ou confus, veuillez revenir en arrière et relire certaines des sections ci-dessus.</p>
    <p class="dropspot">La première chose que nous voulons faire est de colorer les pixels avec chaque teinte, en fonction de la position horizontale du pixel. Pour ce faire, il faut définir la position x comme étant la teinte, puis convertir le format HSV (teinte, saturation, luminosité) en format RGB (rouge, vert,
      et bleu). Pour cela, nous devons écrire une fonction d'aide dans notre fragment <span class="notranslate">shader</span> qui prend les valeurs HSV et renvoie un vecteur RVB. Nous utiliserons une seule fonction qui fera cela sans avoir besoin d'aucune déclaration à l'adresse <span class="inline">if</span>,
      car l'utilisation de conditionnels dans le code du <span class="notranslate">shader</span> rend les <span class="notranslate">shaders</span> <em>très </em>lents et doit être évitée.</p>
    <p class="dropspot">Voici à quoi ressemble le <span class="notranslate">shader</span> à ce stade :</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variable vec2 v_vTexcoord ;<br> variable vec4 v_vColour ;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0) ;<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www) ;<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y) ;<br> }
      <br>
      <br> void main()<br> {
      <br> vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0) ;<br> float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a ;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha) ;<br> }
    </p>
    <p class="dropspot">Il se passe un peu plus de choses ici que dans les exemples précédents, mais la plupart d'entre elles devraient être assez évidentes pour vous maintenant. Tout d'abord, il y a notre fonction <span class="inline">hsv2rgb</span>, qui prend un <span class="inline">vec3</span> avec notre couleur HSV
      et renvoie une autre <span class="inline">vec3</span> avec notre conversion RVB. Dans la fonction principale, nous commençons par créer notre couleur HSV, où la teinte est notre position x, et nous laissons la saturation et la luminosité à 1,0 pour le moment. Ensuite, nous récupérons
      l'alpha de la texture afin qu'elle ne colore que le personnage du sprite et non l'ensemble du rectangle du sprite (comme nous l'avons fait dans l'exemple de superposition de couleurs, ci-dessus). Enfin, nous définissons notre couleur de fragment comme étant notre couleur HSV convertie en RVB avec l'alpha, multipliée par la couleur de sommet (bonne pratique).
      par la couleur du sommet (c'est une bonne pratique de toujours faire cela).</p>
    <p class="dropspot">Quant à notre code de tirage, il est trivial pour l'instant :</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrRainbow) ;
      <br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">Voyons ce qu'on a :</p>
    <p class="dropspot"><img alt="Initial Rainbow Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay.gif">Nous sommes proches de ce que nous voulons, mais il y a un problème : nous ne voyons pas toutes les couleurs en même temps dans chaque image de l'animation.
      de l'animation, et les couleurs semblent changer de façon aléatoire. La raison en est que nous avons supposé que <span class="inline">v_vTexcoord</span> nous a donné les coordonnées du sprite, commençant dans le coin supérieur gauche (0,0) et finissant dans le coin inférieur droit
      (1,1), ce qui est standard dans les <span class="notranslate">shaders</span>. Cependant, pour des raisons d'optimisation, <span class="notranslate">GameMaker</span> regroupe autant de textures que possible dans ce que l'on appelle une <a href="../Settings/Texture_Information/Texture_Pages.htm">page de texture.</a> 
      c'est à cela que ressemble notre texture :</p>
    <p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Texture.png">Comme expliqué ci-dessus, <span class="inline">v_vTexcoord</span> nous donne les coordonnées absolues du sprite dans cette page de texture entière,
      mais ce que nous voulons, c'est une valeur comprise entre 0,0 et 1,0 qui ne couvre que notre sprite actuel. Ce processus est appelé <strong>normalisation</strong> (obtenir une valeur et la traduire en une plage de 0 à 1). Pour normaliser nos valeurs horizontales, nous devons connaître les valeurs de x0 et x1 dans le sprite actuel.
      valeurs de x0 et x1 dans l'image ci-dessus. Heureusement, <span class="notranslate">GameMaker</span> possède une fonction qui nous donne l'emplacement de chaque coin de notre sprite dans la page de texture. Tout d'abord, nous devons aller dans l'événement Create et créer un uniforme pour transmettre ces données à
      le <span class="notranslate">shader</span>:</p>
    <p class="code">// Créer un événement<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;) ;</p>
    <p class="dropspot">Et nous modifions l'événement draw pour obtenir les valeurs et les passer au <span class="notranslate">shader</span>:</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrRainbow) ;
      <br> var uv = sprite_get_uvs(sprite_index, image_index) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]) ;<br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">La fonction <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> prend un sprite et un index, et renvoie un tableau avec des tonnes d'informations,
      comme les coordonnées de chaque coin, combien de pixels ont été coupés pour l'optimiser, etc. Nous sommes intéressés par deux de ces valeurs : les coordonnées gauche et droite du sprite, qui sont stockées respectivement dans <span class="inline">uv[0]</span> et <span class="inline">uv[2]</span>. Dans le fragment <span class="notranslate">shader</span>, nous allons maintenant utiliser ces valeurs pour calculer la position horizontale normalisée de la manière suivante :</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> varying vec2 v_vTexcoord ;<br> varying vec4 v_vColour ;<br>
      <br> uniform vec2 u_uv ;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0) ;<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www) ;<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y) ;<br> }
      <br>
      <br> void main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]) ;<br> vec3 col = vec3(pos, 1.0, 1.0) ;<br> float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a ;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha) ;<br> }
    </p>
    <p class="dropspot">Ici, nous ajoutons la variable uniforme en haut du fichier avec le même nom que nous avons utilisé dans l'événement de création. Ensuite, nous calculons la position horizontale normalisée en translatant notre coordonnée actuelle <span class="inline">x</span> vers l'origine (
      <span class="inline">v_vTexcoord.x - u_uv[0]</span> ), puis nous la divisons par la largeur du sprite pour obtenir une valeur comprise entre 0 et 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">Le résultat est :</p>
    <p class="dropspot"><img alt="Rainbow Overlay Shader Improved" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Improved.gif">Nous y voilà ! C'est exactement ce que nous voulions. Nous pouvons voir toutes les couleurs du spectre à l'intérieur
      notre sprite.</p>
    <p class="dropspot">Cela peut vous satisfaire, mais nous pouvons nous amuser davantage avec ce <span class="notranslate">shader</span>. Et si nous ajoutions un décalage aux couleurs en fonction du temps pour produire du mouvement ? Pour ce faire, nous aurons besoin de deux variables supplémentaires pour la <strong>vitesse </strong>et le <strong>temps</strong>.
      Nous aurons également besoin de deux uniformes supplémentaires, un pour chacune des nouvelles variables, de sorte que l'événement Create devient :</p>
    <p class="code">// Créer un événement<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;) ;<br> _uniTime = shader_get_uniform(shdrRainbow, &quot;u_time&quot;) ;<br> _uniSpeed = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_speed&quot;) ;<br> _time = 0 ;<br> _speed = 1.0 ;</p>
    <p class="dropspot">Nous devons également augmenter le temps à chaque image, donc dans le Step Event nous ajoutons :</p>
    <p class="code">// Événement d'étape<br> _time += 1 / room_speed ;</p>
    <p class="dropspot">Passons maintenant à l'événement draw pour envoyer ces uniformes au <span class="notranslate">shader</span>:</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrRainbow) ;
      <br> var uv = sprite_get_uvs(sprite_index, image_index) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSpeed, _speed) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniTime, _time) ;<br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">Enfin, nous allons retourner dans notre shader <span class="notranslate">pour</span> utiliser réellement ces variables maintenant. Ce que nous allons faire, c'est multiplier la vitesse par le temps et l'ajouter à la position, comme ceci :</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variable vec2 v_vTexcoord ;<br> variable vec4 v_vColour ;<br>
      <br> uniforme vec2 u_uv ;<br> uniforme float u_speed ;<br> uniforme float u_time ;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0) ;<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www) ;<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y) ;<br> }
      <br>
      <br> void main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]) ;<br> vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0) ;<br> float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a ;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col),
      alpha) ;
      <br> }
    </p>
    <p class="dropspot">Si vous avez tout fait correctement, vous devriez voir quelque chose comme ceci :</p>
    <p class="dropspot"><img alt="Rainbow Shader Overlay Moving With Time" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Final.gif">Pour terminer ce <span class="notranslate">shader</span>, nous allons ajouter quelques uniformes supplémentaires pour le personnaliser encore plus.
      Les deux premiers servent à contrôler la saturation et la luminosité. Le suivant, que nous appellerons &quot;section&quot;, a pour fonction de permettre à l'utilisateur de passer un nombre entre zéro et un pour déterminer le pourcentage du spectre entier que nous voyons à un moment donné.
      à un moment donné. Enfin, nous ajouterons une variable appelée &quot;mix&quot;, qui spécifiera dans quelle mesure nous voulons mélanger la <span class="notranslate">couleur de</span> notre shader avec la couleur de la texture originale (1.0 est tout arc-en-ciel, 0.0 est toute la texture). Comme toujours, commençons par ajouter les variables à
      l'événement Create :</p>
    <p class="code">// Créer un événement<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;) ;<br> _uniTime = shader_get_uniform(shdrRainbow, &quot;u_time&quot;) ;<br> _uniSpeed = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_speed&quot;) ;<br> _uniSection
         = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_section&quot;) ;<br> _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;) ; <br> _uniBrightness = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_brightness&quot;) ;<br> _uniMix =
     <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_mix&quot;) ;<br>
      <br> _time = 0 ;<br> _speed = 1.0 ;<br> _section = 0.5 ;<br> _saturation = 0.7 ;<br> _brightness = 0.8 ;<br> _mix = 0.5 ;</p>
    <p class="dropspot">Notre événement de tirage au sort change pour inclure ces uniformes comme ceci :</p>
    <p class="code">// Événement de dessin<br> <span class="notranslate">shader_set</span>(shdrRainbow) ;
      <br> var uv = sprite_get_uvs(sprite_index, image_index) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSpeed, _speed) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniTime, _time) ; <br> <span class="notranslate">shader_set_uniform_f</span>(_uniSaturation, _saturation) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniBrightness, _brightness) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSection, _section) ;<br> <span class="notranslate">shader_set_uniform_f</span>(_uniMix, _mix) ;<br> draw_self() ;
      <br> <span class="notranslate">shader_reset</span>() ;
    </p>
    <p class="dropspot">Comme pour le <span class="notranslate">shader</span>, nous devons passer la saturation et la luminosité à la couleur, ce qui affectera la couleur générée par notre fonction d'aide. La section doit être multipliée par notre position pour réduire la portée. Nous allons également saisir la texture entière
      afin de pouvoir calculer notre couleur finale en mélangeant la couleur de la texture avec la conversion RVB de notre couleur. Le dernier paramètre de la fonction mix détermine la quantité de la deuxième couleur que nous voulons ajouter. Ceci est notre code de <span class="notranslate">shader</span> final :</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> varying vec2 v_vTexcoord ;<br> varying vec4 v_vColour ;<br>
      <br> uniform vec2 u_uv ;<br> uniform float u_speed ;<br> uniform float u_time ;<br> uniform float u_saturation ;<br> uniform float u_brightness ;<br> uniform float u_section ;<br> Uniform float u_mix ;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0) ;<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www) ;<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y) ;<br> }
      <br>
      <br> void main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]) ;<br> vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord) ; <br>     <br> vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness) ;<br> vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix) ;<br>     <br> gl_FragColor = v_vColour * finalCol ;<br> }
    </p>
    <p class="dropspot">Et voici notre résultat final !</p>
    <p class="dropspot"><img alt="Rainbow Shader Final" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Final.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>C'est la fin de ce petit guide et vous devriez maintenant avoir une meilleure compréhension du fonctionnement des shaders et de certaines des utilisations qu'on peut en faire. Vous devriez prendre le temps de jouer avec les <span class="notranslate">shaders</span> que vous avez créés en suivant ce guide, et essayer de
    d'expérimenter avec eux pour faire d'autres choses - que diriez-vous de créer un <span class="notranslate">shader de</span> flou, ou un <span class="notranslate">shader</span> qui fait un écran monochrome de style gameboy ? - car les <span class="notranslate">shaders</span> sont un outil incroyablement puissant pour ajouter de la complexité visuelle et du style à vos jeux.</p>
  <p> </p>
  <p class="note"><span class="notranslate">YoYo Games</span> tient à remercier <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> et <strong><span class="notranslate">Amazon</span></strong> pour nous avoir permis de reproduire ce guide. Vous pouvez trouver la version originale sur le <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">blog des développeurs d'<span class="notranslate">Amazon</span></a>.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="Additional_Information.htm">Informations complémentaires</a></div>
        <div style="float:right">Suivant : <a href="Guide_To_Primitives_And_Vertex_Building.htm">Guide des primitives et de la construction de sommets</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
<span class="notranslate">Shaders</span>
Using <span class="notranslate">Shaders</span>
<span class="notranslate">Shader</span> Guide
Guide To Using <span class="notranslate">Shaders</span>
-->
  <!-- TAGS
using_<span class="notranslate">shaders</span>
-->
</body>
</html>