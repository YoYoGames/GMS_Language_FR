<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guide d&#39;utilisation des Shaders</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page qui explique comment configurer et utiliser les shaders" />
  <meta name="rh-index-keywords" content="Guide d&#39;utilisation des Shaders" />
  <meta name="search-keywords" content="shaders,shader,utiliser des shaders,guide de shader,configuration du shader,exemples de shader,exemple de shader" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Guide d&#39;utilisation des <span class="notranslate">Shaders</span></h1><p> <span class="notranslate">Shaders</span> sont souvent utilisés pour créer de beaux effets graphiques dans les jeux. Elles font également partie des fonctionnalités les plus avancées offertes par <span class="notranslate">GameMaker Studio 2</span>, il est donc nécessaire que vous ayez une compréhension de base de la programmation et du fonctionnement de <span class="notranslate">GameMaker Studio 2</span> avant de commencer à les utiliser.</p><p> Alors, qu&#39;est-ce qu&#39;un <span class="notranslate">shader</span> ? Initialement, ils ont été créés pour fournir un ombrage pour l&#39;éclairage (d&#39;où le nom), mais ils sont maintenant utilisés pour produire une grande variété d&#39;effets. <span class="notranslate">Shader</span> code Shader est similaire au code normal, mais il est (presque toujours) exécuté par le GPU, pas par le CPU. Cette différence vient avec son propre ensemble de règles et de limitations, mais nous les couvrirons plus tard.</p><p> Chaque <span class="notranslate">shader</span> est composé de deux composants distincts: un <strong>vertex <span class="notranslate">shader</span></strong> et un <strong>fragment <span class="notranslate">shader</span></strong> (également appelé <strong>pixel <span class="notranslate">shader</span></strong> ). Commençons par le vertex <span class="notranslate">shader</span>. Chaque sprite est formé par un rectangle, mais les ordinateurs aiment dessiner des triangles, donc ces rectangles sont divisés en deux triangles (parfois appelés <em>quad</em> ). Cela nous laisse avec six sommets (coins) par sprite, mais deux d&#39;entre eux sont les mêmes, donc nous ne devrions nous soucier que de quatre. Maintenant, imaginez que nous ayons une boucle for qui passe sur chaque sommet et exécute le code à l&#39;intérieur du <span class="notranslate">shader</span> vertex pour chacun. Cela nous permet de changer la position et la couleur des sommets avant de les transmettre au fragment <span class="notranslate">shader</span> puisque le vertex <span class="notranslate">shader</span> est exécuté plus tôt.</p><p> Voici à quoi cela ressemblerait:</p><p><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /> Pour le fragment <span class="notranslate">shader</span>, vous pouvez imaginer la même boucle qu&#39;avant, mais cette fois, elle passe sur chaque pixel de votre sprite, vous donnant des informations telles que l&#39;emplacement et la couleur de ce pixel. Dans votre <span class="notranslate">shader</span> fragment, vous effectuez des opérations et des calculs pour déterminer la couleur de ce pixel afin d&#39;obtenir l&#39;effet souhaité. Par exemple, si vous voulez qu&#39;un <span class="notranslate">shader</span> rend votre sprite noir et blanc, vous calculez alors quelle nuance de gris chaque pixel doit avoir pour créer l&#39;effet.</p><p> Cela ressemblerait à quelque chose comme ceci:</p><p><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /> La raison pour laquelle <span class="notranslate">shader</span> code de shader est généralement exécuté par le GPU est qu&#39;il est plus efficace. Les processeurs modernes ont généralement entre deux et huit cœurs. Chaque cœur peut effectuer une tâche à la fois, donc en tirant parti de plusieurs cœurs, nous pouvons effectuer autant de tâches simultanément. En revanche, les GPU modernes peuvent effectuer des milliers, voire des dizaines de milliers de tâches en même temps. Ceci est utile pour les <span class="notranslate">shaders</span> car nous pouvons exécuter le <span class="notranslate">shader</span> de milliers de pixels simultanément. La limitation est que nous n&#39;avons accès qu&#39;à l&#39;état initial du sprite, nous ne connaissons donc aucune modification apportée aux autres pixels car nous ne pouvons pas savoir avec certitude que le code a encore été exécuté sur eux.</p><p class="note"> <strong>REMARQUE</strong>: <span class="notranslate">GameMaker Studio 2</span> permet aux utilisateurs d&#39;écrire des <span class="notranslate">shaders</span> en <strong>GLSL</strong> (OpenGL <span class="notranslate">Shader</span> Language), <strong>HLSL</strong> (High-level <span class="notranslate">Shader</span> Language, utilisé lors de l&#39;utilisation de DirectX) et <strong>GLSL ES</strong> (un sous-ensemble de GLSL qui est courant dans les appareils mobiles). Ici, nous utilisons <strong>GLSL ES</strong> comme <span class="notranslate">shader</span> car c&#39;est celui qui offre la meilleure compatibilité entre les plates-formes cibles. Généralement, c&#39;est celui que vous souhaitez toujours utiliser à moins que vous n&#39;ayez des besoins très spécifiques et que vous compreniez les limites des autres langages de <span class="notranslate">shader</span> Cependant, les mathématiques et les techniques devraient être similaires entre les trois langages, à l&#39;exception de quelques différences de syntaxe ici et là.</p><p> Le vertex <span class="notranslate">shader</span> est exécuté en premier et, comme nous l&#39;avons expliqué ci-dessus, il traite des <strong>sommets</strong>. Il est utilisé pour calculer les positions, les normales et les coordonnées de texture. Ces <span class="notranslate">shaders</span> ne sont pas particulièrement utiles en 2D, puisque chaque sprite est généralement un carré, mais il peut être utilisé pour faire un peu de biais, de mise à l&#39;échelle, etc... Cela devient beaucoup plus utile en 3D pour les calculs d&#39;éclairage et les déformations de maillage. Les <span class="notranslate">shaders</span> fragments sont beaucoup plus intéressants et sont ce qui sera principalement couvert ici, car le <span class="notranslate">shader</span> fragment est l&#39;endroit où nous obtenons des informations sur nos textures et pouvons modifier la couleur finale de chaque pixel de notre image.</p><p></p><h2> Variables de <span class="notranslate">Shader</span></h2><p> Si vous avez créé un <span class="notranslate">shader</span> dans <span class="notranslate">GameMaker Studio 2</span>, vous avez sans doute remarqué les mots clés suivants dans le <strong>pass-through</strong> par défaut <span class="notranslate">shader</span>. Ces mots clés aident le <span class="notranslate">shader</span> comprendre le but et la portée de chaque variable:</p><ul class="colour"><li> <strong>Attribut</strong>: ce sont des variables transmises par OpenGL au <strong>vertex</strong> <span class="notranslate">shader</span>. Ceux-ci peuvent changer par sommet et sont en lecture seule. Celles-ci incluent des informations telles que la position du sommet, les coordonnées de la texture, la couleur du sommet et la normale du sommet.</li><li> <strong>Variables</strong>: ce sont des variables utilisées pour transmettre des données entre les <span class="notranslate">shaders</span> <strong>sommets</strong> et de <strong>fragments</strong>. Ceux-ci sont disponibles pour l&#39;écriture dans le vertex <span class="notranslate">shader</span>, mais sont en lecture seule dans le fragment <span class="notranslate">shader</span>.</li><li> <strong>Uniforme</strong>: ce sont des variables qui changent par objet et sont transmises par l&#39;utilisateur au <span class="notranslate">shader</span>. Ceux-ci peuvent être utilisés à la fois dans les <span class="notranslate">shaders</span> vertex et de fragment, mais sont en lecture seule.</li></ul><p> Vous verrez également l&#39;utilisation de <strong>vec</strong> comme mot-clé. Ceci est utilisé pour identifier une variable vectorielle dans le <span class="notranslate">shader</span> et vous verrez bientôt que les vecteurs sont très importants lorsque vous travaillez avec des <span class="notranslate">shaders</span>. C&#39;est pourquoi ils sont implémentés en tant que type de base dans GLSL. Si vous ne les connaissez pas, il s&#39;agit d&#39;un terme mathématique représenté sous forme de matrice avec une seule colonne. En programmation, nous les représentons généralement sous forme de tableau où le nombre de composants correspond à la dimension. Les vecteurs à deux et trois dimensions sont souvent utilisés pour les positions, les coordonnées de texture ou les couleurs sans canal alpha, tandis que les vecteurs à quatre dimensions sont utilisés pour les couleurs avec un canal alpha. Nous pouvons également spécifier s&#39;ils contiennent des booléens, des entiers ou des valeurs à virgule flottante. La syntaxe pour déclarer un vecteur est la suivante:</p><p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br/> vec3 secondVec; // Three-dimensional vector of floats<br/> vec4 thirdVec;  // Four-dimensional vector of floats<br/>
    <br/> bvec3 boolVec;  // Three-dimensional vector of booleans<br/> ivec4 intVec;   // Four-dimensional vector of booleans</p><p> Pour les initialiser, nous pouvons utiliser le constructeur pour créer le vecteur. Vous devez fournir le même nombre de valeurs que la longueur du vecteur, mais vous pouvez mélanger et faire correspondre des scalaires et des vecteurs plus petits pour atteindre la longueur cible. En voici quelques exemples:</p><p class="code">// Simple 2D vector with 2 scalar values<br/> vec2 firstVec  = vec2(2.0, 1.0);<br/> // A 4D vector using 2 scalars and a vec2 create the 4 values<br/> vec4 secondVec = vec4(1.0, firstVec, 0.0);<br/> // A 3D vector using 1 component of a vec4 plus a
    vec2 to create the 3 values<br/> vec3 thirdVec  = vec3(secondVec.x, firstVec);</p><p> Nous pouvons également leur attribuer un autre vecteur de même longueur (ou faire <em>basculer</em> le vecteur jusqu&#39;à ce qu&#39;il ait la bonne longueur, mais nous l&#39;expliquerons dans un instant):</p><p class="code">vec3 firstVec;<br/> vec3 secondVec = firstVec;<br/> vec4 thirdVec  = secondVec.xyz;<br/> vec2 fourthVec = thirdVec.zx;</p><p> Lors de l&#39;accès aux composants vectoriels dans GLSL, nous avons quelques options. Le plus élémentaire est de traiter le vecteur comme un tableau et d&#39;accéder aux composants en utilisant des crochets, comme ceci:</p><p class="code">vec4 myVec;<br/> myVec[0] = 1.0;<br/> myVec[1] = 0.0;<br/> myVec[2] = 2.0;<br/> myVec[3] = 1.0;</p><p> Cependant, il existe un autre moyen d&#39;accéder aux composants avec la syntaxe suivante:</p><p class="code">vec4 myVec;<br/> myVec.x = 1.0;<br/> myVec.y = 2.0;</p><p> Cela utilise les noms de composants à l&#39;intérieur du vecteur pour y accéder. Vous pouvez utiliser x, y, z ou w pour obtenir respectivement les premier, deuxième, troisième ou quatrième composants. Nous appelons cette méthode <strong>swizzling</strong> car la syntaxe suivante est également valide:</p><p class="code">vec4 firstVec;<br/> vec3 secondVec = firstVec.xyz;<br/> vec2 thirdVec  = secondVec.zy;<br/> vec4 fourthVec = thirdVec.yxxy;</p><p> Comme vous pouvez le voir, nous pouvons utiliser n&#39;importe quelle combinaison de quatre lettres maximum pour créer un vecteur de cette longueur. Nous ne pouvons pas tenter d&#39;accéder à un composant qui serait hors limites (par exemple, en essayant d&#39;accéder à w dans <span class="inline">secondVec</span> ou <span
      class="inline">thirdVec</span>, car ils n&#39;ont pas de quatrième composant). De plus, nous pouvons répéter des lettres et les utiliser dans n&#39;importe quel ordre, à condition que la variable vectorielle à laquelle elle est affectée ait la même taille que le nombre de lettres utilisées.</p><p> Pour des raisons évidentes, lorsque vous utilisez swizzle pour définir les valeurs des composants, vous ne pouvez pas utiliser le même composant deux fois. Par exemple, ce qui suit n&#39;est pas valide car vous essayez de définir le même composant sur deux valeurs différentes:</p><p class="code">myVec.xx = vec2(2.0, 3.0);</p><p> Enfin, nous utilisons <span class="inline">xyzw</span> comme notre masque swizzle, ce qui est généralement le cas lorsqu&#39;il s&#39;agit de positions. Vous pouvez utiliser deux autres ensembles de masques: <span class="inline">rgba</span> (utilisé pour les couleurs), ou <span class="inline">stpq</span> (utilisé pour les coordonnées de texture). En interne, il n&#39;y a aucune différence entre ces masques, et nous les utilisons uniquement pour rendre le code plus clair quant à ce que le vecteur représente dans cette instance. De plus, nous ne pouvons pas combiner des masques de swizzle dans la même opération, donc ce n&#39;est pas valide:</p><p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p><p> C&#39;étaient beaucoup de définitions et d&#39;informations, mais connaître ces choses est nécessaire pour comprendre les <span class="notranslate">shaders</span> eux-mêmes.</p><p></p><h2> Créer un <span class="notranslate">Shader</span></h2><p> Lorsque vous créez un <span class="notranslate">shader</span> dans <span class="notranslate">GameMaker Studio 2</span>, il ouvre deux fichiers pour vous: un vertex <span class="notranslate">shader</span> (<span class="inline">.vsh</span> ) et un fragment <span class="notranslate">shader</span> (<span class="inline">.fsh</span> ). <span class="notranslate">shader</span> le plus basique que vous puissiez créer, qui prend un sprite, lit la texture et colore chaque pixel avec cette couleur. Si vous spécifiez les couleurs des sommets lors du dessin, ces couleurs se fondront avec la texture.</p><p> Passons en revue le code d&#39;un <span class="notranslate">shader</span> nouvellement créé et analysons-le, en commençant par le vertex <span class="notranslate">shader</span>.</p><p class="code">// Passthrough Vertex Shader<br/> attribute vec3 in_Position;                  // (x,y,z)<br/> //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br/> attribute vec4 in_Colour;                    // (r,g,b,a)<br/> attribute
    vec2 in_TextureCoord;              // (u,v)<br/>
    <br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
    <br/> void main()<br/> {
    <br/>     vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br/>     gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br/>     <br/>     v_vColour = in_Colour;<br/>     v_vTexcoord = in_TextureCoord;<br/>    }
  </p><p> En dehors de la fonction principale, nous voyons quelques déclarations de variables et leurs qualificatifs. Les attributs nous sont donnés par <span class="notranslate">GameMaker</span>. Les différents sont créés par l&#39;utilisateur pour transmettre ces informations au fragment <span class="notranslate">shader</span>. À l&#39;intérieur de la fonction principale, nous avons les calculs pour trouver la position d&#39;écran du sommet:</p><ul class="colour"><li> Tout d&#39;abord, nous créons un <span class="inline">vec4</span> et initialisez-le avec les composants de la position, en ajoutant un comme quatrième composant. En algèbre linéaire, la convention est que nous ajoutons un un à la quatrième composante si le vecteur représente un point, ou un zéro s&#39;il représente un vecteur réel.</li><li> Ensuite, nous devons ajouter ce quatrième composant pour le multiplier par le <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span> matrice, qui est une matrice 4x4. Cette multiplication projettera la position mondiale du sommet en coordonnées d&#39;écran.</li><li> Enfin, nous transmettons la couleur du sommet et la coordonnée de texture au <span class="notranslate">shader</span> fragment via nos variables variables.</li></ul><p> Ce <span class="notranslate">shader</span> doit être laissé seul si vous ne prévoyez pas de jouer avec les positions des sommets et il ne sera utilisé dans aucun des exemples donnés ci-dessous car tous les effets affichés seront créés en utilisant le <span class="notranslate">shader</span> fragment.</p><p> Jetons un coup d&#39;œil au <span class="notranslate">shader</span> fragment maintenant:</p><p class="code">// Passthrough Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
    <br/> void main()<br/> {
    <br/>     gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br/> }
  </p><p> Comme expliqué précédemment, l&#39;idée derrière un <span class="notranslate">shader</span> fragment est de renvoyer la couleur du pixel actuel. Cela se fait en affectant la variable <span class="inline">gl_FragColor</span> la valeur de couleur finale. Le <span class="inline">texture2D</span> fonction prend une texture et un <span class="inline">vec2</span> avec les coordonnées UV que vous souhaitez archiver dans cette texture, ce qui renvoie un <span class="inline">vec4</span> avec la couleur. Dans le <span class="notranslate">shader</span>, tout ce que nous faisons est de saisir la couleur de la texture dans la coordonnée de ce pixel et de la multiplier par la couleur du sommet associé à ce pixel.</p><p> Maintenant que nous avons notre premier <span class="notranslate">shader</span>, tout ce que nous avons à faire pour le tester est de créer un objet et de lui attribuer un sprite, puis dans l&#39; <strong>événement Draw</strong> de l&#39;objet, vous définissez le <span class="notranslate">shader</span> comme ceci:</p><p class="code">// Draw Event<br/> shader_set(shdrColorOverlay);
    <br/> draw_self();
    <br/> shader_reset();
  </p><p> Chaque appel que nous faisons entre <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline"><span class="notranslate">shader</span>_set ()</a> et <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline"><span class="notranslate">shader</span>_reset ()</a> aura le <span class="notranslate">shader</span> appliqué. Ici, nous dessinons le sprite objet avec notre <span class="notranslate">shader</span> passthrough:</p><p><img alt="Drawing Sprite Using Passthough Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_PassThrough.gif" /> Comme vous l&#39;avez peut-être deviné, cela ne change rien visuellement, car il s&#39;agit d&#39;un simple <span class="notranslate">shader</span> pass-through. Cependant, les sections ci-dessous décrivent quelques étapes simples que vous pouvez suivre pour modifier cela et changer la façon dont le sprite sera dessiné. Chacune des sections montre un <span class="notranslate">shader</span> différent que vous pouvez créer et utiliser dans vos projets, en expliquant les étapes nécessaires pour les créer et pourquoi nous faisons les choses comme nous sommes.</p><p></p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="notranslate">Shader</span> superposition de couleur</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> Nous pouvons <span class="notranslate">shader</span> base pour faire quelque chose de différent. Nous ne toucherons pas la partie vertex shdaer, et n&#39;éditerons que le fragment <span class="notranslate">shader</span>, et pour commencer, nous allons faire une opération très simple, qui consiste à faire <span class="notranslate">shader</span> avec la couleur rouge. Nous allons faire cela en changeant simplement le <span class="inline">gl_FragColor</span> être rouge., comme ceci:</p><p class="code">// Color Overlay Fragment Shader<br/> void main()<br/> {
      <br/>     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br/> }
    </p><p class="dropspot"> Cela nous donnera le résultat suivant:</p><p class="dropspot"><img alt="Initial Colour Overlay Block" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Block.gif" /> Pas exactement ce à quoi nous nous attendions! Ce que nous devons nous rappeler, c&#39;est que chaque sprite est en fin de compte un rectangle, donc à moins que nous ne considérions la transparence - ce que nous n&#39;avons pas - c&#39;est le résultat que nous obtiendrons.</p><p class="note"> <strong>REMARQUE</strong>: dans l&#39;image ci-dessus, le rectangle change de taille car le sprite de base a eu l&#39;espace «vide» autour de lui rogné automatiquement lorsqu&#39;il a été placé sur la page de texture par <span class="notranslate">GameMaker</span>, de sorte que chaque image d&#39;animation les triangles qui le composent sont de tailles différentes pour s&#39;adapter à la taille recadrée du cadre. Si vous désactivez cette option, vous aurez simplement un carré rouge immobile à l&#39;écran.</p><p class="dropspot"> Ci-dessus, nous avons mentionné le <span class="inline">texture2D</span> fonction, et nous l&#39;utiliserons pour saisir la couleur du pixel sur lequel nous travaillons et en obtenir la transparence. La valeur de retour de est<span class="inline">texture2D</span> est un <span class="inline">vec4</span>, où les composants sont le rouge, le vert, le bleu et l&#39;alpha, dans cet ordre. On peut accéder au canal alpha soit en mettant un point suivi d&#39;un <span class="inline">a</span> ou un <span class="inline">w</span> après le nom de la variable. Cela correspond respectivement à RGBA et XYZW.</p><p class="dropspot"> Voici le code mis à jour:</p><p class="code">// Color Overlay Fragment Shader<br/> varying vec2 v_vTexcoord;<br/>
      <br/> void main()<br/> {
      <br/>     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br/>     gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br/> }
    </p><p class="dropspot"> Nous attribuons maintenant un nouveau <span class="inline">vec4</span> à <span class="inline">gl_FragColor</span>, où le canal rouge est maximal, les canaux vert et bleu sont à zéro et le canal alpha est le même que la texture d&#39;origine. La sortie ressemble à ceci:</p><p class="dropspot"><img alt="Overlay Shader Making Sprite Red" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay.gif" /> Voilà ce que nous recherchions! Nous avons remplacé la couleur de chaque pixel par du rouge, mais nous avons conservé le canal alpha intact.</p><p class="dropspot"> Devoir changer le <span class="notranslate">shader</span> chaque fois que nous voulons utiliser une couleur différente n&#39;est pas une bonne idée, d&#39;autant plus que nous aurions besoin d&#39;un <span class="notranslate">shader</span> séparé pour chaque couleur que nous voulons. Au lieu de cela, nous transmettrons les informations de couleur au <span class="notranslate">shader</span> utilisant un <strong>uniforme</strong>. Pour ce faire, nous devons d&#39;abord obtenir un <strong>pointeur</strong> vers l&#39;uniforme. Nous allons faire cela dans l&#39; <strong>événement Create</strong> de notre objet qui a le sprite en ajoutant:</p><p class="code">// Create Event<br/> _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br/> _color    = [1.0, 1.0, 0.0, 1.0];</p><p class="dropspot"> Tout ce que nous devons faire est d&#39;appeler <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline"><span class="notranslate">shader</span>_get_uniform ()</a> pour obtenir un pointeur vers l&#39;uniforme. Les paramètres que nous devons passer sont le <span class="notranslate">shader</span> (sans guillemets car nous voulons passer l&#39;ID que <span class="notranslate">GameMaker</span> génère pour nous) et le nom de la variable uniforme à l&#39;intérieur du <span class="notranslate">shader</span>, cette fois sous forme de chaîne. Ce nom doit correspondre exactement à celui <span class="notranslate">shader</span> dans le code du shader pour que cela fonctionne. Nous avons également ajouté une variable de couleur afin que nous puissions la modifier au <span class="notranslate">runtime</span> de l&#39;exécution et qu&#39;elle se souvienne de nos modifications.</p><p class="dropspot"> Maintenant, le code de notre événement draw changera légèrement pour passer la variable uniforme.</p><p class="code">// Draw Event<br/> shader_set(shdrColorOverlay);
      <br/> shader_set_uniform_f_array(_uniColor, _color);<br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> C&#39;est le même code qu&#39;avant, mais avant de dessiner quoi que ce soit, nous devons transmettre toutes les valeurs uniformes au <span class="notranslate">shader</span>. Dans ce cas, nous transmettons la couleur sous la forme d&#39;un tableau de flottants. Quant au <span class="notranslate">shader</span>, nous allons le changer pour inclure l&#39;uniforme et l&#39;utiliser, donc il devient:</p><p class="code">// Color Overlay Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> uniform vec4 u_color;<br/> void main()<br/> {
      <br/>     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br/>     gl_FragColor = vec4(u_color.rgb, texColor.a);<br/> }
    </p><p class="dropspot"> Nous déclarons une variable avec le même nom que dans le <span class="notranslate">shader</span> create (<span class="inline">u_color</span> ) et nous le passons comme les trois premiers composants du <span class="inline">gl_FragColor</span> vecteur, profitant du swizzling. Si nous compilons à nouveau, nous devrions voir ceci:</p><p class="dropspot"><img alt="Overlay Shader Making Sprite Yellow" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Yellow.gif" /> Maintenant, le <span class="notranslate">shader</span> est beaucoup plus utile et réutilisable. C&#39;est à vous d&#39;ajouter plus de fonctionnalités si vous en avez besoin pour définir la couleur (en utilisant la variable <span class="inline">_color</span> ) pendant l&#39; <span class="notranslate">runtime</span>.</p><p></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="notranslate">Shader</span> noir et blanc</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> <span class="notranslate">shader</span> noir et blanc est un excellent moyen d&#39;en savoir plus sur le fonctionnement des <span class="notranslate">shaders</span>, et de nombreux débutants commencent par essayer de le faire, car conceptuellement, c&#39;est assez simple: obtenir chaque pixel et lui attribuer une nuance de gris. Mais est-ce simple? Pas assez...</p><p class="dropspot"> Lorsque vous utilisez la couleur RVB, si les trois composants ont la même valeur, nous obtenons une teinte grise. L&#39;approche naïve pour créer un <span class="notranslate">shader</span> pour utiliser cette idée serait d&#39;ajouter les trois canaux de couleur (rouge, vert et bleu), puis de le diviser par trois. Après cela, vous avez attribué la valeur aux trois canaux, créant ainsi une teinte grise. Voici à quoi ressemble <span class="notranslate">shader</span></p><p class="code">// Black and white fragment shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
      <br/> void main()<br/> {
      <br/>     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br/>     float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br/>     gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br/> }
    </p><p class="dropspot"> Une chose que vous avez peut-être remarqué est que dans le <span class="inline">gl_FragColor</span> code, nous multiplions le<span class="inline">vec4</span> avec quelque chose qui s&#39;appelle <span class="inline">v_vColour</span>. Il s&#39;agit d&#39;une variable passée par le vertex <span class="notranslate">shader</span> qui nous indique la couleur du sommet associé à ce pixel. C&#39;est toujours une bonne idée de multiplier votre couleur calculée finale par la couleur des sommets. Dans la plupart des cas, cela ne fera rien, mais si vous avez changé la couleur du sommet dans <span class="notranslate">GML</span>, cela reflétera cela (en utilisant des fonctions telles que <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> ou <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> pour changer le <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a> ).</p><p class="dropspot"> Quant au tirage au sort, c&#39;est assez simple puisque nous n&#39;avons pas d&#39;uniforme à passer:</p><p class="code">// Draw Event<br/> shader_set(shdrBlackAndWhite);
      <br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> Compilons et voyons ce que nous avons.</p><p class="dropspot"><img alt="Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite.gif" /> Cela a déjà l&#39;air génial, non? Eh bien, oui et non... il existe une solution plus «correcte», puisqu&#39;au lieu d&#39;ajouter les composants et de diviser par trois, nous multiplions chaque composant par les valeurs NTSC standard pour le noir et blanc. Voici le code du <span class="notranslate">shader</span></p><p class="code">// Black and white fragment shader<br/> varying vec2 v_vTexcoord;<br/>
      <br/> void main()<br/> {
      <br/>     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br/>     float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br/>     gl_FragColor = vec4(gray, gray, gray, texColor.a);<br/> }
    </p><p class="dropspot"> Nous utilisons le produit scalaire comme un raccourci pour multiplier chaque composant de <span class="inline">texColor</span> avec les poids corrects, puis additionnez-les. Si vous n&#39;êtes pas familier avec le produit scalaire, c&#39;est essentiellement ce qui se passe:</p><p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p><p class="dropspot"> En fin de compte, cela semble très similaire, mais c&#39;est techniquement plus correct.</p><p class="dropspot"><img alt="Corrected Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite_Improved.gif" /></p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="notranslate">Shader</span> arc-en-ciel</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot">Notre dernier <span class="notranslate">shader</span> est amusant et peut être utilisé pour ajouter de la vie au texte, aux boutons et à d&#39;autres choses. Nous commencerons simplement et ajouterons des fonctionnalités progressivement, car ce <span class="notranslate">shader</span> est hautement personnalisable. Il y a beaucoup à couvrir pour celui-ci, donc si vous vous sentez un peu perdu ou confus, veuillez revenir en arrière et relire certaines des sections ci-dessus.</p><p class="dropspot"> La première chose que nous voulons faire est de colorer les pixels avec chaque teinte, en fonction de la position horizontale du pixel. La façon de faire est de définir la position x comme la teinte, puis de passer du format HSV (teinte, saturation, luminosité) au format RVB (rouge, vert et bleu). Pour cela, nous devrons écrire une fonction d&#39;assistance dans notre <span class="notranslate">shader</span> fragment qui prend les valeurs HSV et renvoie un vecteur RVB. Nous utiliserons une seule fonction qui fait cela sans avoir besoin d&#39;aucune <span class="inline">if</span> instructions, car l&#39;utilisation de conditions dans <span class="notranslate">shader</span> code de <span class="notranslate">shaders</span> <em>très</em> lents et doit être évitée.</p><p class="dropspot"> Voici à quoi <span class="notranslate">shader</span> à ce stade:</p><p class="code">// Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
      <br/> vec3 hsv2rgb(vec3 c) <br/> {
      <br/>     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br/>     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br/>     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br/> }
      <br/>
      <br/> void main()<br/> {
      <br/>     vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br/>     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br/>     gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br/> }
    </p><p class="dropspot"> Il se passe un peu plus ici que dans les exemples précédents, mais la plupart devraient être assez évidents pour vous maintenant. Premièrement, il y a notre <span class="inline">hsv2rgb</span> fonction, qui prend un <span class="inline">vec3</span> avec notre couleur HSV et renvoie un autre <span class="inline">vec3</span> avec notre conversion RVB. Dans la fonction principale, nous commençons par créer notre couleur HSV, où la teinte est notre position x, et nous laisserons la saturation et la luminosité à 1.0 pour le moment. Ensuite, nous obtenons l&#39;alpha de la texture afin qu&#39;il ne colore que notre personnage de sprite et non le rectangle de sprite entier (comme nous l&#39;avons fait dans l&#39;exemple de superposition de couleurs, ci-dessus). Enfin, nous définissons notre couleur Fragment comme étant notre couleur HSV convertie en RVB avec l&#39;alpha, multipliée par la couleur du sommet (bonne pratique pour toujours le faire).</p><p class="dropspot"> Quant à notre code de tirage, il est trivial pour le moment:</p><p class="code">// Draw Event<br/> shader_set(shdrRainbow);
      <br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> Voyons ce que nous avons:</p><p class="dropspot"><img alt="Initial Rainbow Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay.gif" /> Nous sommes proches de ce que nous voulons, mais il y a un problème: nous ne voyons pas toutes les couleurs à la fois dans chaque image de l&#39;animation et les couleurs semblent changer de manière aléatoire. La raison en est que nous avons supposé que <span class="inline">v_vTexcoord</span> nous a donné les coordonnées du sprite, commençant dans le coin supérieur gauche (0,0) et se terminant dans le coin inférieur droit (1,1), qui est standard dans les <span class="notranslate">shaders</span>. Cependant, pour l&#39;optimisation, <span class="notranslate">GameMaker</span> rassemble autant de textures qu&#39;il peut en <a href="../Settings/Texture_Information/Texture_Pages.htm">contenir dans ce qu&#39;on appelle une page de texture,</a> et à cause de cela, voici à quoi ressemble notre texture:</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Texture.png" /> Comme expliqué ci-dessus, <span class="inline">v_vTexcoord</span> nous donne les coordonnées absolues du sprite dans toute cette page de texture, mais ce que nous voulons, c&#39;est une valeur de 0,0 à 1,0 qui ne couvre que notre sprite actuel. Ce processus est appelé <strong>normalisation</strong> (obtenir une valeur et la traduire dans une plage de 0 à 1). Pour normaliser nos valeurs horizontales, nous devons connaître les valeurs de x0 et x1 dans l&#39;image ci-dessus. Heureusement, <span class="notranslate">GameMaker</span> a une fonction qui nous donne l&#39;emplacement de chaque coin de notre sprite dans la page de texture. Tout d&#39;abord, nous devons accéder à l&#39;événement Create et créer un uniforme pour transmettre ces données au <span class="notranslate">shader</span>:</p><p class="code">// Create Event<br/> _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p><p class="dropspot"> Et nous modifions l&#39;événement draw pour obtenir les valeurs, puis les transmettons au <span class="notranslate">shader</span>:</p><p class="code">// Draw Event<br/> shader_set(shdrRainbow);
      <br/> var uv = sprite_get_uvs(sprite_index, image_index);<br/> shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> La fonction <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> prend un sprite et un index, et il renvoie un tableau avec des tonnes d&#39;informations, telles que les coordonnées de chaque coin, combien de pixels ont été rognés pour l&#39;optimiser, etc. Nous nous intéressons à deux de ces valeurs: les coordonnées gauche et droite du sprite, qui sont stockés dans <span class="inline">uv[0]</span> et <span class="inline">uv[2]</span> respectivement. Dans le <span class="notranslate">shader</span> fragment, nous utiliserons ces valeurs maintenant pour calculer la position horizontale normalisée comme ceci:</p><p class="code">// Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
      <br/> uniform vec2 u_uv;<br/>
      <br/> vec3 hsv2rgb(vec3 c) <br/> {
      <br/>     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br/>     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br/>     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br/> }
      <br/>
      <br/> void main()<br/> {
      <br/>     float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br/>     vec3 col = vec3(pos, 1.0, 1.0);<br/>     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br/>     gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br/>      }
    </p><p class="dropspot"> Ici, nous ajoutons la variable uniforme en haut du fichier avec le même nom que nous avons utilisé dans la création d&#39;événement. Ensuite, nous calculons la position horizontale normalisée en traduisant notre courant <span class="inline">x</span> coordonnée à l&#39;origine ( <span class="inline">v_vTexcoord.x - u_uv[0]</span> ) puis nous le divisons par la largeur du sprite pour faire la plage de 0 à 1 (<span class="inline">u_uv[1] - u_uv[0]</span> ).</p><p class="dropspot"> Le résultat est:</p><p class="dropspot"><img alt="Rainbow Overlay Shader Improved" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Improved.gif" /> On y va! C&#39;est exactement ce que nous voulions. Nous pouvons voir toutes les couleurs du spectre à l&#39;intérieur de notre sprite.</p><p class="dropspot"> Vous serez peut-être satisfait de cela, mais nous pouvons nous amuser encore plus avec ce <span class="notranslate">shader</span>. Et si nous ajoutions un décalage aux couleurs basé sur le temps pour produire du mouvement? Pour ce faire, nous aurons besoin de deux variables supplémentaires pour la <strong>vitesse</strong> et le <strong>temps</strong>. Nous aurons également besoin de deux uniformes supplémentaires, un pour chacune des nouvelles variables, de sorte que l&#39;événement Create devienne:</p><p class="code">// Create Event<br/> _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br/> _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br/> _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br/> _time  = 0;<br/>      _speed = 1.0;</p><p class="dropspot"> Nous devons également augmenter le temps à chaque image, donc dans l&#39;événement Step, nous ajoutons:</p><p class="code">// Step Event<br/> _time += 1 / room_speed;</p><p class="dropspot"> Passons maintenant à l&#39;événement draw pour envoyer ces uniformes au <span class="notranslate">shader</span>:</p><p class="code">// Draw Event<br/> shader_set(shdrRainbow);
      <br/> var uv = sprite_get_uvs(sprite_index, image_index);<br/> shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br/> shader_set_uniform_f(_uniSpeed, _speed);<br/> shader_set_uniform_f(_uniTime, _time);<br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> Enfin, nous reviendrons à notre <span class="notranslate">shader</span> pour utiliser réellement ces variables maintenant. Ce que nous allons faire, c&#39;est multiplier la vitesse avec le temps et l&#39;ajouter à la position, comme ceci:</p><p class="code">// Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
      <br/> uniform vec2 u_uv;<br/> uniform float u_speed;<br/> uniform float u_time;<br/>
      <br/> vec3 hsv2rgb(vec3 c) <br/> {
      <br/>     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br/>   vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br/>     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br/> }
      <br/>
      <br/> void main()<br/> {
      <br/>     float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br/>     vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br/>     float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br/>     gl_FragColor = v_vColour * vec4(hsv2rgb(col),
      alpha);
      <br/> }
    </p><p class="dropspot"> Si vous avez tout fait correctement, vous devriez voir quelque chose comme ceci:</p><p class="dropspot"><img alt="Rainbow Shader Overlay Moving With Time" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Final.gif" /> Pour finir ce <span class="notranslate">shader</span>, nous ajouterons quelques uniformes supplémentaires pour le personnaliser encore plus. Les deux premiers sont de contrôler la saturation et la luminosité. La prochaine que nous appellerons &quot;section&quot; et sa fonction est de permettre à l&#39;utilisateur de passer un nombre entre zéro et un pour déterminer quel pourcentage du spectre entier que nous voyons à la fois. Enfin, nous ajouterons une variable appelée &quot;mix&quot;, qui précisera combien nous voulons mélanger la <span class="notranslate">shader</span> avec la couleur de la texture d&#39;origine (1.0 est tout arc-en-ciel, 0.0 est toute texture). Comme toujours, commençons par ajouter les variables à l&#39;événement Create:</p><p class="code">// Create Event<br/> _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br/> _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br/> _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br/> _uniSection
         = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br/> _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br/> _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br/> _uniMix        =
      shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br/>
      <br/> _time  = 0;<br/> _speed = 1.0;<br/> _section = 0.5;<br/> _saturation = 0.7;<br/> _brightness = 0.8;<br/> _mix = 0.5;</p><p class="dropspot"> Notre événement de tirage au sort change pour inclure ces uniformes comme ceci:</p><p class="code">// Draw Event<br/> shader_set(shdrRainbow);
      <br/> var uv = sprite_get_uvs(sprite_index, image_index);<br/> shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br/> shader_set_uniform_f(_uniSpeed, _speed);<br/> shader_set_uniform_f(_uniTime, _time);<br/> shader_set_uniform_f(_uniSaturation, _saturation);<br/>      shader_set_uniform_f(_uniBrightness, _brightness);<br/> shader_set_uniform_f(_uniSection, _section);<br/> shader_set_uniform_f(_uniMix, _mix);<br/> draw_self();
      <br/> shader_reset();
    </p><p class="dropspot"> En ce qui concerne le <span class="notranslate">shader</span>, nous devons passer la saturation et la luminosité à la couleur, ce qui affectera la couleur générée par notre fonction d&#39;assistance. La section doit être multipliée par notre position pour réduire la portée. Nous allons également saisir toute la couleur de la texture, afin de pouvoir calculer notre couleur finale en mélangeant la couleur de la texture avec la conversion RVB de notre couleur. Le dernier paramètre de la fonction de mixage détermine la quantité de la deuxième couleur que nous voulons ajouter. Voici notre code de <span class="notranslate">shader</span></p><p class="code">// Fragment Shader<br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
      <br/> uniform vec2 u_uv;<br/> uniform float u_speed;<br/> uniform float u_time;<br/> uniform float u_saturation;<br/> uniform float u_brightness;<br/> uniform float u_section;<br/> Uniform float u_mix;<br/>
      <br/> vec3 hsv2rgb(vec3 c) <br/> {
      <br/>     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br/>     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br/>     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br/> }
      <br/>
      <br/> void main()<br/> {
      <br/>     float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br/>     vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br/>     <br/>     vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br/>        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br/>     <br/>     gl_FragColor = v_vColour * finalCol;<br/> }
    </p><p class="dropspot"> Et notre résultat final est le suivant!</p><p class="dropspot"><img alt="Rainbow Shader Final" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Final.gif" /></p><p class="dropspot"></p></div><p></p><p> C&#39;est la fin de ce petit guide et vous devriez maintenant avoir une meilleure compréhension du fonctionnement des <span class="notranslate">shaders</span> et de certaines des utilisations auxquelles ils peuvent être faits. Vous devriez prendre votre temps pour jouer avec les <span class="notranslate">shaders</span> vous avez créés en suivant ce guide et essayer de les expérimenter pour faire d&#39;autres choses - que diriez-vous de créer un <span class="notranslate">shader</span> flou ou un <span class="notranslate">shader</span> qui crée un écran monochrome de style gameboy? - puisque les <span class="notranslate">shaders</span> sont un outil incroyablement puissant pour ajouter de la complexité visuelle et du style à vos jeux.</p><p></p><p class="note"> <span class="notranslate">YoYo Games</span> tient à remercier <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> et <strong><span class="notranslate">Amazon</span></strong> de nous avoir permis de reproduire ce guide. Vous pouvez trouver la version originale sur le <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">blog des développeurs <span class="notranslate">Amazon</span></a>.</p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="Additional_Information.htm">Informations complémentaires</a></div><div style="float:right"> Suivant: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Guide des primitives et de la construction de sommets</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>