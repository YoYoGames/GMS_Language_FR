<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guide des primitives et de la construction de sommets</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page qui explique comment configurer et utiliser les primitives et les tampons de sommets" />
  <meta name="rh-index-keywords" content="Guide des primitives et de la construction de sommets" />
  <meta name="search-keywords" content="bâtiment primitif,primitives,sommet,tampons de sommets,formats de sommets" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Guide des primitives et de la construction de sommets</h1><p> Ce guide explique brièvement comment créer et utiliser des <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">primitives à l&#39;</a> aide de <strong>formats de</strong> sommets et de <strong>tampons de sommets personnalisés</strong>.</p><p> En général, lorsque vous commencez à travailler avec la 3D, les effets spéciaux, les processus de dessin complexes ou les <span class="notranslate">shaders</span> vous n&#39;avez pas à vous soucier trop du format de sommet utilisé, car <span class="notranslate">GameMaker Studio 2</span> configurera et transmettra automatiquement les <a class="glossterm"
      data-glossterm="sommet" href="#">données de sommet</a> pour vous. Cependant, il est parfois nécessaire de créer vos propres données de sommets et de les formater en conséquence, en particulier lorsque vous avez besoin d&#39;augmenter la vitesse ou que vous souhaitez transmettre des informations supplémentaires. Par exemple, le format de sommet standard comprend une position 3D x, y, z, une couleur (avec alpha) et des coordonnées de texture UV, qui, si vous le créez vous-même, ressembleraient à ceci:</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p> Cependant, si vous n&#39;utilisez (par exemple) qu&#39;un <span class="notranslate">shader</span> pour manipuler la position du sommet, il n&#39;est pas nécessaire de passer par les données de couleur ou de texture. Dans ce cas, vous créeriez votre propre format comme suit:</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> my_format = vertex_format_end();</p><p> Au total, il existe cinq attributs de sommet différents que vous pouvez utiliser lors de la définition d&#39;un format de sommet:</p><ul class="colour"><li> Couleur</li><li> Normal</li><li> Positionner</li><li> Position 3D</li><li> Coordonnée de la texture</li></ul><p> En général, vous devez <em>toujours</em> fournir une position ou une position 3D dans le cadre du format, mais toutes les autres sont facultatives.</p><p> Vous devez noter qu&#39;une fois que vous avez créé votre format de sommet, l&#39;ordre dans lequel vous avez défini les attributs de sommet <i>doit être respecté</i> lors de la construction de vos <strong>primitives</strong>. Donc, si vous avez défini un format de sommet comme coordonnées de position, de couleur et de texture, <b>vous <i>devez</i> ajouter ces attributs à la primitive dans le même ordre, sinon vous obtiendrez une erreur</b>. Notez également que comme toute autre ressource dynamique, un format de sommet nécessite de la mémoire et doit donc être supprimé lorsqu&#39;il n&#39;est pas nécessaire à l&#39;aide de la fonction <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_delete.htm"><tt>vertex_format_delete()</tt></a>.</p><p> Toutes les primitives que vous créez sont conservées dans un <b>tampon de sommets</b>. Celui-ci doit être créé au préalable, puis référencé par les fonctions utilisées pour construire votre primitive. Le tampon de vertex peut être réutilisé autant de fois que nécessaire pour créer différentes primitives, ou il peut être «gelé» pour maintenir un type primitif spécifique pendant la durée de votre jeu ou niveau (ce qui est l&#39;approche la plus rapide, donc si vous savez qu&#39;une primitive que vous construisez ne changera pas, vous devez toujours utiliser cette option).</p><p> Un exemple d&#39;une primitive de triangle unique en cours de construction est illustré dans le code suivant:</p><p class="code">// CREATE EVENT<br/> v_buff = vertex_create_buffer();<br/> vertex_begin(v_buff, global.my_format);<br/> vertex_position(v_buff, 10, 10);<br/> vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 0, 0);<br/> vertex_position(v_buff, 110, 10);<br/>    vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 1, 0);<br/> vertex_position(v_buff, 110, 110);<br/> vertex_colour(v_buff, c_white, 1);<br/> vertex_texcoord(v_buff, 1, 1);<br/> vertex_end(v_buff);
    <br/>
    <br/> // DRAW EVENT<br/> var tex = sprite_get_texture(spr_Background, 0);<br/> shader_set(shd_shimmer);
    <br/> vertex_submit(v_buff, pr_trianglelist, tex);<br/> shader_reset();
  </p><p> Ici, nous avons d&#39;abord créer notre tampon de sommets dans l&#39;événement de création de l&#39;instance, puis nous commençons la définition des différents sommets qui composent notre primitive de triangle, en donnant la position, la couleur et la coordonnée UV de texture pour chacun des trois points que nous voulons utiliser. Nous terminons ensuite la définition de sommet, et nous savons que le tampon de sommet avec ces données de sommet est stocké dans la variable &quot;v_buff&quot;.</p><p class="note"> <strong>REMARQUE</strong>: Si le contenu du tampon doit être mis à jour en permanence, le tampon sera créé, compte tenu des données de sommet, puis détruit à nouveau - après avoir été dessiné - le tout dans la même étape.</p><p> Nous dessinons ensuite le contenu du tampon de vertex dans l&#39;événement Draw à l&#39;aide d&#39;un <span class="notranslate">shader</span>. C&#39;est un exemple très simple, et c&#39;est essentiellement la façon dont <span class="notranslate">GameMaker Studio 2</span> fonctionne en interne, c&#39;est-à-dire: lorsque vous dessinez un sprite, <span class="notranslate">GameMaker</span> crée un tampon de sommets avec quatre sommets créant deux triangles (qui forment un carré, également appelé &quot;quad&quot;), et textures ces deux triangles avec l&#39;image du sprite. Lorsque nous dessinons ce sprite, nous soumettons le tampon de sommets et son contenu est dessiné à l&#39;écran.</p><p> Vous remarquerez que lorsque nous soumettons le tampon de vertex pour le dessin, nous fournissons un type primitif. Le type de primitive que vous utilisez peut être un point, une liste de lignes ou une bande, ou une liste ou une bande de triangles, mais vous n&#39;êtes <i>pas</i> autorisé à utiliser des ventilateurs de triangle car la plupart du matériel mobile n&#39;acceptera pas ce type de primitive. N&#39;oubliez pas de formater correctement votre tampon de sommets pour le type de primitive qui va être utilisé pour le dessiner. Par exemple, dessiner une primitive à deux triangles sous forme de liste de triangles nécessite 6 points, mais en tant que bande triangulaire, il ne nécessite que 4 points. Le type que vous utilisez dépend de vous et dépendra de ce que vous souhaitez dessiner et de l&#39;effet que vous souhaitez obtenir.</p><p> Un dernier point important à noter lorsque vous utilisez vos propres tampons de sommets de cette manière est la façon dont cela affecte les lots de sommets envoyés au GPU. Lorsque vous créez un tampon de vertex, vous créez le niveau le plus bas de données graphiques. Ainsi, lorsque vous dessinez, tout ce qui se passe est que <span class="notranslate">GameMaker Studio 2</span> envoie votre tampon directement à la carte graphique. Pour cette raison, si vous voulez un meilleur traitement par lots, vous devez le résoudre vous-même et stocker les éléments que vous souhaitez regrouper dans le même tampon.</p><p> Comme nous l&#39;avons déjà mentionné ci-dessus, les formats de sommets sont construits en utilisant ensemble les 5 types d&#39;attributs suivants (ajoutés via le <tt>vertex_format_add_*</tt> fonction):</p><ul class="colour"><li> Couleur</li><li> Normal</li><li> Positionner</li><li> Position 3D</li><li> Coordonnée de la texture</li></ul><p> Dans le <span class="notranslate">shader</span> GLSL ES, ces types sont reconnus à l&#39;aide des 4 attributs suivants:</p><ul class="colour"><li> Couleur</li><li> Normal</li><li> Positionner</li><li> Coordonnée de la texture</li></ul><p> Maintenant, cela peut sembler étrange car il semble que nous puissions spécifier plus de types d&#39;attributs dans notre format de vertex que nous ne le pouvons dans le <span class="notranslate">shader</span> vertex. Cependant, dans le <span class="notranslate">shader</span> <i>position</i> et <i>la position 3D</i> sont traitées comme le <em>même</em> attribut, sauf que la <i>position</i> ne devrait avoir que les coordonnées «x» et «y» alors que <i>la position 3D</i> a les coordonnées «x», «y» et «z». Alors, comment mappez-vous ce qui est dans votre format de sommet à la façon dont vous définissez les attributs dans votre <span class="notranslate">shader</span> ? Commençons par regarder un ensemble typique d&#39;attributs du <span class="notranslate">shader</span> par défaut:</p><p></p><p class="code">attribute vec3 in_Position;        // (x,y,z)<br/> //attribute vec3 in_Normal;        // (x,y,z) unused in this shader.<br/> attribute vec4 in_Colour;          // (r,g,b,a)<br/> attribute vec2 in_TextureCoord;    // (u,v)</p><p> Et voici un morceau de code qui met en place un format de sommet compatible avec ce <span class="notranslate">shader</span>:</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p> Maintenant, comment l&#39; <span class="notranslate">shader</span> est-il mis en correspondance avec le type de format de sommet? C&#39;est juste basé sur la convention de dénomination:</p><ul class="colour"><li> &quot;in_Position&quot; correspond à <tt>vertex_format_add_position / _3d()</tt></li><li><tt>&quot;in_Colour&quot; maps to <tt>vertex_format_add_colour()</tt></tt></li><li><tt><tt>&quot;in_TextureCoord&quot; maps to <tt>vertex_format_add_textcoord()</tt></tt>
      </tt></li></ul><p><tt><tt><tt></tt></tt>
    </tt> Maintenant, les choses deviennent plus délicates lorsque vous avez plusieurs attributs du même type, mais les choses sont toujours basées sur la même convention de dénomination. Nous allons maintenant chercher à fournir des <b>coordonnées de</b> <b>couleur</b> et de texture supplémentaires, car il ne peut y avoir <b>qu&#39;un</b> <b>seul</b> attribut Position et un attribut Normal dans le <span class="notranslate">shader</span> ou de sommet, mais il <em>peut</em> y avoir plusieurs attributs de couleur ou de texture.</p><p> Lors de l&#39;ajout d&#39;attributs de couleur supplémentaires à votre <span class="notranslate">shader</span>, un nombre doit être ajouté à la fin de l&#39; <span class="notranslate">shader</span> pour indiquer à quelle entrée particulière dans le format de sommet l&#39;attribut correspond. Voici un exemple - d&#39;abord le format des sommets:</p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p> Et maintenant les attributs de <span class="notranslate">shader</span></p><p class="code">attribute vec3 in_Position;      // (x,y,z)<br/> attribute vec4 in_Colour0;       // (r,g,b,a)<br/> attribute vec4 in_Colour1;       // (r,g,b,a)<br/> attribute vec2 in_TextureCoord;  // (u,v)</p><p> Dans ce cas <tt>in_Colour0</tt> cartes au premier <tt>vertex_format_add_colour()</tt> et <tt>in_Colour1</tt> correspond à la seconde.</p><p> Les coordonnées de texture sont gérées légèrement différemment de la couleur. En gros, tout ce qui n&#39;est pas appelé <tt>in_Position</tt>, <tt>in_Normal</tt> ou l&#39;un des <tt>in_Colour[0 ... ]</tt> Les attributs sont traités comme une coordonnée de texture. L&#39;ordre dans lequel ils sont définis, dans la liste des attributs du <span class="notranslate">shader</span>, indique à quel attribut dans le format de sommet ils sont mappés. Consultez l&#39;exemple <span class="notranslate">GML</span></p><p class="code">vertex_format_begin();<br/> vertex_format_add_position_3d();
    <br/> vertex_format_add_colour();
    <br/> vertex_format_add_textcoord();
    <br/> vertex_format_add_textcoord();
    <br/> vertex_format_add_textcoord();
    <br/> my_format = vertex_format_end();</p><p> Et le <span class="notranslate">shader</span> ressemblerait à ceci:</p><p class="code">attribute vec3 in_Position;      // (x,y,z)<br/> attribute vec4 in_Colour;        // (r,g,b,a)<br/> attribute vec2 in_myTexcoord;    // (u,v)<br/> attribute vec2 in_TextureCoord;  // (u,v)<br/> attribute vec2 in_Something;     // (u,v)</p><p> Dans cet exemple, <tt>in_myTexcoord</tt>, <tt>in_TextureCoord</tt> et <tt>in_Something</tt> mapper aux trois attributs de coordonnées de texture successifs définis dans le format de sommet.</p><p> Vous pouvez trouver une liste complète de toutes les fonctions requises pour créer des formats de sommets, des tampons de sommets et des primitives à partir de la page suivante:</p><ul class="colour"><li> <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Primitives et formats de sommets</a> </li></ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="Additional_Information.htm">Informations complémentaires</a></div><div style="float:right"> Suivant: <a href="Guide_To_Using_Blendmodes.htm">Guide d&#39;utilisation de Blendmodes</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Primitive Building
Vertex Formats
Vertex Buffers
-->
  <!-- TAGS
using_primitives_vertex_buffers
-->
</body>
</html>