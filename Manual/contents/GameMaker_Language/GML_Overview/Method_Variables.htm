<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Variables de la méthode</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Page outlining the use of Method Variables" />
  <meta name="rh-index-keywords" content="Method Variables" />
  <meta name="search-keywords" content="Method Variables,methods,method" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Variables de la méthode</h1>
  <p>Une variable de méthode est essentiellement une variable à laquelle une fonction a été attribuée, ce qui permet de &quot;lier&quot; la fonction à une instance et d'utiliser la variable pour faire référence à la fonction, tout comme vous utilisez un <a href="Runtime_Functions.htm">nom de<span class="notranslate">fonction</span></a> d'exécution <a href="Runtime_Functions.htm">pour</a> faire référence à une <span class="notranslate">fonction</span> GML intégrée <span class="notranslate">.</span> La variable utilisée peut avoir une portée <em>locale</em>, d'<em>instance</em> ou <em>globale</em> (voir <a href="Variables_And_Variable_Scope.htm">ici</a> pour plus d'informations sur la portée des variables).</p>
  <p>La syntaxe pour créer une variable de méthode est la suivante :</p>
  <p class="code">&lt;variablename&gt; = function(&lt;parameter1&gt;, &lt;parameter2&gt;, etc... )<br> {
    <br> &lt;déclaration1&gt; ;<br> &lt;déclaration1&gt; ;<br>...<br> }
  </p>
  <p>ou</p>
  <p class="code">fonction &lt;variablename&gt;(&lt;parameter1&gt;, &lt;parameter2&gt;, etc... )<br> {
    <br> &lt;déclaration1&gt; ;<br> &lt;déclaration1&gt; ;<br>...<br> }
  </p>
  <p>En général, cependant, vous utiliserez la <em>première </em>forme pour les méthodes, et la seconde pour définir des <a href="Script_Functions.htm">fonctions de script</a>, car la seconde forme attribuera également un index de script au nom de la fonction, tandis que la première forme
    sera une &quot;vraie&quot; méthode (et nécessitera l'utilisation du <a href="Variables/Global_Variables.htm">préfixe</a> global <a href="Variables/Global_Variables.htm">si elle est</a> utilisée pour définir une fonction scriptée).</p>
  <p class="note"><strong>NOTE</strong>: Vous pouvez vérifier cela en utilisant les deux formulaires dans le projet et en appelant la fonction d'<span class="notranslate">exécution</span> <a href="../GML_Reference/Variable_Functions/typeof.htm">typeof()</a> sur chacun d'eux. L'un d'eux sera classé comme un &quot;nombre&quot; - puisqu'il renvoie un ID d'index de script - et l'autre sera classé comme une &quot;méthode&quot;.
    il renvoie un ID d'index de script - et l'autre sera classé comme une &quot;méthode&quot;.</p>
  <p>Gardez donc à l'esprit qu'en général, lorsque nous parlons de méthodes et de variables de méthode, nous faisons toujours référence à des fonctions qui <em>n'ont pas </em>été définies avec un index de script. </p>
  <p>Vous pouvez voir ci-dessous trois exemples simples de création d'une variable de méthode à l'aide de différents champs d'application :</p>
  <p class="code">// Local<br> var _debug = function(message)<br> {
    <br> show_debug_message(message) ;<br> }
    <br>
    <br> // Instance<br> do_maths = function(val1, val2, val3)<br> {
    <br> return (val1 * val2) - val3 ;<br> }
    <br>
    <br> // Global<br> global.pd = function(_x1, _y1, _x2, _y2) ;<br> {
    <br> return point_distance(_x1, _y1, _x2, _y2) ;<br> }
  </p>
  <p>Remarquez que dans le code ci-dessus, les différents paramètres qui sont donnés en entrée de la fonction sont tous nommés et que ces noms sont ceux qui doivent être utilisés dans la fonction pour faire référence aux différentes entrées. Notez également que vous pouvez utiliser l'instruction <span class="inline"><a href="Language_Features/return.htm">return</a></span> pour renvoyer une valeur d'une fonction à utiliser ailleurs dans votre code, et qu'une fonction <em>sans</em> valeur de retour définie renverra par défaut <span class="inline">undefined</span>.</p>
  <p class="note"><strong>REMARQUE</strong>: Alors que la variable sera dans la portée choisie, la fonction réelle sera liée à la portée dans laquelle elle a été initialement définie. Par exemple, les <a href="Script_Functions.htm">fonctions de script</a> ont toutes une portée globale et sont &quot;non liées&quot; (c'est-à-dire qu'elles ne sont pas associées à des instances).
    (c'est-à-dire qu'elles ne sont associées à aucune instance), mais si vous avez une fonction de script qui crée une autre fonction en tant que variable de méthode et que vous appelez ensuite cette fonction de script à partir d'une instance, la fonction utilisée dans le script <strong>sera liée à la variable d'instance en tant que méthode</strong>.
    En général, il n'est pas nécessaire de s'en préoccuper, mais pour des opérations plus complexes avec des variables de méthode, cela vaut la peine d'être pris en considération. Cela s'applique également à l'utilisation d'autres constructions telles que <a href="Language_Features/with.htm"><span class="inline">with</span></a>    - lorsque vous créez une variable de méthode à l'intérieur d'un with, la fonction sera liée à l'instance qui est actuellement dans la portée.</p>
  <p>Une fois créée, la variable méthode peut être utilisée comme une fonction d'<span class="notranslate">exécution</span> ou une fonction de script, par exemple :</p>
  <p class="code">create_vec = function(_x1, _y1, _x2, _y2) ;<br> {
    <br> var _array ;<br> _array[0] = point_distance(_x1, _y1, _x2, _y2) ;<br> _array[1] = point_direction(_x1, _y1, _x2, _y2) ;<br> return _array ;<br> }
    <br>
    <br> vec = create_vec(x, y, mouse_x, mouse_y) ;</p>
  <p>Les variables créées à l'intérieur d'une fonction suivent les mêmes règles que la normale et leur portée dépend du mot-clé utilisé ou de la portée de l'appel de fonction. Dans l'exemple ci-dessus, nous utilisons <span class="inline">var</span> et la variable tableau est donc dans la portée locale de la fonction.
    portée <em>locale </em>de la fonction. Si nous n'avions pas utilisé le mot-clé, la variable aurait été créée dans la portée de l'instance qui a appelé la fonction.</p>
  <p>Les méthodes, tout comme les fonctions de script, peuvent également prendre des arguments facultatifs qui ont des valeurs par défaut lorsqu'ils ne sont pas transmis :</p>
  <p class="code">create_attachment = function(_attachment, <strong>_x = x</strong>, <strong>_y = y</strong>)<br> {
    <br> return instance_create_layer(_x, _y, layer, _attachment) ;<br> }
  </p>
  <p>La fonction ci-dessus prend trois arguments, les deux derniers étant facultatifs. S'ils ne sont pas passés lors de l'appel de la fonction, les coordonnées x et y de l'instance seront utilisées par défaut.</p>
  <p>Notez que si un argument n'est pas passé, et qu'il n'a pas de valeur par défaut, alors il sera égal à <tt>undefined</tt>.</p>
  <p>Les méthodes peuvent également utiliser des variables statiques, qui conservent leur valeur à chaque appel de fonction. Veuillez <a href="Functions/Static_Variables.htm">lire cette page</a> pour plus d'informations.</p>
  <p>Nous énumérons ci-dessous quelques fonctions d'aide associées aux variables de méthode :</p>
  <ul class="colour">
    <li><a href="../GML_Reference/Variable_Functions/is_method.htm">est_méthode</a></li>
    <li><a href="../GML_Reference/Variable_Functions/method.htm">méthode</a></li>
    <li><a href="../GML_Reference/Variable_Functions/method_get_self.htm">méthode_get_self</a></li>
    <li><a href="../GML_Reference/Variable_Functions/method_get_index.htm">méthode_get_index</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="GML_Overview.htm">Aperçu du<span class="notranslate">GML</span></a></div>
        <div style="float:right">Suivant : <a href="Structs.htm">Structs</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Script Functions
User Defined Functions
-->
  <!-- TAGS
method_variables
-->
</body>
</html>