<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Structs</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page décrivant l&#39;utilisation de Structs" />
  <meta name="rh-index-keywords" content="Structs" />
  <meta name="search-keywords" content="structs,new,delete,struct" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Structs</h1><p> Une <strong>structure</strong> est - pour le dire simplement - une variable qui contient une collection d&#39;autres variables. Les variables qu&#39;une structure contient peuvent être de n&#39;importe quel <a href="Data_Types.htm">type de données</a> mentionné précédemment et ces variables peuvent être lues et écrites après la déclaration initiale de la structure, et vous pouvez également ajouter plus de variables à une structure après sa déclaration. Les variables utilisées dans une structure doivent suivre les schémas de dénomination conventionnels, c&#39;est-à-dire: elles ne peuvent pas commencer par un nombre et ne doivent être constituées que de caractères alphanumériques et du caractère de soulignement &quot;_&quot;, et notez également que le contenu d&#39;une structure est <em>indépendant du instance ou fonction qui l&#39;a créé</em>, et en tant que tel, vous pouvez - si vous le souhaitez - utiliser les noms de variables intégrés comme <tt>image_index</tt> ou <tt>x</tt> et <tt>y</tt>.</p><p> Après la création initiale, struct ont pas de frais généraux de traitement alors qu&#39;ils existent, bien qu&#39;ils prennent de l&#39; espace dans la mémoire. La syntaxe struct est la suivante:</p><p class="code"><i>&lt;variable&gt;</i> = {<br/>
    <i>&lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br/>
    <i>&lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br/>     etc...
    <br/>     };
  </p><p> Ainsi, un exemple de cela dans la pratique serait:</p><p class="code">mystruct = {<br/>     a : 20,<br/>     b : &quot;Hello World&quot;<br/>     };
  </p><p> Le code ci-dessus crée une structure de portée d&#39;instance dans la variable &quot;mystruct&quot; et la remplit avec certaines valeurs (les structures peuvent être créées à portée locale, instance et globale, comme toute autre variable - voir la section <a href="Variables_And_Variable_Scope.htm">Variables et portée de variable</a> pour plus d&#39;informations ). Notez que vous n&#39;avez pas à remplir le contenu d&#39;une structure lors de sa création initiale et que vous pouvez créer une structure vide en faisant simplement ceci:</p><p class="code">mystruct = {};</p><p> Cette structure peut ensuite être ajoutée ultérieurement dans le code du jeu. Voici un exemple de structure avec différents types de variables et de données:</p><p class="code">var _xx = 100;<br/> mystruct = {<br/>     a : 10,<br/>     b : &quot;Hello World&quot;,<br/>     c : int64(5),<br/>     d : _xx + 50,<br/>     e : function(a, b)<br/>         {
    <br/>         return a + b;<br/>         },
    <br/>     f : [ 10, 20, 30, 40, 50 ],<br/>     g : image_index<br/>     };
  </p><p> Vous remarquerez dans le code ci-dessus que vous pouvez également définir des méthodes et utiliser <span class="notranslate">runtime</span> fonctions d&#39;exécution dans des structures, et vous pouvez également utiliser des variables locales et des variables d&#39;instance dans la structure.</p><p> Vous remarquerez dans l&#39;exemple ci-dessus que la variable struct &quot;g&quot; est définie sur <span class="inline">image_index</span>, qui est une variable d&#39;instance. Vous pensez peut-être que vous devez utiliser le <a href="Instance_Keywords.htm">mot-clé</a> <span class="inline">other</span> dans ce cas pour obtenir la variable d&#39;instance, mais ce n&#39;est pas nécessaire. Essentiellement, lorsque vous définissez struct <strong>, toutes les variables membres sur le côté gauche du signe deux-points &quot;:&quot; sont les <em>variables struct</em>, et les valeurs et les variables sur le côté droit sont de la portée de tout ce <em>qui fait le définir</em></strong>.</p><p> Regardons un exemple simple pour illustrer cela. Supposons que vous souhaitiez définir une structure avec les variables &quot;x&quot; et &quot;y&quot; et que vous vouliez les définir sur les &quot;x&quot; et &quot;y&quot; de l&#39;instance définissant la structure. En pratique, le code ressemblerait à ceci:</p><p class="code">mystruct = {<br/>     x : x,<br/>     y : y<br/>     };
  </p><p> Dans le code ci-dessus, les variables de membre de structure &quot;x&quot; et &quot;y&quot; sont définies sur les valeurs contenues dans les variables d&#39;instance &quot;x&quot; et &quot;y&quot;, car la partie droite du signe deux-points &quot;:&quot; fait référence à l&#39;instance qui définit la structure. Il est à noter que cela signifie que vous <em>ne pouvez pas</em> utiliser de variables membres de structure dans le cadre de la définition d&#39;autres variables dans la structure lors de sa création. Par exemple, ce qui suit vous donnerait une erreur:</p><p class="code">mystruct = {<br/>     a : 10,<br/>     b : 10,<br/>     c : a + b<br/>     }</p><p> L&#39;erreur se produit parce que les variables «a» et «b» sont en fait évaluées à la portée de ce qui définit la structure (elles sont à droite du signe deux-points «:»), et <em>ne</em> sont pas celles qui sont définies dans la structure lui-même.<strong></strong></p><h3 style="padding-left: 20px"> <em><strong style="margin-left: 0px">IMPORTANT!</strong></em> Vous <strong>ne pouvez pas</strong> utiliser de <em><strong>variables de portée globale</strong></em> intégrées comme noms de membres de structure, par exemple: <span class="inline">game_id</span> ou <span class="inline">fps</span>. Vous pouvez trouver une liste complète de ces variables globales sur la page suivante:</h3><ul class="colour"><li> <a href="Struct_Forbidden_Variables.htm">Variables interdites de structure</a></li></ul><p> Une fois qu&#39;une structure a été définie, vous pouvez accéder aux données à l&#39;intérieur en utilisant la notation &quot;point&quot;, comme ceci:</p><p class="code">mystruct = {<br/>     a : 20,<br/>     b : &quot;Hello World&quot;<br/>     }
    <br/> mystring = mystruct.b + string(mystruct.a);</p><p> Vous pouvez également effectuer des opérations sur les variables d&#39;une structure ou les utiliser dans des fonctions, comme vous le feriez pour toute autre variable. Par exemple:</p><p class="code">mystruct.a += 1;<br/> mystruct.b = mystruct.a + 20;<br/> mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);</p><p> Enfin, les structures peuvent avoir d&#39;autres structures imbriquées à l&#39;intérieur, comme ceci:</p><p class="code">mystruct = {<br/>     a : {<br/>         aa : &quot;This is an example&quot;<br/>         },
    <br/>     b : {<br/>         bb : &quot;And another one&quot;<br/>         },
    <br/>     };
  </p><p> Pour accéder à de telles structures imbriquées, vous utiliseriez toujours la notation de point, comme ceci:</p><p class="code">var _str = mystuct.a.aa + &quot; &quot; + mystruct.b.bb;<br/> show_debug_message(_str);
  </p><p> Une autre façon d&#39;accéder aux données dans une structure consiste à utiliser le<a href="Language_Features/with.htm"><span class="inline">with()</span></a> fonction. Ainsi, vous pouvez le faire, par exemple:</p><p class="code">with(mystruct)<br/>     {<br/>     a += other.x;<br/>     }</p><p> Utilisant <span class="inline">with()</span> remplace la portée du code par la structure donnée dans laquelle vous pouvez manipuler les variables membres dans la portée de la structure. Notez que dans l&#39;exemple, nous utilisons également le <span class="inline">other</span> <a href="Instance_Keywords.htm">mot-clé</a>. Cela fonctionne comme dans une instance lors de l&#39;utilisation <span class="inline">with()</span> et référencera l&#39;instance (ou la structure) qui exécute réellement le bloc de code. Le mot clé <span class="inline">self</span> peut également être utilisé dans les structures pour faire référence à l&#39;instance actuelle qui exécute le bloc de code entier. Par exemple, dans une instance référençant des variables membres de structure imbriquées, <span class="inline">self</span> fera référence à l&#39; <em>instance</em> quelle que soit la profondeur d&#39;imbrication de la structure.</p><p> Lorsqu&#39;une structure n&#39;est plus requise, elle peut être supprimée de la mémoire à l&#39;aide du <a href="Language_Features/delete.htm"><tt>delete</tt></a>, qui marque la structure comme pouvant être récupérée. Ce n&#39;est pas strictement nécessaire car le <a class="glossterm"
      data-glossterm="Éboueur" href="#">garbage collector</a> peut le faire automatiquement dans les étapes de jeu suivantes si la structure n&#39;est plus référencée dans votre code, mais c&#39;est une bonne pratique de le faire et nous le recommandons (par exemple, appelez <tt>delete</tt> dans l&#39; <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">événement Clean Up</a> d&#39;une instance pour indiquer explicitement au garbage collector qu&#39;une structure d&#39;étendue d&#39;instance doit être supprimée).</p><p> Notez également que les structures peuvent être créées à l&#39;aide de <a href="Script_Functions.htm">fonctions</a> et de <a href="Method_Variables.htm">méthodes de</a> script, ce qui nécessite l&#39;utilisation du <a href="Language_Features/new.htm"><tt>new</tt></a> opérateur et le mot-clé <tt>constructor</tt>, comme illustré dans l&#39;exemple suivant:</p><p class="code">Vector2 = function(_x, _y) constructor<br/>     {
    <br/>     x = _x;<br/>     y = _y;<br/>     static Add = function( _other )<br/>         {
    <br/>         x += _other.x;<br/>         y += _other.y;<br/>         }
    <br/>     }
    <br/>
    <br/> // OR<br/>
    <br/> function Vector2(_x, _y) constructor<br/>     {
    <br/>     x = _x;<br/>     y = _y;<br/>     static Add = function( _other )<br/>         {
    <br/>         x += _other.x;<br/>         y += _other.y;<br/>         }
    <br/>     }
  </p><p> Ici, nous créons la fonction <tt>Vector2</tt> et en disant à <span class="notranslate">GameMaker Studio 2</span> qu&#39;il s&#39;agit d&#39;une fonction pour créer une structure en ajoutant le <tt>constructor</tt> mot-clé après la définition. Vous pouvez alors appeler cette fonction comme ceci:</p><p class="code">v1 = new Vector2(10, 10);</p><p> Maintenant la variable <tt>v1</tt> référencera une structure avec les variables <tt>x</tt> et <tt>y</tt> et la <a href="Method_Variables.htm">variable de méthode </a><tt>Add</tt>. Les structures créées de cette manière prendront également en charge l&#39; <b>héritage</b> unique, c&#39;est-à-dire: vous pouvez créer une structure en utilisant une fonction qui hérite des données d&#39;une autre fonction constructeur.</p><p class="note"> <strong>REMARQUE</strong>: lorsque vous travaillez avec l&#39;héritage, vous ne pouvez pas utiliser de variables de méthode pour définir la fonction de constructeur de structure, uniquement des fonctions de script.</p><p> Par exemple, nous avons créé un <tt>Vector2</tt> ci-dessus, nous pouvons donc l&#39;utiliser comme &quot;parent&quot; pour une autre fonction <tt>Vector3</tt>:</p><p class="code">function Vector3(_x, _y, _z) : Vector2(_x, _y) constructor<br/>     {
    <br/>     z = _z;<br/>     static Add = function( _other )<br/>         {
    <br/>         x += _other.x;<br/>         y += _other.y;<br/>         z += _other.z;<br/>         }
    <br/>     }
  </p><p> Comme vous pouvez le voir, lors de la définition de la fonction, nous utilisons un signe deux-points &quot;<span class="inline">:</span> &quot;pour séparer la nouvelle fonction de la fonction&quot; parent &quot;dont il faut hériter, et nous pouvons maintenant faire des choses comme ceci:</p><p class="code">var v1 = new Vector3(10, 10, 20);<br/> var v2 = new Vector3(100, 100, 200);<br/> v1.Add(v2);
    <br/> show_debug_message(v1);
  </p><p> La sortie affichée pour le code ci-dessus serait:</p><p class="code">{ 110, 110, 220 }</p><p> Pour plus de détails sur <tt>new</tt> et <tt>delete</tt> opérateurs, veuillez consulter les pages suivantes:</p><ul class="colour"><li><a href="Language_Features/new.htm"><tt>new </tt></a></li><li><tt><a href="Language_Features/delete.htm"><tt>delete</tt></a>
      </tt></li></ul><p> Une dernière chose à mentionner à propos des structures est que vous pouvez modifier ce qui est sorti sur la console pour le débogage. Par défaut, appeler la fonction<a href="../GML_Reference/Debugging/show_debug_overlay.htm"><span class="inline">show_debug_message()</span></a> sur une structure affichera le contenu de la structure (comme indiqué ci-dessus). Cependant, il est possible de personnaliser ce message en ajoutant une méthode spécifiquement nommée à la structure appelée <span class="inline">toString</span>:</p><p class="code">mystruct = {<br/>     a : 20,<br/>     b : &quot;Hello World&quot;,<br/>     toString: function()<br/>         {<br/>         return &quot;This stuct says &quot; + b + &quot;, &quot; + string(a) + &quot; times!!!&quot;;<br/>         }<br/>     }
    <br/> show_debug_message(mystruct);
  </p><p> Maintenant, quand le <span class="inline">show_debug_message()</span> fonction est appelée, la <span class="inline">toString</span> sera utilisée pour générer la sortie et - avec l&#39;exemple ci-dessus - vous obtiendrez:</p><p class="code">This struct says Hello World, 20 times!!!</p><p> Notez que vous pouvez également appeler le<a href="../GML_Reference/Strings/Strings.htm"><span class="inline">string()</span></a> fonction sur une référence de structure et utilisez-la pour afficher le contenu - ou <span class="inline">toString</span> méthode - à l&#39;écran, ou enregistrez-le dans un fichier, ou autre, par exemple:</p><p class="code">var _str = string(mystruct);<br/> draw_text(32, 32, _str);</p><p> Enfin, il existe un certain nombre de <span class="notranslate">runtime</span> que vous pouvez utiliser sur les structures pour obtenir les variables qu&#39;elles contiennent ainsi que quelques autres choses. Vous pouvez les trouver dans la section suivante:</p><ul class="colour"><li> <a href="../GML_Reference/Variable_Functions/Variable_Functions.htm">Fonctions variables</a> </li></ul><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="GML_Overview.htm">Présentation de <span class="notranslate">GML</span></a></div><div style="float:right"> Suivant: <a href="Language_Features.htm">Fonctionnalités linguistiques</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Structs
struct
constructor
-->
  <!-- TAGS
structs
-->
</body>
</html>