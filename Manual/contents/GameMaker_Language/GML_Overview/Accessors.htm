<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Accesseurs</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Accesseurs</h1>
  <p>Le <span class="notranslate">langage GameMaker</span><span class="notranslate">(GML)</span> vous permet également d'accéder à certaines <a href="../GML_Reference/Data_Structures/Data_Structures.htm">structures de données</a> et <a href="Arrays.htm">tableaux</a> grâce à des expressions logiques appelées <b>accesseurs</b>. Ce site
    est structurée de la même manière que lorsque vous travaillez normalement avec un tableau, sauf que nous utilisons un <em>symbole d'identification</em> avant le premier argument pour indiquer à <span class="notranslate">GameMaker Studio 2</span> que vous travaillez sur une structure de données (précédemment créée) ou sur le littéral d'un tableau.
    littéral.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Listes de DS [| ]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot">La syntaxe des <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">listes DS</a> est la suivante :</p>
    <p class="code">list_index [| index]</p>
    <p class="dropspot">Ainsi, lorsque vous avez utilisé <tt>ds_list_create()</tt> pour créer votre liste, vous utilisez l'index de la liste (que vous avez stocké dans une variable) pour la référencer, la valeur &quot;index&quot; étant la position dans la liste à définir ou à ajouter. Par exemple, le code
      exemple, le code suivant crée une liste et ajoute 10 entrées, en définissant chaque entrée comme un nombre aléatoire de 0 à 9 :</p>
    <p class="code">ds = ds_list_create() ;<br> var index = 0 ;<br> repeat(10)
      <br> {
      <br> ds[| index++] = irandom(9) ;<br> }
    </p>
    <p class="dropspot">Notez que si vous utilisez une expression pour ajouter une référence à un index qui a déjà une valeur, la valeur précédente sera remplacée plutôt que d'avoir un autre index ajouté à la liste. Pour ajouter des entrées supplémentaires, vous devez connaître la taille de ds_list
      et les ajouter à la fin. Il est également intéressant de noter que vous pouvez définir un index de liste qui est <i>supérieur</i> à la taille de la liste référencée, ce qui aura pour effet de définir cette valeur, d'étendre la liste en même temps et d'initialiser toutes les positions de la liste jusqu'à l'index donné.
      dans la liste jusqu'à l'indice donné comme 0.</p>
    <p class="dropspot">Une fois que vous avez créé votre structure de liste et que vous l'avez remplie de données, pour obtenir des valeurs à partir de la liste, il vous faut quelque chose du genre :</p>
    <p class="code">valeur = ds[| 5] ;</p>
    <p class="dropspot">La méthode ci-dessus récupère la valeur de la position 5 (le sixième indice, puisque les listes commencent à 0) et la stocke dans une variable. Si vous fournissez une position qui est en dehors de la taille de la liste, la valeur <tt>undefined</tt> sera retournée, ce que vous pouvez vérifier à l'aide de la fonction
      à l'aide de la fonction <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Cartes DS [ ?]</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">La syntaxe des <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">cartes DS</a> est la suivante :</p>
    <p class="code">map_index[ ? key]</p>
    <p class="dropspot">Après avoir créé votre carte avec <tt>ds_map_create()</tt>, vous utiliserez l'index de carte que vous avez stocké dans une variable pour la référencer, la valeur &quot;key&quot; étant la clé de carte à définir ou à obtenir. Par exemple, le code suivant crée une carte et
      puis ajoute quelques entrées à l'aide de cette syntaxe :</p>
    <p class="code">ds = ds_map_create() ;<br> ds[ ? &quot;Name&quot;] = &quot;Hamish&quot; ;<br> ds[ ? &quot;Company&quot;] = &quot;MacSeweeny Games&quot; ;<br> ds[ ? &quot;Game&quot;] = &quot;Catch The Haggis&quot; ;</p>
    <p class="dropspot">Notez que si la carte contient déjà la même valeur de clé que celle que vous essayez d'ajouter, elle ne créera pas de clé en double avec la nouvelle valeur, mais la valeur précédente sera remplacée.</p>
    <p class="dropspot">Une fois que vous avez créé votre structure de carte et que vous l'avez remplie de données, pour obtenir des valeurs à partir d'une clé de carte spécifique, vous auriez quelque chose comme ceci :</p>
    <p class="code">valeur = ds[ ? &quot;Nom&quot;] ;</p>
    <p class="dropspot">La méthode ci-dessus récupère la valeur de la clé &quot;Name&quot; et la stocke dans une variable, mais il faut savoir que si la clé donnée n'existe pas dans la carte DS, la valeur renvoyée sera indéfinie. Ceci peut être vérifié à l'aide de la fonction
      <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Grilles DS [#]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">La syntaxe de la <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">grille DS</a> est :</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">Après avoir créé votre grille à l'aide de la fonction <tt>ds_grid_create()</tt>, vous utiliserez l'index de la grille que vous avez stocké dans une variable pour la référencer, les valeurs &quot;xpos&quot; et &quot;ypos&quot; étant la position dans la grille pour obtenir ou définir
      une valeur. Par exemple, le code suivant crée une grille, la remet à 0, puis y ajoute quelques entrées :</p>
    <p class="code">ds = ds_grid_create() ;<br> ds_grid_clear(ds, 0) ;<br> var gw = ds_grid_width(ds) - 1 ;<br> var gh = ds_grid_height(ds) - 1 ;<br> repeat(10)
      <br> {
      <br> var xx = irandom(gw) ;<br> var yy = irandom(gh) ;<br> if (ds[# xx, yy] == 0)<br> {
      <br> ds[# xx, yy] = 1 ;<br> }
      <br> }
    </p>
    <p class="dropspot">Une fois que vous avez créé votre structure de grille et que vous l'avez remplie de données, pour obtenir des valeurs à partir d'une position spécifique de la grille, il vous faudrait quelque chose du genre :</p>
    <p class="code">valeur = ds[# mouse_x div 16, mouse_y div 16] ;</p>
    <p class="dropspot">La fonction ci-dessus récupère la valeur de la ds_grid donnée en fonction de la position de la souris (divisée par la largeur de la &quot;cellule&quot; dans la pièce pour obtenir l'emplacement correct). Si vous fournissez une position qui est en dehors des limites de la grille, la valeur <tt>undefined</tt> sera retournée, ce que vous pouvez vérifier en utilisant la fonction <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Tableaux [@]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Les tableaux ont également leurs propres accesseurs qui fonctionnent de manière similaire à ceux énumérés ci-dessus pour les structures de données. Cependant, les accesseurs de tableaux ont une propriété intéressante qui est de vous permettre de modifier un tableau à partir d'une <a href="Script_Functions.htm">fonction</a> ou d'une <a href="Method_Variables.htm">méthode de</a> <a href="Script_Functions.htm">script</a> sans avoir à le copier. Lorsque vous passez un tableau dans une fonction, il est <strong>passé par référence</strong>, ce qui signifie que le tableau lui-même n'est pas donné dans le script mais qu'il est simplement référencé pour obtenir les données.
      simplement référencé pour obtenir les données. Normalement, si vous devez modifier le tableau, il sera <em>copié </em>dans le script et vous devrez ensuite renvoyer le tableau copié pour que le tableau original soit mis à jour. Cela peut avoir des coûts élevés
      Vous pouvez donc utiliser l'accesseur à la place, car il modifiera <em>directement </em>le tableau d'origine sans qu'il soit nécessaire de le copier. Vous pouvez voir comment cela fonctionne dans les exemples ci-dessous.</p>
    <p class="dropspot">La syntaxe des tableaux est la suivante :</p>
    <p class="code">tableau[@ xpos]</p>
    <p class="dropspot">Après avoir créé votre tableau dans une instance, vous pouvez ensuite le passer à un script par référence et utiliser l'accesseur <span class="inline">@</span> pour le modifier directement. Par exemple, vous pouvez créer le tableau et appeler la fonction de la manière suivante :</p>
    <p class="code">array[99] = 0 ;<br> array_populate(array) ;
    </p>
    <p class="dropspot">La fonction elle-même aurait quelque chose comme ceci :</p>
    <p class="code">function array_populate(_array)<br> {<br> var a = _array ; var i = 0 ; repeat(25)<br> {<br> i = irandom(99) ;<br> while (a[i] != 0)<br> {<br> i = irandom(99) ;<br> } <br> 
        a[@ i] = 100 ;<br> } <br> }</p>
    <p class="dropspot">Tout ce que fait cette fonction est de sélectionner 25 positions aléatoires dans le tableau et de fixer la valeur de la position choisie du tableau à 100.</p>
    <p class="note">NOTE : Vous ne pouvez pas utiliser l'accesseur de tableau <span class="inline">@</span> lorsque vous travaillez avec le tableau <span class="inline">argument[n]</span> dans des fonctions de script.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Structs [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>La syntaxe des <a href="Structs.htm">structs</a> est</span></p>
    <p class="code">struct[$ &quot;nom&quot;]</p>
    <p class="dropspot">Cet accesseur est essentiellement une enveloppe pour les fonctions <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> et <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>,
      Vous pouvez l'utiliser comme l'accesseur d'une carte DS. Par exemple, si vous avez créé une structure et que vous voulez récupérer une valeur d'une variable appelée &quot;ma_santé&quot;, vous pouvez le faire :</span>
    </p>
    <p class="code">var _hp = struct [$ &quot;my_health&quot;] ;</p>
    <p class="dropspot">Comme vous pouvez le voir, vous ne fournissez pas la variable elle-même, mais plutôt une <em>chaîne de caractères</em> avec la variable. Notez que si la structure n'a pas de variable avec le nom donné, l'accesseur retournera <span class="inline">undefined</span> comme valeur.
      la valeur.</p>
    <p class="dropspot">Pour définir une variable dans une structure, vous devez procéder comme suit</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100 ;</p>
    <p class="dropspot">Comme pour la récupération d'une valeur, vous fournissez le nom de la variable à définir sous forme de chaîne de caractères, et elle sera définie à la valeur donnée. Si le nom de variable utilisé n'existe pas dans la structure, il sera créé et défini à la valeur donnée.</p>
    <p class="dropspot"><br /></p>
  </div>
  <p> </p>
  <p>Une caractéristique importante des accesseurs est le fait qu'ils peuvent être <i>enchaînés</i>. Cela signifie que si vous avez plusieurs structures de données et/ou tableaux imbriqués, il n'est plus nécessaire d'utiliser une variété de fonctions pour accéder à une valeur qui
    valeur qui se trouve au plus profond de la structure imbriquée. Par exemple, disons que vous avez un tableau, et que chaque élément du tableau est une liste DS, comme ceci :</p>
  <p class="code">array = array_create(3) ;<br> for (var i = 0 ; i &lt; 3 ; ++i ;)<br> {
    <br> array[i] = ds_list_create() ;<br> switch(i)
    <br> {
    <br> case 0 :<br> with (obj_Wall) ds_list_add(array[i], id) ;<br> break ;
    <br> cas 1 :<br> avec (obj_Door) ds_list_add(array[i], id) ;<br> break ;
    <br> cas 2 :<br> avec (obj_Chest) ds_list_add(array[i], id) ;<br> pause ;
    <br> }
    <br> }
  </p>
  <p>Dans le code ci-dessus, nous avons créé un tableau de 3 éléments et attribué une liste DS à chacun d'entre eux, puis nous avons rempli les différentes listes avec les ID d'instance de divers objets du jeu. Maintenant, pour accéder à un ID dans l'une des listes, nous pouvons faire ce qui suit
    ce qui suit :</p>
  <p class="code">var _list = array[0] ;<br> var _id = ds_list_find_value(_list, 0) ;</p>
  <p>Cependant, vous pouvez faire la même chose en utilisant des accesseurs enchaînés d'une manière beaucoup plus propre et en utilisant moins de code :</p>
  <p class="code">var _id = tableau [0] [| 0] ;</p>
  <p>Vous pouvez enchaîner plusieurs accesseurs de cette manière et ils peuvent être de plusieurs types pour accéder aux informations stockées dans chaque partie de la structure imbriquée. Voici d'autres exemples :</p>
  <p class="code">// Accéder à un tableau qui a été ajouté à une liste faisant partie d'une carte :<br> var _a = data[ ? &quot;lists&quot;][| 0][# 0, 0] ;<br>
    <br> // Accéder à un tableau imbriqué dans une liste depuis un script et le modifier :<br> data[| 0][@ 10] = 100 ;<br>
    <br> // Accéder à une carte imbriquée dans une grille imbriquée dans une liste imbriquée dans un tableau :<br> data[0][| 10][# 3, 4][ ? &quot;key&quot;] = &quot;hello world&quot; ;</p>
  <p>L'utilisation d'accesseurs chaînés pour les choses ne signifie pas seulement que vous pouvez écrire un code plus compact, mais aussi que vous pourrez utiliser l'itération (par exemple, en utilisant une boucle <a href="Language_Features/for.htm"><tt>pour</tt></a> boucle) et d'autres techniques pour accéder à vos données de manière
    données d'une manière plus propre et plus intuitive.</p>
  <p>Il convient de noter que lorsque vous utilisez des accesseurs de cette manière, vous devez toujours utiliser l'accesseur <span class="inline">@</span> pour les tableaux, car sinon vous ajouterez des frais supplémentaires à toutes les actions effectuées. Comme mentionné ci-dessus, par défaut, les tableaux
    sont transmis par référence dans les fonctions et utilisent ensuite le comportement &quot;copy on write&quot; lorsqu'ils sont modifiés. Cependant, si le tableau fait partie d'une chaîne, l'élément précédent dans la chaîne sera mis à jour avec le tableau copié et l'élément &quot;original&quot; sera supprimé.
    sera supprimé. Par exemple, en faisant quelque chose comme ceci :</p>
  <p class="code">// Dans un événement objet<br> data[| 0][0] = 100 ;<br>
    <br> // Dans une fonction<br> data[| 0][0] = 200 ;</p>
  <p>permet d'obtenir les mêmes résultats que cette méthode :</p>
  <p class="code">// Dans un événement objet<br> data[| 0][0] = 100 ;<br>
    <br> // Dans une fonction<br> data[| 0][@ 0] = 200 ;</p>
  <p>Cependant, le deuxième exemple est meilleur car il fonctionne sans la surcharge inutile de copier d'abord le tableau entier.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="GML_Overview.htm">Aperçu du<span class="notranslate">GML</span></a></div>
        <div style="float:right">Suivant : <a href="Script_Functions.htm">Fonctions et variables de script</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>