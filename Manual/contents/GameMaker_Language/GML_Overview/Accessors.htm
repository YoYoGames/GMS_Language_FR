<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Accesseurs</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page décrivant les différents accesseurs" />
  <meta name="rh-index-keywords" content="Accesseurs" />
  <meta name="search-keywords" content="Accesseurs,@,[| ],[@],[#],[? ],accesseur de grille,accesseur de liste,accesseur de carte,accesseur de tableau" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Accesseurs</h1><p> Le <span class="notranslate">GameMaker Language</span> ( <span class="notranslate">GML</span> ) vous permet également d&#39;accéder à certaines <a href="../GML_Reference/Data_Structures/Data_Structures.htm">structures de données</a> et <a href="Arrays.htm">tableaux</a> en utilisant des expressions logiques appelées <b>accesseurs</b>. Ceci est structuré de la même manière que lorsque vous travaillez normalement avec un tableau, seulement nous utilisons un <em>symbole identifiant</em> avant le premier argument pour indiquer à <span class="notranslate">GameMaker Studio 2</span> que vous travaillez sur une structure de données (précédemment créée) ou le littéral de tableau.</p><p></p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Listes DS [| ]</a></p><div class="droptext" data-targetname="drop-down10"><p class="dropspot"> La syntaxe des <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">listes DS</a> est la suivante:</p><p class="code">list_index[| index]</p><p class="dropspot"> Alors quand tu as utilisé <tt>ds_list_create()</tt> pour créer votre liste, vous utiliseriez l&#39;index de la liste (que vous avez stocké dans une variable) pour la référencer, la valeur «index» étant la position dans la liste à définir ou à ajouter. Par exemple, le code suivant crée une liste, puis ajoute 10 entrées, définissant chaque entrée sur un nombre aléatoire de 0 à 9:</p><p class="code">ds = ds_list_create();<br/> var index = 0;<br/> repeat(10)
      <br/>     {
      <br/>     ds[| index++] = irandom(9);<br/>     }
    </p><p class="dropspot"> Notez que si vous utilisez une expression pour ajouter une référence à un index qui a déjà une valeur, la valeur précédente sera remplacée au lieu d&#39;avoir un autre index ajouté à la liste. Pour ajouter d&#39;autres entrées, vous devez connaître la taille de ds_list et les ajouter à la fin. Il est également intéressant de noter que vous pouvez définir un index de liste <i>supérieur</i> à la taille de la liste référencée, ce qui définira cette valeur, en développant la liste en même temps et en initialisant toutes les positions de la liste à la valeur donnée. index comme 0.</p><p class="dropspot"> Une fois que vous avez créé votre structure de liste et l&#39;avez remplie de données, pour obtenir des valeurs de la liste, vous auriez quelque chose comme:</p><p class="code">value = ds[| 5];</p><p class="dropspot"> Ce qui précède obtiendra la valeur de la position 5 (le sixième index, puisque les listes commencent à 0) et la stockera dans une variable. Si vous indiquez une position en dehors de la taille de la liste, la valeur <tt>undefined</tt> sera retourné, que vous pouvez vérifier à l&#39;aide de la fonction <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS Maps [? ]</a></p><div class="droptext" data-targetname="drop-down13"><p class="dropspot"> La syntaxe des <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">cartes DS</a> est la suivante:</p><p class="code">map_index[? key]</p><p class="dropspot"> Après avoir créé votre carte avec <tt>ds_map_create()</tt>, vous utiliseriez l&#39;index de carte que vous avez stocké dans une variable pour la référencer, la valeur &quot;clé&quot; étant la clé de carte à définir ou à obtenir. Par exemple, le code suivant crée une carte, puis y ajoute quelques entrées à l&#39;aide de cette syntaxe:</p><p class="code">ds = ds_map_create();<br/> ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br/> ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br/> ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p><p class="dropspot"> Notez que si la carte contient déjà la même valeur de clé que celle que vous essayez d&#39;ajouter, elle ne créera pas de clé en double avec la nouvelle valeur, mais la valeur précédente sera remplacée.</p><p class="dropspot"> Une fois que vous avez créé votre structure de carte et l&#39;avez remplie de données, pour obtenir les valeurs d&#39;une clé de carte spécifique, vous auriez quelque chose comme ceci:</p><p class="code">value = ds[? &quot;Name&quot;];</p><p class="dropspot"> Ce qui précède obtiendra la valeur de la clé &quot;Nom&quot; et la stockera dans une variable, mais sachez que si la clé donnée n&#39;existe pas dans la carte DS, la valeur renvoyée sera <tt>undefined</tt>. Cela peut être vérifié à l&#39;aide de la fonction <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS Grids [#]</a></p><div class="droptext" data-targetname="drop-down14"><p class="dropspot"> La syntaxe de la <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">grille DS</a> est la suivante:</p><p class="code">grid_index[# xpos, ypos]</p><p class="dropspot"> Après avoir créé votre grille avec le <tt>ds_grid_create()</tt>, vous utiliseriez l&#39;index de grille que vous avez stocké dans une variable pour la référencer, avec les &quot;xpos&quot; et &quot;ypos&quot; étant la position dans la grille pour obtenir ou définir une valeur. Par exemple, le code suivant crée une grille, l&#39;efface à 0, puis y ajoute quelques entrées:</p><p class="code">ds = ds_grid_create();<br/> ds_grid_clear(ds, 0);<br/> var gw = ds_grid_width(ds) - 1;<br/> var gh = ds_grid_height(ds) - 1;<br/> repeat(10)
      <br/>     {
      <br/>     var xx = irandom(gw);<br/>     var yy = irandom(gh);<br/>     if (ds[# xx, yy] == 0)<br/>         {
      <br/>         ds[# xx, yy] = 1;<br/>         }
      <br/>     }
    </p><p class="dropspot"> Une fois que vous avez créé votre structure de grille et l&#39;avez remplie de données, pour obtenir des valeurs à partir d&#39;une position de grille spécifique, vous auriez quelque chose comme:</p><p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p><p class="dropspot"> Ce qui précède obtiendra la valeur de la ds_grid donnée en fonction de la position de la souris (divisée par la largeur de la &quot;cellule&quot; dans la pièce pour obtenir l&#39;emplacement correct). Si vous indiquez une position en dehors des limites de la grille, la valeur <tt>undefined</tt> sera retourné, que vous pouvez vérifier à l&#39;aide de la fonction <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><tt>is_undefined()</tt></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Tableaux [@]</a></p><div class="droptext" data-targetname="drop-down15"><p class="dropspot"> Les tableaux ont également leurs propres accesseurs qui fonctionnent de la même manière que ceux listés ci-dessus pour les structures de données. Cependant, les accesseurs de tableau ont une propriété intéressante et c&#39;est de vous permettre de modifier un tableau à partir d&#39;une <a href="Script_Functions.htm">fonction de script</a> ou<a href="Method_Variables.htm">method</a> sans avoir à le copier. Lorsque vous passez un tableau dans une fonction, il est <strong>passé par référence</strong>, ce qui signifie que le tableau lui-même n&#39;est pas donné dans le script mais qu&#39;il est simplement référencé pour obtenir les données. Normalement, si vous devez ensuite changer le tableau, il sera <em>copié</em> dans le script et vous devrez ensuite renvoyer (retourner) le tableau copié pour que le tableau d&#39;origine soit mis à jour. Cela peut entraîner des frais généraux de traitement coûteux et vous pouvez donc utiliser l&#39;accesseur à la place, car cela modifiera <em>directement le</em> tableau d&#39;origine sans qu&#39;il soit nécessaire de le copier. Vous pouvez voir comment cela fonctionne dans les exemples ci-dessous.</p><p class="dropspot"> La syntaxe des tableaux est:</p><p class="code">array[@ xpos]</p><p class="dropspot"> Après avoir créé votre tableau dans une instance, vous pouvez ensuite le transmettre à un script par référence et utiliser l&#39;accesseur<span class="inline">@</span> pour le changer directement. Par exemple, vous créez le tableau et appelez la fonction comme ceci:</p><p class="code">array[99] = 0;<br/> array_populate(array);
    </p><p class="dropspot"> La fonction elle-même aurait quelque chose comme ceci:</p><p class="code">function array_populate(_array)<br/>     {<br/>     var a = _array; var i = 0; repeat(25)<br/>         {<br/>         i = irandom(99);<br/>         while (a[i] != 0)<br/>             {<br/>             i = irandom(99);<br/>             }<br/>   
        a[@ i] = 100;<br/>         }<br/>     }</p><p class="dropspot"> Tout ce que fait cette fonction est de sélectionner 25 positions aléatoires dans le tableau et de définir la valeur de la position de tableau choisie sur 100.</p><p class="note"> REMARQUE: vous ne pouvez pas utiliser l&#39;accesseur de tableau <span class="inline">@</span> lorsque vous travaillez avec le<span class="inline">argument[n]</span> tableau dans les fonctions de script.</p><p class="dropspot"></p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Structs [$]</a></p><div class="droptext" data-targetname="drop-down16"><p class="dropspot"> <span>La syntaxe des <a href="Structs.htm">structures</a> est</span></p><p class="code">struct[$ &quot;name&quot;]</p><p class="dropspot"> Cet accesseur est essentiellement un wrapper pour les fonctions <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> et <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, et vous l&#39;utiliseriez comme l&#39;accesseur d&#39;une carte DS. Par exemple, si vous avez créé une structure et que vous souhaitez récupérer une valeur à partir d&#39;une variable appelée &quot;my_health&quot;, vous feriez:</span></p><p class="code">var _hp = struct[$ &quot;my_health&quot;];</p><p class="dropspot"> Comme vous pouvez le voir, vous ne fournissez pas la variable elle-même, mais plutôt une <em>chaîne</em> avec la variable. Notez que si la structure n&#39;a pas de variable avec le nom donné, alors l&#39;accesseur retournera <span class="inline">undefined</span> comme valeur.</p><p class="dropspot"> Pour définir une variable dans une structure, procédez comme suit</p><p class="code">struct[$ &quot;my_score&quot;] = 100;</p><p class="dropspot"> Comme pour obtenir une valeur, vous fournissez le nom de la variable à définir sous forme de chaîne, et il sera défini sur la valeur donnée. Si le nom de variable utilisé n&#39;existe pas dans la structure, il sera créé et mis à la valeur donnée.</p><p class="dropspot"><br/></p></div><p></p><p> Une caractéristique importante des accesseurs est le fait qu&#39;ils peuvent être <i>enchaînés</i>. Cela signifie que si vous avez plusieurs structures de données et / ou tableaux imbriqués, il n&#39;est plus nécessaire d&#39;utiliser une variété de fonctions pour accéder à une valeur qui est profondément dans la structure imbriquée. Par exemple, disons que vous avez un tableau et que chaque élément du tableau est une liste DS, comme ceci:</p><p class="code">array = array_create(3);<br/> for (var i = 0; i &lt; 3; ++i;)<br/>     {
    <br/>     array[i] = ds_list_create();<br/>     switch(i)
    <br/>         {
    <br/>         case 0:<br/>             with (obj_Wall) ds_list_add(array[i], id);<br/>             break;
    <br/>         case 1:<br/>             with (obj_Door) ds_list_add(array[i], id);<br/>             break;
    <br/>         case 2:<br/>             with (obj_Chest) ds_list_add(array[i], id);<br/>             break;
    <br/>         }
    <br/>     }
  </p><p> Dans le code ci-dessus, nous avons créé un tableau de 3 éléments et attribué une liste DS à chacun d&#39;eux, puis nous avons rempli les différentes listes avec les ID d&#39;instance de divers objets du jeu. Maintenant, pour accéder à un identifiant dans l&#39;une des listes, nous pouvons faire ce qui suit:</p><p class="code">var _list = array[0];<br/> var _id = ds_list_find_value(_list, 0);</p><p> Cependant, vous pouvez faire la même chose en utilisant des accesseurs chaînés d&#39;une manière beaucoup plus propre qui utilise moins de code:</p><p class="code">var _id = array[0][| 0];</p><p> Vous pouvez enchaîner plusieurs accesseurs de cette manière et ils peuvent être de plusieurs types pour accéder aux informations stockées dans chaque partie de la structure imbriquée. Voici quelques exemples supplémentaires:</p><p class="code">// Access a grid that has been added to a list that is part of a map:<br/> var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br/>
    <br/> // Access an array nested in a list from a script and modify it:<br/> data[| 0][@ 10] = 100;<br/>
    <br/> // Access a map nested in a grid nested in a list nested in an array:<br/> data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;</p><p> Utiliser des accesseurs chaînés pour les choses signifie non seulement que vous pouvez écrire du code plus compact, mais cela vous permettra également d&#39;utiliser une itération (par exemple, en utilisant un <a href="Language_Features/for.htm"><tt>for</tt></a> loop) et d&#39;autres techniques pour accéder à vos données de manière plus propre et plus intuitive.</p><p> Il est à noter que lorsque vous utilisez des accesseurs de cette manière, vous devez toujours utiliser le <span class="inline">@</span> accesseur pour les tableaux, sinon vous ajouterez une surcharge supplémentaire à toutes les actions en cours d&#39;exécution. Comme mentionné ci-dessus, par défaut, les tableaux sont passés par référence dans les fonctions et utilisent ensuite le comportement «copie à l&#39;écriture» lorsqu&#39;ils sont modifiés. Cependant, si le tableau fait partie d&#39;une chaîne, l&#39;élément précédent de la chaîne sera mis à jour avec le tableau copié et «l&#39;original» sera supprimé. Par exemple, faire quelque chose comme ceci:</p><p class="code">// In an object event<br/> data[| 0][0] = 100;<br/>
    <br/> // In a function<br/> data[| 0][0] = 200;</p><p> obtient les mêmes résultats que de faire ceci:</p><p class="code">// In an object event<br/> data[| 0][0] = 100;<br/>
    <br/> // In a function<br/> data[| 0][@ 0] = 200;</p><p> Cependant, le deuxième exemple est meilleur car il fonctionne sans la surcharge inutile de la copie de tout le tableau en premier. </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="GML_Overview.htm">Présentation de <span class="notranslate">GML</span></a></div><div style="float:right"> Suivant: <a href="Script_Functions.htm">Fonctions et variables de script</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>