<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>buffer_create</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page de référence pour buffer_create" />
  <meta name="rh-index-keywords" content="buffer_create,buffer_fixed,buffer_grow,buffer_wrap,buffer_fast,buffer_vbuffer" />
  <meta name="search-keywords" content="buffer_create,buffer_fixed,buffer_grow,buffer_wrap,buffer_fast,buffer_vbuffer" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>buffer_create</h1><p> Vous utilisez cette fonction pour allouer une partie de la mémoire en tant que tampon dans votre jeu, la fonction renvoyant l&#39; <i>ID de tampon</i> unique qui doit être stocké dans une variable et utilisé pour tous les autres appels de fonction au tampon. Le tampon peut ensuite être utilisé pour stocker différents types de données (spécifiés lorsque vous écrivez dans le tampon à l&#39;aide du <a href="buffer_write.htm"><tt>buffer_write()</tt></a> fonction, avec les constantes suivantes utilisées pour définir le type de tampon:</p><p></p><table><tbody><tr><th> Constant</th><th> Description</th></tr><tr><td> <span class="notranslate">buffer_fixed</span></td><td> Un tampon de taille fixe.</td></tr><tr><td> <span class="notranslate">buffer_grow</span></td><td> Un tampon qui «grandira» dynamiquement à mesure que des données sont ajoutées</td></tr><tr><td> <span class="notranslate">buffer_wrap</span></td><td> Un tampon dans lequel les données seront «enveloppées». Lorsque les données ajoutées atteignent la limite de la taille de la mémoire tampon, l&#39;écrasement sera replacé au début de la mémoire tampon et une nouvelle écriture se poursuivra à partir de ce point.</td></tr><tr><td> <span class="notranslate">buffer_fast</span></td><td> Tampon spécial &quot;dépouillé&quot; extrêmement rapide en lecture / écriture. Ne peut être utilisé qu&#39;avec <tt>buffer_u8</tt> <a href="buffer_read.htm">types de données</a> et <i>doit</i> être aligné sur 1 octet.</td></tr><tr><td> <span class="notranslate">buffer_vbuffer</span></td><td> Ce type de tampon doit être utilisé uniquement comme tampon de sommets.</td></tr></tbody></table><p></p><p> Outre le type de tampon, vous devrez également définir l&#39; <i>alignement des octets</i> pour le tampon. Cette valeur varie en fonction des données que vous souhaitez stocker dans la mémoire tampon, et dans la plupart des cas, une valeur de 1 convient parfaitement. Cependant, sachez que pour certaines opérations, un alignement spécifique est <i>essentiel</i> et qu&#39;un alignement incorrect peut provoquer des erreurs (pour plus de détails sur l&#39;alignement, voir <a href="../../../Additional_Information/Guide_To_Using_Buffers.htm">Tampons</a> ). Ce qui suit est un guide général pour montrer quelles valeurs sont les plus appropriées pour chaque type de données (en cas de doute, utilisez un alignement de 1):</p><ul class="colour"><li> Les chaînes doivent être alignées sur 1 octet.</li><li> Les entiers 8 bits signés ou non signés peuvent être alignés sur n&#39;importe quelle valeur, mais notez que pour un tampon rapide (voir <a href="buffer_write.htm"><tt>buffer_write()</tt></a> ) il <i>doit</i> être aligné sur 1.</li><li> Les entiers 16 bits signés ou non signés doivent être alignés sur 2 octets.</li><li> Les entiers 32 bits signés ou non signés doivent être alignés sur 4 octets</li><li> Les flotteurs jusqu&#39;à 16 bits doivent être alignés sur 2 octets. <i>(Pas actuellement pris en charge!)</i></li><li> Les flotteurs jusqu&#39;à 32 bits doivent être alignés sur 4 octets.</li><li> Les flottants jusqu&#39;à 64 bits doivent être alignés sur 8 octets.</li></ul><p class="note"> <b>REMARQUE</b>: l&#39;alignement des octets peut être très important car un mauvais choix peut affecter les performances.</p><p class="note"> <b>REMARQUE</b>: il est important que vous supprimiez de la mémoire toutes les ressources créées dynamiquement comme celle-ci lorsque vous n&#39;en avez plus besoin pour éviter les fuites de mémoire.Par conséquent, lorsque vous avez terminé avec le tampon que vous avez créé, vous devez le libérer à nouveau en utilisant <span style="font-size:1px;"><a href="buffer_delete.htm"><tt style="font-size: 14px">buffer_delete ()</tt></a></span>.</p><p></p><h4> Syntaxe:</h4><p class="code">buffer_create(size, type, alignment)</p><table><tbody><tr><th> Argument</th><th> Description</th></tr><tr><td> <span class="notranslate">size</span></td><td> La taille (en octets) du tampon.</td></tr><tr><td> <span class="notranslate">type</span></td><td> Le type de tampon à créer (voir la liste des constantes ci-dessus).</td></tr><tr><td> <span class="notranslate">alignment</span></td><td> L&#39;alignement des octets pour le tampon</td></tr></tbody></table><p></p><h4> Retour:</h4><p class="code">Int (Vertex buffer ID)</p><p></p><h4> Exemple:</h4><p class="code">player_buffer = buffer_create(16384, buffer_fixed, 2);</p><p> Le code ci-dessus alloue 16 384 octets de mémoire à un tampon et renvoie l&#39;index de ce tampon, qui est stocké dans la variable &quot;player_buffer&quot;, pour une utilisation future. Le tampon est aligné sur une limite de deux octets. </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="Buffers.htm">Tampons</a></div><div style="float:right"> Suivant:<a href="buffer_create_from_vertex_buffer.htm">buffer_create_from_vertex_buffer</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
buffer_create
buffer_fixed
buffer_grow
buffer_wrap
buffer_fast
buffer_vbuffer
-->
  <!-- TAGS
buffer_create
-->
</body>
</html>