<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>view_surface_id</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page de référence pour view_surface_id" />
  <meta name="rh-index-keywords" content="view_surface_id" />
  <meta name="search-keywords" content="view_surface_id" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1>view_surface_id</h1><p> Avec cette variable, vous pouvez définir le contenu d&#39;un port de vue donné pour dessiner sur une surface, ou obtenir l&#39;ID de surface actuel si l&#39;un a été affecté à un port de vue. Lorsque vous travaillez avec des surfaces, il est souvent nécessaire de capturer la <i>totalité de</i> la zone visible de l&#39;écran sur la surface, et vous devez donc l&#39;attribuer à un port de vue à l&#39;aide de cette variable. Cela signifie que tout ce qui est affiché dans la vue choisie sera maintenant dessiné sur la surface assignée. La vue <i>ne</i> sera plus dessinée à l&#39;écran, ce qui signifie que vous devrez soit:</p><ul class="colour"><li> Activez une nouvelle vue et dessinez la surface uniquement dans cette vue (en utilisant <a href="view_current.htm"><tt>view_current</tt></a> pour vérifier quelle vue est dessinée)</li><li> Dessinez la surface dans l&#39;événement Draw GUI d&#39;une instance, car la couche GUI est indépendante des vues.</li></ul><p> Vous pouvez également lire cette variable pour obtenir l&#39;index de la surface qui a été assignée à la vue choisie ou elle renverra -1 si aucune surface n&#39;a été assignée, et généralement la surface utilisée pour cette fonction doit être de la taille de la caméra de vue lui-même (pas le port de vue). L&#39;exemple étendu ci-dessous montre une configuration de base pour capturer une vue et la dessiner dans l&#39; <b>événement Draw GUI</b>, et pour plus d&#39;informations sur les surfaces, voir la section <a href="../../Drawing/Surfaces/Surfaces.htm">Surfaces</a>.</p><p> Notez que vous pouvez également définir un port de vue sur une surface à l&#39;aide de la fonction <a href="view_set_surface_id.htm"><tt>view_set_surface_id()</tt></a>.</p><p></p><h4> Syntaxe:</h4><p class="code">view_surface_id[0...7];</p><p></p><h4> Retour:</h4><p class="code">Real (surface index or -1 if no surface has been assigned)</p><p></p><h4> Exemple étendu:</h4><p> Dans cet exemple étendu, nous allons créer une surface et l&#39;affecter au port de vue [0] afin qu&#39;elle capture la vue de la caméra affectée à ce port, puis la dessiner sur l&#39;écran dans l&#39;événement Draw GUI. Pour commencer, nous devons initialiser notre variable de surface dans le <b>Create Event</b> d&#39;une instance de contrôleur:</p><p class="code">surf = -1;</p><p> Nous définissons la variable de surface sur -1, car toutes les fonctions de surface doivent vraiment être utilisées dans les <b>événements Draw</b> pour éviter des erreurs impaires ou des comportements indéfinis. Donc, une fois cela fait, nous aurions alors ceci dans l&#39;événement <b>principal Draw:</b></p><p class="code">if !surface_exists(surf)<br/>     {
    <br/>     surf = surface_create(camera_get_view_width(view_camera[0]), camera_get_view_height(view_camera[0]));<br/>     view_surface_id[0] = surf;<br/>     }
  </p><p> Les surfaces sont <i>volatiles,</i> ce qui signifie qu&#39;elles peuvent être supprimées de la mémoire à tout moment en raison de la gestion de la mémoire du système d&#39;exploitation et d&#39;autres choses.Nous vérifions donc ici si notre surface existe et si ce n&#39;est pas le cas, nous la créons et l&#39;affectons à la vue 0. Cela fait, tout ce qui apparaîtrait dans la vue 0 sera maintenant dessiné sur la surface que nous avons créée à la place. Si vous ne faites rien d&#39;autre à ce stade, lorsque vous exécutez votre jeu, vous obtiendrez simplement un écran vide car tout le dessin est fait sur la surface, mais la surface elle-même n&#39;est dessinée nulle part. Par conséquent, nous devons maintenant dessiner la surface à l&#39;écran dans l&#39; <b>événement Draw GUI</b> comme ceci:</p><p class="code">if surface_exists(surf)<br/>     {
    <br/>     draw_surface_stretched(surf, 0, 0, display_get_gui_width(), display_get_gui_height());<br/>     }
  </p><p> Ce code va maintenant dessiner la surface que nous avons créée à partir de la caméra de vue étirée pour remplir la couche entière de l&#39;interface graphique. </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Arrière: <a href="Cameras_And_View_Ports.htm">caméras et ports d&#39;affichage</a></div><div style="float:right"> Suivant:<a href="view_get_camera.htm">view_get_camera</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
view_surface_id
-->
  <!-- TAGS
view_surface_id
-->
</body>
</html>