<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Animation squelettique</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page décrivant les différentes fonctions d&#39;animation squelettique" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="Animation squelettique,gm_SpineTintBlackColour,teinte noire,La colonne vertébrale" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Sprites d&#39;animation squelettique</h1><p> Les fonctions trouvées dans cette section sont <i>uniquement</i> destinées à être utilisées avec des sprites qui ont été importés à partir d&#39;un fichier d&#39;animation squelettique (en particulier, les fichiers JSON que <a href="http://es.esotericsoftware.com/"><b>Spine</b></a> exporte) et peuvent être utilisées pour obtenir des informations sur un actif d&#39;animation dans votre jeu, ainsi que pour définir certaines propriétés dans une animation. Ces fonctions peuvent être utilisées avec les fonctions et variables de sprite normales, vous permettant (par exemple) de mélanger deux animations squelettes à l&#39;aide de ces fonctions spéciales tout en définissant l&#39;échelle de l&#39;image à l&#39;aide des variables d&#39;instance de sprite normales (pour plus d&#39;informations sur les variables d&#39;instance de sprite voir <a href="../Sprite_Instance_Variables/Sprite_Instance_Variables.htm">ici</a> ).</p><p class="note"> <b>REMARQUE</b>: pour plus d&#39;informations sur l&#39;importation de sprites d&#39;animation squelettiques créés avec Spine, veuillez consulter la section <a href="../../../../../Settings/Texture_Information/Non-Bitmap_Sprites.htm">Importer des sprites non bitmap</a>.</p><p> Vous pouvez en savoir plus sur les fonctions de ces types de sprites dans les sections ci-dessous:</p><p></p><ul class="colour"><li> <a href="Animation/Animation.htm"><label for="a">Animation</label></a></li><li> <a href="Skins/Skins.htm"><label for="b">Skins</label></a></li><li> <a href="Attachments/Attachments.htm"><label for="c">Pièces jointes</label></a></li><li> <a href="Bones/Bones.htm"><label for="d">Des os</label></a></li><li> <a href="Slots/Slots.htm"><label for="f">Machines à sous</label></a></li><li> <a href="Drawing_And_Miscellaneous/Drawing_And_Miscellaneous.htm"><label for="e">Dessin et divers</label></a></li></ul><p></p><p></p><h2> Support noir de teinte</h2><p> Cette fonction permet aux zones sombres des emplacements de sprite Spine d&#39;être teintées différemment des zones claires (il s&#39;agit d&#39;une fonction IDE Spine, voir la section <b>Teinte noire</b> <a href="http://esotericsoftware.com/spine-attachments"
      target="_blank">ici pour</a> plus de détails). Actuellement, pour utiliser cette fonctionnalité dans <span class="notranslate">GameMaker Studio 2</span>, vous devez utiliser un <a href="../../../../../The_Asset_Editors/Shaders.htm"><span class="notranslate">shader</span></a> personnalisé lors du dessin d&#39;un sprite Spine qui l&#39;utilise. Ce <span class="notranslate">shader</span> contient une variable uniforme globale appelée &quot;<tt>gm_SpineTintBlackColour</tt> &quot;que le coureur remplit avec la couleur de teinte noire actuelle, extraite automatiquement des données Spine. Le <span class="notranslate">shader</span> requis est indiqué ci-dessous:</p><p> Vertex <span class="notranslate">Shader</span> (c&#39;est le même que le <span class="notranslate">shader</span> vertex passthrough par défaut)</p><p class="code">attribute vec3 in_Position; // (x,y,z)<br/> attribute vec4 in_Colour; // (r,g,b,a)<br/> attribute vec2 in_TextureCoord; // (u,v)<br/>
    <br/> varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
    <br/> void main()<br/> {
    <br/> vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br/> gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br/> v_vColour = in_Colour;<br/> v_vTexcoord = in_TextureCoord;<br/> }
  </p><p> Le Fragment <span class="notranslate">Shader</span>:</p><p class="code">varying vec2 v_vTexcoord;<br/> varying vec4 v_vColour;<br/>
    <br/> uniform vec4 gm_SpineTintBlackColour; // This is the uniform containing the tint-black colour<br/>
    <br/> void main()<br/> {
    <br/> vec4 tb = gm_SpineTintBlackColour;<br/> vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord );<br/> vec4 outcol;<br/> outcol.rgb = v_vColour.rgb * texcol.rgb;<br/> outcol.rgb += tb.rgb * ((tb.a * (texcol.a - 1.0)) + (1.0 - texcol.rgb)); //
    This line performs the tint-black blending logic<br/> outcol.a = v_vColour.a * texcol.a;<br/> gl_FragColor = outcol;<br/> }
  </p><p> Vous utiliseriez ceci en appelant d&#39;abord le <span class="notranslate">shader</span>, puis en dessinant le sprite, puis en réinitialisant le <span class="notranslate">shader</span>, quelque chose comme ceci: </p><p class="code">shader_set(shd_spine_tint_black);<br/> draw_self();
    <br/> shader_reset();
  </p><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="../Sprites.htm">Sprites</a></div><div style="float:right"> Suivant: <a href="../Sprite_Information/Sprite_Information.htm"><label for="three">Informations sur les sprites</label></a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Spine Sprites
Spine
Skeleton Animation Sprites
gm_SpineTintBlackColour
tint black
-->
  <!-- TAGS
sprite_spìne_functions
-->
</body>
</html>