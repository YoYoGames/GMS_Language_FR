<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Dessiner des événements</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page détaillant l&#39;événement de tirage au sort." />
  <meta name="rh-index-keywords" content="Objets - Événements de dessin" />
  <meta name="search-keywords" content="événement de tirage au sort,tirage au sort,dessiner la fin,pré-tirage,tirage au sort,dessiner GUI,ordre de tirage" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Les événements de tirage au sort</h1><p><img alt="The Draw Event" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Draw.png" /> La catégorie d&#39;événements Draw est celle qui contient tous les événements qui régissent ce que vous voyez à l&#39;écran lorsque vous exécutez votre jeu. Il est divisé en divers événements distincts pour mieux gérer les différentes exigences de dessin de votre jeu, et l&#39;image ci-dessous illustre l&#39;ordre dans lequel chaque événement est exécuté:</p><p><img alt="Object Editor Draw Diagram" class="center" src="../../assets/Images/Asset_Editors/Editor_Events_DrawOrder.png" /> L&#39;événement Draw normal se divise en trois sous-types: les événements <strong>Draw Begin</strong>, les événements <strong>Draw</strong> standard et <strong>Draw End.</strong> En général, vous n&#39;aurez besoin d&#39;utiliser que l&#39;événement Draw standard et vous devez être conscient que toutes les instances dans une salle auront cet événement déclenché à chaque étape du jeu, donc cet événement sera toujours appelé tant que l&#39;instance a le <strong>visible</strong> flag défini sur true. Il est important de comprendre que même si vous n&#39;avez rien défini pour ce sous-événement dans les propriétés de l&#39;objet (c&#39;est-à-dire: pas de code ni d&#39;actions), <em>si l&#39;objet a un sprite affecté, il aura toujours un événement draw qui sera déclenché</em>. En effet, <span class="notranslate">GameMaker Studio 2</span> dispose de deux façons de dessiner des éléments dans l&#39;événement Draw:</p><ul class="colour"><li> le <strong>dessin par défaut</strong>, c&#39;est-à-dire lorsque vous définissez le sprite dans les propriétés de l&#39;objet et ne placez aucune action ou code dans l&#39;événement Draw normal, et dans ce cas <span class="notranslate">GameMaker Studio 2</span> dessinera automatiquement le sprite affecté. Notez que toutes les transformations que vous effectuez dans d&#39;autres événements pour changer l&#39;échelle de l&#39;image, l&#39;index, la fusion, etc. seront également reflétées tant que l&#39;événement de dessin est vide.</li><li> le <strong>dessin personnalisé</strong>, c&#39;est-à-dire lorsque vous placez du code ou des actions dans l&#39;événement draw. Cela <span class="notranslate">GameMaker Studio 2</span> &quot; <em>Je veux contrôler ce que vous dessinez pour les instances de cet objet</em> &quot; et il remplace complètement le dessin par défaut. Cela signifie que, par exemple, vous pouvez avoir un objet avec un sprite attribué, puis définir l&#39;événement draw pour dessiner du texte et le texte sera dessiné à l&#39;écran, mais le sprite <em>ne</em> sera pas dessiné car vous ne l&#39;avez pas dit à <span class="notranslate">GameMaker Studio 2</span> pour le dessiner avec le texte.</li></ul><p> Le reste des événements de tirage au sort sont expliqués dans les sections ci-dessous:</p><p></p><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Dessiner le début et dessiner la fin</a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot"> Outre l&#39;événement principal Draw, vous avez également un événement <strong>Draw Begin</strong> et un événement <strong>Draw End.</strong> Ceux-ci agissent exactement de la même manière qu&#39;un événement Draw standard (c&#39;est-à-dire: ils dessineront tout ce que vous y mettez à chaque étape du jeu et pour toutes les fenêtres), mais ils ne «tirent par défaut» rien s&#39;ils n&#39;ont pas été explicitement ajoutés à un objet, et ils seront toujours exécutés avant / après l&#39;événement Draw standard. Ainsi, lorsque le jeu est en cours d&#39;exécution, vous aurez <em>toujours</em> l&#39;événement Draw Begin pour toutes les instances, puis l&#39;événement Draw pour toutes les instances, puis enfin l&#39;événement Draw End pour toutes les instances.</p><p class="dropspot"> De cette façon, vous pouvez dessiner des éléments ou définir des propriétés de dessin dans l&#39;étape Draw Begin en une seule instance et vous assurer que toutes les instances avec un événement Draw standard ou Draw End utiliseront ces propriétés ou dessineront sur ce que la première instance a dessiné. Fondamentalement, c&#39;est un moyen sûr de garantir que certaines choses sont dessinées à certains moments, tout comme le font les événements <strong>Begin Step</strong> et <strong>End Step.</strong></p><p class="dropspot"> Il y a quelques points à noter lors du dessin d&#39;objets dans <span class="notranslate">GameMaker Studio 2</span>, qu&#39;il s&#39;agisse d&#39;un sprite que vous <span class="notranslate">shader</span> ou d&#39;un tampon 3D:</p><ul class="colour"><li class="dropspot"> L&#39;événement de tirage au sort est un événement très intensif, en ce sens que c&#39;est l&#39;un des événements qui prend le plus de temps et de ressources... à cette fin, ce n&#39;est jamais une bonne idée de faire quoi que ce soit dans l&#39;événement de tirage autre que le dessin. Enregistrez donc votre code volumineux ou vos actions complexes pour l&#39;événement Step ou Alarms ou tout autre événement adapté, mais laissez l&#39;événement draw clair pour le dessin car c&#39;est ce qu&#39;il fait le mieux.</li><li class="dropspot"> Si le paramètre visible de votre objet est <em>désactivé</em> (afin que les instances de l&#39;objet ne soient pas dessinées), <strong>tous les événements de dessin sont ignorés</strong> (à l&#39;exception de l&#39; <strong>événement Resize</strong> ). Cela signifie que rendre une instance invisible arrêtera tout le code placé dans l&#39;un de ces événements de s&#39;exécuter, donc ne mettez pas de code essentiel dans les événements de dessin s&#39;ils ne seront pas visibles.</li><li class="dropspot"> Ce que vous dessinez n&#39;a rien à voir avec le moteur de collision que vous choisissez (traditionnel ou physique) tel qu&#39;il est défini par les propriétés de l&#39;objet et le sprite (ou masque) que l&#39;objet a été donné.</li></ul><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Dessiner GUI</a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot"> Le type d&#39;événement Draw GUI appartient à la catégorie Draw Event et est spécialement conçu pour dessiner <a class="glossterm" data-glossterm="GUI" href="#">des</a> éléments GUI qui ne sont pas affectés par l&#39;échelle ou la rotation de la caméra de vue. Cela signifie que vous pouvez demander à une instance de dessiner tous les éléments de votre <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> ou de votre interface utilisateur sans avoir à baser tout le positionnement des éléments sur la position de l&#39;occurrence dans la pièce ou sur la position de la vue de la caméra actuelle.</p><p class="dropspot"> Lorsque vous dessinez dans ces cas, il est important que vous compreniez que les coordonnées de dessin ne changent pas même lorsque les vues de caméra sont actives et que (0,0) est <em>toujours</em> le coin supérieur gauche de la surface d&#39;application ou de l&#39;affichage (voir la remarque à au bas de cette section), et la largeur et la hauteur par défaut sont 1: 1 avec la surface d&#39;application. L&#39;ordre de profondeur est toujours conservé entre différentes instances sur différentes couches (donc une instance sur une couche supérieure sera dessinée sous une à une couche inférieure) et également dans les événements eux-mêmes, car l&#39; <strong>événement Draw GUI Begin</strong> sera d&#39;abord dessiné pour toutes les instances, puis <strong>L&#39;interface graphique</strong> standard de Draw dessinera pour toutes les instances au-dessus de cela, et finalement l&#39; <strong>événement Draw Gui End</strong> est déclenché.</p><p class="dropspot"> De cette façon, vous pouvez dessiner des éléments ou définir des propriétés de dessin dans l&#39;interface graphique de Draw Begin en une seule instance et vous assurer que toutes les instances avec une interface graphique standard de dessin ou un événement de fin d&#39;interface graphique de dessin utiliseront ces propriétés ou dessineront sur ce que la première instance a dessiné. En gros, c&#39;est un moyen sûr de garantir que certaines choses sont dessinées à certains moments, tout comme le font les événements <strong>Begin Step</strong> et <strong>End Step.</strong></p><p class="dropspot"> Ces événements peuvent également être utilisés en conjonction avec les événements Draw normaux (qui seront affectés par la position, l&#39;échelle et la rotation de la vue de la caméra comme d&#39;habitude). Si vous n&#39;avez pas d&#39;événement de dessin mais que vous avez un événement d&#39;interface graphique de <span class="notranslate">GameMaker Studio 2</span> dessinera toujours l&#39;image-objet par défaut pour l&#39;instance (si elle en a un) comme d&#39;habitude.</p><p class="dropspot"> En ce qui concerne les autres événements de dessin, les événements de l&#39;interface graphique de dessin seront toujours dessinés sur tout ce qui est dessiné dans les événements de dessin normaux. Ainsi, si vous avez une instance sur un calque inférieur avec un événement Draw GUI, elle dessinera sur l&#39;instance qui se trouve sur un calque supérieur avec un événement Draw normal. Si les deux instances ont un événement Draw GUI, l&#39;ordre des calques sera respecté.</p><p class="note"> <strong>REMARQUE</strong>: Cet événement dessine, par défaut, 1: 1 avec la taille de la surface de l&#39;application, qui est normalement la taille de la pièce ou du port de vue. Cela signifie que lorsque vous avez <strong>activé la correction du rapport d&#39;aspect</strong> dans les options de jeu, l&#39;interface graphique ne sera pas dessinée sur les barres noires qui «boîte aux lettres» du jeu. Ce comportement peut être désactivé à l&#39;aide de la fonction <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm"><span style="font-size:14px;"><span class="inline" style="font-size: 14px">display_set_gui_maximise ()</span></span></a>, et vous pouvez également verrouiller l&#39;événement GUI à une taille spécifique qui sera ensuite mise à l&#39;échelle pour s&#39;adapter automatiquement aux dimensions de la surface d&#39;affichage ou d&#39;application en utilisant la fonction <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm"><span class="inline" style="font-size: 14px">display_set_gui_size ()</span></a>.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Tirage avant et après le tirage</a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"> Les événements Pre Draw et Post Draw font partie de la catégorie Draw Event. Cependant, contrairement aux autres événements Draw, ceux-ci dessinent <em>directement</em> dans la <a class="glossterm" data-glossterm="tampon d&#39;affichage" href="#">mémoire tampon d&#39;affichage</a>, qui sera la taille de l&#39;espace d&#39;écran combiné pour toutes les fenêtres actuellement visibles, <em>ou</em> la taille de la fenêtre si vous n&#39;utilisez qu&#39;une seule fenêtre ou aucune fenêtre du tout. L&#39;image ci-dessous illustre ceci:</p><p class="dropspot"><img alt="Object Editor Post Draw" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_PostDraw.png" /> Ainsi, si vous utilisez les événements Pre ou Post Draw, vous dessinez vers la cible de rendu plein écran (tampon d&#39;affichage) qui aura la même taille que la fenêtre à laquelle toutes les fenêtres sont conçues pour s&#39;adapter. Si vous n&#39;avez aucune fenêtre active, celle-ci est à la place définie sur la taille de la fenêtre elle-même.</p><p class="dropspot"> L&#39;événement Pre Draw est déclenché avant tout autre événement de dessin, et vous pouvez y définir des valeurs, définir des propriétés de dessin et même dessiner des objets sans vous soucier des fenêtres ou de la taille du calque de l&#39;interface graphique (la taille du calque de l&#39;interface graphique peut être la même que celle du tampon d&#39;écran, mais ce n&#39;est peut-être pas le cas puisque vous pouvez définir la résolution de l&#39;interface graphique dans le code).</p><p class="dropspot"> Il convient de noter que cet événement se produit <em>avant que</em> le tampon d&#39;affichage ne soit effacé pour le dessin normal, ce qui signifie que si vous ne désactivez pas l&#39;effacement de vue dans l&#39;éditeur de pièce, rien de ce qui est dessiné dans l&#39;événement Pre Draw ne sera vu, comme le premier dessin de la fenêtre. va l&#39;effacer. Si vous voulez pouvoir voir à travers les fenêtres elles-mêmes, ou si vous n&#39;utilisez pas du tout les fenêtres, vous devez également avoir défini la couleur d&#39;arrière-plan pour avoir un alpha de 0 dans l&#39; <strong><a href="../Rooms.htm">éditeur de pièce</a></strong>.</p><p class="note"> <strong>REMARQUE</strong>: si vous désactivez ces options, vous remarquerez peut-être que des artefacts indésirables sont dessinés à l&#39;écran lorsque le jeu est testé (comme des «traces» d&#39;instances). Cela est dû au fait que vous dessinez directement sur l&#39;image précédente du tampon d&#39;affichage sans qu&#39;elle soit effacée. Cependant, vous pouvez utiliser <span class="inline" style="font-size: 14px"><a href="../../GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm">draw_clear_alpha ()</a></span> pour le faire vous-même.</p><p class="dropspot"> L&#39;événement Post Draw est déclenché <em>après</em> tous les événements de dessin standard, mais <em>avant</em> les événements de l&#39;interface graphique Draw. Comme l&#39;événement Pre Draw, il est basé sur la taille de la mémoire tampon d&#39;affichage et est placé avant les événements Draw GUI pour vous permettre d&#39;effectuer des effets de post-traitement et d&#39;autres choses sur une base plein écran simplement et facilement sans interférer avec aucun <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> / <a class="glossterm" data-glossterm="GUI" href="#">Éléments d&#39;interface graphique</a> que vous pouvez avoir dans votre jeu.</p><p class="dropspot"></p></div><p> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Redimensionner la fenêtre</a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot"> Ce type d&#39;événement appartient à la catégorie Draw Event, et bien qu&#39;il ne dessine rien, il réagit aux changements dans le tampon d&#39;affichage - en particulier, il est conçu pour réagir au changement de la taille du tampon d&#39;affichage UWP lorsque la fenêtre de jeu est &quot;cassé&quot;.</p><p class="dropspot"> Sur la plate-forme cible UWP, il est important que vous détectiez tout redimensionnement de la mémoire tampon d&#39;affichage à partir du &quot;snapping&quot; de la fenêtre de jeu (lorsque l&#39;utilisateur fait glisser la fenêtre sur le côté de l&#39;écran, par exemple). Cet événement fera exactement cela et est déclenché chaque fois que la fenêtre est modifiée, vous permettant d&#39;ajouter ici un code personnalisé qui redimensionnera la vue ou repositionnera les <a class="glossterm" data-glossterm="HUD" href="#">éléments HUD</a> si nécessaire. Cette fonction est fournie comme un moyen pratique d&#39;éviter d&#39;avoir un code d&#39;événement d&#39;étape qui vérifie ces choses tout le temps.</p><p class="note"> <strong>REMARQUE</strong>: vous ne pouvez pas dessiner dans cet événement! Il est déclenché par le redimensionnement de la fenêtre et sert uniquement à capturer ce changement... tout dessin qui doit être fait doit encore être dans l&#39;un des autres événements de dessin. </p><p class="dropspot"></p></div><p></p><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="Object_Events.htm">Evénements d&#39;objets</a></div><div style="float:right"> Suivant: <a href="Async_Events.htm">Événements asynchrones</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Draw Events
Pre Draw Event
Post Draw Event
Draw Begin Event
Draw End Events
Draw GUI Events
Draw GUI Begin Event
Draw GUI End Event
Pre Draw Event
Post Draw Event
Window Resize Event
-->
  <!-- TAGS
draw_events
-->
</body>
</html>