<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Lecture audio</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page détaillant l&#39;événement asynchrone de lecture audio." />
  <meta name="rh-index-keywords" content="Objets - Événement de lecture audio asynchrone" />
  <meta name="search-keywords" content="Lecture audio,ev_audio_playback" />
  <link rel="stylesheet" type="text/css" href="../../../assets/css/default.css" />
</head>
<body><!--<div class="body-scroll" style="top: 150px;">--><h1> Lecture audio</h1><p><img alt="Audio Playback Event" class="center" src="../../../assets/Images/Asset_Editors/Async_AudioPlayback.png" /> Cet événement ne peut être déclenché que par les fonctions de lecture de la <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/Audio_Buffers.htm">file d&#39;attente audio</a> <a href="../../../GameMaker_Language/GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">et renverra une DS Map</a> stockée dans la variable <a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm"> <span class="inline">async_load</span></a>, contenant différentes paires clé / valeur relatives à la file d&#39;attente audio qui a déclenché l&#39;événement. L&#39;événement est déclenché par un <a class="glossterm" data-glossterm="rappeler" href="#">rappel</a> lorsque vous avez sélectionné une file d&#39;attente audio à lire et qu&#39;une mémoire tampon de cette file d&#39;attente audio est terminée.</p><p> Les clés suivantes seront disponibles dans la carte DS:</p><ul class="dropspotlist"><li class="dropspot"> &quot;<span class="inline">queue_id</span> &quot;- l&#39;index de la file d&#39;attente qui a fini de jouer, tel que renvoyé par la fonction <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_play_queue.htm"><span class="inline">audio_create_play_queue()</span></a>.</li><li class="dropspot"> &quot;<span class="inline">buffer_id</span> &quot;- l&#39;ID de la <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">mémoire tampon à partir de</a> laquelle la lecture n&#39;est plus effectuée.</li><li class="dropspot"> &quot;<span class="inline">queue_shutdown</span> &quot;- il est réglé sur 0 pendant la lecture normale et 1 lorsque l&#39;événement est reçu car <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_free_play_queue.htm"><span class="inline">audio_free_play_queue()</span></a> a été appelé. Lorsqu&#39;il est défini sur 1, vous ne souhaitez pas mettre d&#39;autres données en file d&#39;attente.</li></ul><p> Puisqu&#39;une file d&#39;attente audio peut être créée à partir de plusieurs tampons, cet événement peut être déclenché plusieurs fois pour une file d&#39;attente lorsque la fin de chaque section d&#39;audio tamponné est atteinte, d&#39;où la clé &quot;buffer_id&quot;.</p><p class="note"> <strong>REMARQUE</strong>: la variable <span class="inline" style="font-size: 14px">async_load</span> n&#39;est valide que dans les événements asynchrones, car la mappe DS qui pointe vers est créée au début de l&#39;événement, puis supprimée à nouveau à la fin, cette variable étant réinitialisée à la valeur -1. Cependant, toutes les autres structures de données créées à partir de l&#39;événement doivent être nettoyées à l&#39;aide des fonctions appropriées.</p><p> Dans l&#39;exemple d&#39;utilisation donné ci-dessous, nous allons créer une file d&#39;attente audio avec 10 sons audio tamponnés ajoutés, puis lire la file d&#39;attente:</p><p class="code">audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono);<br/> for (var i = 0; i &lt; 10; i++;)<br/>    {<br/>    audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));<br/>    }<br/> audio_play_sound(audio_queue,
    0, true);</p><p> Chaque étape du jeu maintenant que l&#39;enregistrement est détecté déclenchera un événement d&#39;enregistrement audio asynchrone où vous pouvez traiter l&#39;entrée enregistrée quelque chose comme ceci:</p><p class="code">var queue = async_load[? &quot;queue_id&quot;];<br/> var num = 0;<br/> if queue = audio_queue<br/>    {<br/>    for (var i = 0; i &lt; 10; i++;)<br/>       {<br/>       if async_load[? &quot;buffer_id&quot;] == audio_buffer[i]<br/>          {<br/>  buffer_seek(audio_buffer[i],
    buffer_seek_start, 0);<br/>          num = i;<br/>          }<br/>       }<br/>    if num == 9<br/>       {<br/>       audio_stop_sound(audio_queue);<br/>       audio_free_play_queue(audio_queue);<br/>       }<br/>  }
  </p><p> Ici, nous vérifions l&#39;ID de la file d&#39;attente et si c&#39;est celui que nous voulons, nous vérifions ensuite l&#39;ID du tampon pour voir quel tampon a fini d&#39;être lu. Nous définissons également une variable locale sur cette valeur d&#39;index pour vérification ultérieure et remettons le tampon au début de ce son. Une fois que notre variable locale atteint 9, indiquant que la file d&#39;attente est terminée, nous arrêtons la lecture du son et libérons la file d&#39;attente. </p><p></p><div class="droptext" data-targetname="drop-down"></div><p></p><p></p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Retour: <a href="../Async_Events.htm">Événements asynchrones</a></div><div style="float:right"> Suivant: <a href="Audio_Recording.htm">Enregistrement audio</a></div></div></div><h5> <span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Asynchronous Audio Playback Event
ev_audio_playback
Audio Playback
-->
  <!-- TAGS
ev_audio_playback
-->
</body>
</html>